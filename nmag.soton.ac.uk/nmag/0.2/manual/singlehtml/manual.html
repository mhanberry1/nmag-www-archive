

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>NMAG User Manual v0.2.1 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="None" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="manual.html#">NMAG User Manual v0.2.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <hr class="docutils" />
<div class="section" id="nmag-user-manual-nmagverstr">
<span id="id1"></span><h1>1&nbsp;&nbsp;&nbsp;NMAG User Manual (0.2.1)<a class="headerlink" href="manual.html#nmag-user-manual-nmagverstr" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Authors:</th><td class="field-body">Hans Fangohr, Thomas Fischbacher, Matteo Franchin, Giuliano Bordignon, Jacek Generowicz, Andreas Knittel, Michael Walter, Maximilian Albert</td>
</tr>
<tr class="field"><th class="field-name">Licence:</th><td class="field-body"><a class="reference external" href="http://www.gnu.org/licenses/gpl2.txt">GNU General Public License (GPL) version 2</a></td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">0.2.1</td>
</tr>
<tr class="field"><th class="field-name">Date:</th><td class="field-body">Manual generated on 2012-01-14 at 23:58.</td>
</tr>
<tr class="field"><th class="field-name">Home page:</th><td class="field-body"><a class="reference external" href="../../../../index.html">http://nmag.soton.ac.uk</a></td>
</tr>
</tbody>
</table>
<img alt="_images/nmaglogo500.png" class="align-center" src="_images/nmaglogo500.png" style="width: 500px; height: 189px;" />
<ul>
<li class="toctree-l1"><a class="reference internal" href="manual.html#document-introduction">1. Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-introduction#nmag-philosophy">1.1. Nmag Philosophy</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-introduction#how-to-read-this-document">1.2. How to read this document</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-introduction#development-status">1.3. Development status</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-introduction#mailing-list">1.4. Mailing list</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-introduction#nmag-announce">1.4.1. nmag-announce</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-introduction#nmag-users">1.4.2. nmag-users</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-introduction#support">1.5. Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-introduction#license-and-disclaimer">1.6. License and Disclaimer</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="manual.html#document-guided_tour">2. Guided Tour</a><ul>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example1/doc">2.1. Example: Demag field in uniformly magnetised sphere</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example1/doc#importing-nmag">2.1.1. Importing nmag</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example1/doc#creating-the-simulation-object">2.1.2. Creating the simulation object</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example1/doc#defining-magnetic-materials">2.1.3. Defining (magnetic) materials</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example1/doc#loading-the-mesh">2.1.4. Loading the mesh</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example1/doc#setting-the-initial-magnetisation">2.1.5. Setting the initial magnetisation</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example1/doc#setting-the-external-field">2.1.6. Setting the external field</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example1/doc#extracting-and-saving-data">2.1.7. Extracting and saving data</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example2/doc">2.2. Example 2: Computing the time development of a system</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example2/doc#mesh-generation">2.2.1. Mesh generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example2/doc#the-simulation">2.2.2. The simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example2/doc#analysing-the-data">2.2.3. Analysing the data</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example2/doc#higher-level-functions">2.2.4. Higher level functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example2/doc#relaxing-the-system">2.2.5. &#8220;Relaxing&#8221; the system</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example2/doc#relaxing-the-system-faster">2.2.6. &#8220;Relaxing&#8221; the system faster</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example2/doc#decreasing-execution-time">2.2.7. Decreasing execution time</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_hysteresis_ellipsoid/doc">2.3. Example: Simple hysteresis loop</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_hysteresis_ellipsoid/doc#hysteresis-simulation-script">2.3.1. Hysteresis simulation script</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_hysteresis_ellipsoid/doc#hysteresis-loop-computation">2.3.2. Hysteresis loop computation</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_hysteresis_ellipsoid/doc#obtaining-the-hysteresis-loop-data">2.3.3. Obtaining the hysteresis loop data</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_hysteresis_ellipsoid/doc#plotting-the-hysteresis-loop-with-gnuplot">2.3.4. Plotting the hysteresis loop with Gnuplot</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_stoner_wohlfarth/doc">2.4. Example: Hysteresis loop for Stoner-Wohlfarth particle</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_stoner_wohlfarth/doc#plotting-the-hysteresis-loop">2.4.1. Plotting the hysteresis loop</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_hysteresis_disk/doc">2.5. Example: Hysteresis loop for thin disk</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_hysteresis_disk/doc#thin-disk-hysteresis-loop">2.5.1. Thin disk hysteresis loop</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_vortex/doc">2.6. Example: Vortex formation and propagation in disk</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_manipulate/doc">2.7. Example: Manipulating magnetisation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_manipulate/doc#modifying-the-magnetisation">2.7.1. Modifying the magnetisation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_ipython/doc">2.8. Example: IPython</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_pinning/doc">2.9. Example: Pinning Magnetisation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_pinning/doc#pinning-simulation-script">2.9.1. Pinning simulation script</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_pinning/doc#pinning-magnetisation">2.9.2. Pinning magnetisation</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_pinning/doc#visualisation">2.9.3. Visualisation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_uniaxial_anis/doc">2.10. Example: Uniaxial anisotropy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_uniaxial_anis/doc#uniaxial-anisotropy-simulation-script">2.10.1. Uniaxial anisotropy simulation script</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_uniaxial_anis/doc#visualization">2.10.2. Visualization</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_uniaxial_anis/doc#comparison">2.10.3. Comparison</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_cubic_anis/doc">2.11. Example: Cubic Anisotropy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_cubic_anis/doc#cubic-anisotropy-simulation-script">2.11.1. Cubic anisotropy simulation script</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_cubic_anis/doc#analyzing-the-result">2.11.2. Analyzing the result</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_user_anis/doc">2.12. Example: Arbitrary Anisotropy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_user_anis/doc#arbitrary-anisotropy-simulation-script">2.12.1. Arbitrary anisotropy simulation script</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_user_anis/doc#the-result">2.12.2. The result</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_restart/doc">2.13. Restart example</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_restart/doc#saving-the-state-of-the-simulation">2.13.1. Saving the state of the simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_restart/doc#starting-and-restarting-the-simulation">2.13.2. Starting and restarting the simulation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_changing_space_time_field/doc">2.14. Applying a field that changes both in time and in space</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_changing_space_time_field/doc#idea-pass-simulation-object-to-field-setting-function">2.14.1. Idea: pass simulation object to field-setting function</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_changing_space_time_field/doc#complete-example-simple-moving-write-head-example">2.14.2. Complete example: simple moving write-head example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_two_materials/doc">2.15. Example: two different magnetic materials</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_larmor/doc">2.16. Example: Larmor precession</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_1Dperiodicity/doc">2.17. Example: 1D periodicity</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_1Dperiodicity/doc#introduction-periodic-boundary-conditions-macro-geometry">2.17.1. Introduction periodic boundary conditions (&#8220;macro geometry&#8221;)</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_1Dperiodicity/doc#d-example">2.17.2. 1d example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_2Dperiodicity/doc">2.18. Example: 2D periodicity</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_periodic_spinwaves/doc">2.19. Example: Spin-waves in periodic system</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_periodic_spinwaves/doc#relaxation-script">2.19.1. Relaxation script</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_periodic_spinwaves/doc#visualising-the-magnetisation-evolution">2.19.2. Visualising the magnetisation evolution</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example2/doc2">2.20. Example: post processing of saved field data</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_zhangli1/doc">2.21. Example: Spin transfer torque (Zhang-Li model)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_zhangli1/doc#current-driven-motion-of-a-vortex-in-a-thin-film">2.21.1. Current-driven motion of a vortex in a thin film</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_zhangli1/doc#part-i-relaxation">2.21.2. Part I: Relaxation</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_zhangli1/doc#part-ii-current-driven-dynamics">2.21.3. Part II: Current driven dynamics</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_zhangli1/doc#standard-problem">2.21.4. Standard problem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_zhangli2/doc">2.22. Example: Current-driven magnetisation precession in nanopillars</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_zhangli2/doc#two-simulations-in-one-single-script">2.22.1. Two simulations in one single script</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_zhangli2/doc#results-precession-of-the-magnetisation">2.22.2. Results: precession of the magnetisation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-mesh_distortion/doc">2.23. Mesh distortion for edge roughness simulation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-mesh_distortion/doc#example">2.23.1. Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-mesh_distortion/doc#details-and-command-line-options">2.23.2. Details and command line options</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_phi_BEM_hlib/doc">2.24. Compression of the Boundary Element Matrix using HLib</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_phi_BEM_hlib/doc#hierarchical-matrices-in-micromagnetism">2.24.1. Hierarchical Matrices in Micromagnetism</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_phi_BEM_hlib/doc#installation-of-hlib">2.24.2. Installation of HLib</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_phi_BEM_hlib/doc#testing-the-hlib-bem-matrix-compression">2.24.3. Testing the HLib BEM Matrix compression</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_phi_BEM_hlib/doc#using-hlib-example-1-demagnetisation-field-of-a-sphere">2.24.4. Using HLib example 1: Demagnetisation Field of a Sphere</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_phi_BEM_hlib/doc#using-hlib-example-2-thin-films">2.24.5. Using HLib Example 2: Thin Films</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_phi_BEM_hlib/doc#hlib-and-mpi">2.24.6. HLib and MPI</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_nmagprobe/doc">2.25. Example: Calculation of dispersion curves</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_nmagprobe/doc#the-system-thesystem-py">2.25.1. The system: <tt class="docutils literal"><span class="pre">thesystem.py</span></tt></a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_nmagprobe/doc#part-i-relaxation-py">2.25.2. Part I: <tt class="docutils literal"><span class="pre">relaxation.py</span></tt></a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_nmagprobe/doc#part-ii-dynamics-py">2.25.3. Part II: <tt class="docutils literal"><span class="pre">dynamics.py</span></tt></a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_nmagprobe/doc#postprocessing-the-data">2.25.4. Postprocessing the data</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_tolerances/doc">2.26. Example: Timestepper tolerances</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_tolerances/doc#hysteris-loop-calculation-not-converging-a-word-of-warning">2.26.1. Hysteris loop calculation not converging? A word of warning ...</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_mpi1/doc">2.27. Example: Parallel execution (MPI)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_mpi1/doc#using-mpich2">2.27.1. Using mpich2</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_mpi1/doc#using-mpich1">2.27.2. Using mpich1</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_mpi1/doc#visualising-the-partition-of-the-mesh">2.27.3. Visualising the partition of the mesh</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-example_mpi1/doc#performance">2.27.4. Performance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_mpi1/doc#restarting-mpi-runs">2.28. Restarting MPI runs</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-example_excoupling/doc">2.29. More than one magnetic material, exchange coupled</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="manual.html#document-background">3. Background</a><ul>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-background#architecture-overview">3.1. Architecture overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-background#the-nsim-library">3.2. The nsim library</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-background#fields-and-subfields">3.3. Fields and subfields</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-background#field">3.3.1. Field</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-background#subfield">3.3.2. Subfield</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-background#fields-and-subfields-in-nmag">3.4. Fields and Subfields in Nmag</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-background#example-one-magnetic-material">3.4.1. Example: one magnetic material</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-background#example-two-magnetic-materials">3.4.2. Example: two magnetic materials</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-background#obtaining-and-setting-subfield-data">3.4.3. Obtaining and setting subfield data</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-background#primary-and-secondary-fields">3.4.4. Primary and secondary fields</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-background#mesh">3.5. Mesh</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-background#node">3.5.1. Node</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-background#node-id">3.5.2. node id</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-background#node-position">3.5.3. node position</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-background#site">3.6. Site</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-background#si-object">3.7. SI object</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-background#library-of-useful-si-constants">3.7.1. Library of useful si constants</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-background#terms">3.8. Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-background#stage-step-iteration-time-etc">3.8.1. Stage, Step, iteration, time, etc.</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-background#some-geek-talk-deciphered">3.8.2. Some geek-talk deciphered</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-background#solvers-and-tolerance-settings">3.9. Solvers and tolerance settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-background#the-equation-of-motion-the-landau-lifshitz-gilbert-equation">3.10. The equation of motion: the Landau-Lifshitz-Gilbert equation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="manual.html#document-command_reference">4. Command reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-command_reference#magmaterial">4.1. MagMaterial</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#uniaxial-anisotropy">4.1.1. uniaxial_anisotropy</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#cubic-anisotropy">4.1.2. cubic_anisotropy</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-command_reference#simulation">4.2. Simulation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#advance-time">4.2.1. advance_time</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#get-subfield">4.2.2. get_subfield</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#get-subfield-positions">4.2.3. get_subfield_positions</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#get-subfield-sites">4.2.4. get_subfield_sites</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#get-subfield-average">4.2.5. get_subfield_average</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#get-subfield-average-siv">4.2.6. get_subfield_average_siv</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#probe-subfield">4.2.7. probe_subfield</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#probe-subfield-siv">4.2.8. probe_subfield_siv</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#probe-h-demag-siv">4.2.9. probe_H_demag_siv</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#hysteresis">4.2.10. hysteresis</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#load-mesh">4.2.11. load_mesh</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#load-m-from-h5file">4.2.12. load_m_from_h5file</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#save-restart-file">4.2.13. save_restart_file</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#relax">4.2.14. relax</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#save-data">4.2.15. save_data</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#set-m">4.2.16. set_m</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#set-h-ext">4.2.17. set_H_ext</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#set-pinning">4.2.18. set_pinning</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#set-params">4.2.19. set_params</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-command_reference#get-subfield-from-h5file">4.3. get_subfield_from_h5file</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-command_reference#get-subfield-positions-from-h5file">4.4. get_subfield_positions_from_h5file</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-command_reference#get-subfield-sites-from-h5file">4.5. get_subfield_sites_from_h5file</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-command_reference#hmatrixsetup">4.6. HMatrixSetup</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-command_reference#si">4.7. SI</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#value">4.7.1. value</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#units">4.7.2. units</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#in-units-of">4.7.3. in_units_of</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-command_reference#is-compatible-with">4.7.4. is_compatible_with</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-command_reference#ipython">4.8. ipython</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-command_reference#command-line-options">4.9. Command line options</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="manual.html#document-finite_element_mesh_generation">5. Finite element mesh generation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-finite_element_mesh_generation#nmesh-file-format">5.1. Nmesh file format</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-finite_element_mesh_generation#ascii-nmesh">5.1.1. Ascii nmesh</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-finite_element_mesh_generation#hdf5-nmesh">5.1.2. Hdf5 nmesh</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-finite_element_mesh_generation#mesh-file-size">5.2. mesh file size</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="manual.html#document-executables">6. Executables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-executables#ncol">6.1. ncol</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-executables#nmagpp">6.2. nmagpp</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-executables#inspecting-the-content">6.2.1. Inspecting the content</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-executables#dumping-data">6.2.2. Dumping data</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-executables#range-of-data-to-be-processed">6.2.3. Range of data to be processed</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-executables#conversion-to-vtk-file">6.2.4. Conversion to vtk file</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-executables#other-features">6.2.5. Other features</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-executables#nmeshpp">6.3. nmeshpp</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-executables#general-information-info">6.3.1. General information (<tt class="docutils literal"><span class="pre">--info</span></tt>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-executables#memory-requirements-of-boundary-element-matrix">6.3.2. Memory requirements of boundary element matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-executables#inspecting-the-quality-of-a-mesh">6.3.3. Inspecting the quality of a mesh</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-executables#histogram-of-edge-lengths">6.3.4. Histogram of edge lengths</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-executables#convert-nmesh-h5-to-nmesh-file-and-back">6.4. Convert nmesh.h5 to nmesh file (and back)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-executables#nmeshmirror">6.4.1. nmeshmirror</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-executables#nmeshsort">6.4.2. nmeshsort</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-executables#nmeshimport">6.5. nmeshimport</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-executables#nsim">6.6. nsim</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-executables#nsimversion">6.7. nsimversion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="manual.html#document-files_and_file_names">7. Files and file names</a><ul>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-files_and_file_names#mesh-files-nmesh-nmesh-h5">7.1. mesh files (<tt class="docutils literal"><span class="pre">.nmesh</span></tt>, <tt class="docutils literal"><span class="pre">.nmesh.h5</span></tt>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-files_and_file_names#simulation-scripts-py">7.2. Simulation scripts (<tt class="docutils literal"><span class="pre">.py</span></tt>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-files_and_file_names#data-files-ndt">7.3. Data files (<tt class="docutils literal"><span class="pre">.ndt</span></tt>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-files_and_file_names#data-files-h5">7.4. Data files (<tt class="docutils literal"><span class="pre">.h5</span></tt>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-files_and_file_names#file-names-for-data-files">7.5. File names for data files</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-files_and_file_names#file-names-for-log-files">7.6. File names for log files</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="manual.html#document-faq">8. Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#what-is-the-difference-between-the-oommf-and-nmag-approach">8.1. What is the difference between the OOMMF and nmag approach?</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#so-this-means-the-major-difference-is-cubes-vs-tetrahedra">8.2. ... So, this means the major difference is &#8220;cubes&#8221; vs. &#8220;tetrahedra&#8221;?</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#why-do-you-have-your-own-python-interpreter-nsim">8.3. Why do you have your own Python interpreter (=<tt class="docutils literal"><span class="pre">nsim</span></tt>)?</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#what-is-nsim-i-thought-the-package-is-called-nmag">8.4. What is nsim - I thought the package is called nmag?</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#how-fast-is-nmag-in-comparison-to-magpar">8.5. How fast is nmag in comparison to magpar?</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#how-do-i-start-a-time-consuming-nmag-run-in-the-background">8.6. How do I start a time-consuming nmag run in the background?</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#nmag-claims-to-support-mpi-so-can-i-run-simulation-jobs-on-multiple-processors">8.7. nmag claims to support MPI. So, can I run simulation jobs on multiple processors?</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#how-should-i-cite-nmag">8.8. How should I cite nmag?</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#why-can-you-not-use-the-step-as-a-unique-identifier">8.9. Why can you not use the step as a unique identifier?</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#how-to-generate-a-mesh-with-more-than-one-region-using-gmsh">8.10. How to generate a mesh with more than one region using GMSH?</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#can-i-run-more-than-one-simulation-in-one-directory">8.11. Can I run more than one simulation in one directory?</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#can-i-save-data-to-an-arbitrary-directory">8.12. Can I save data to an arbitrary directory?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-faq#do-you-really-need-to-do-so">8.12.1. Do you really need to do so?</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-faq#how-to-save-data-to-a-different-directory">8.12.2. How to save data to a different directory</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#how-to-check-the-convergence-of-a-simulation">8.13. How to check the convergence of a simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#what-to-do-in-case-of-convergence-problems">8.14. What to do in case of convergence problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#how-to-visualise-the-difference-between-two-fields-defined-over-the-same-mesh">8.15. How to visualise the difference between two fields defined over the same mesh</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#how-to-re-sample-data-from-a-saved-h5-file">8.16. How to re-sample data from a saved h5 file</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-faq#notes-on-using-gmsh-to-create-a-family-of-related-meshes">8.17. Notes on using GMSH to create a family of related meshes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="manual.html#document-useful_tools">9. Useful tools</a><ul>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-useful_tools#vtk">9.1. vtk</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-useful_tools#mayavi">9.2. MayaVi</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-useful_tools#numpy">9.3. NumPy</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="manual.html#document-contact">10. Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="manual.html#document-tutorial/doc">11. Mini tutorial micromagnetic modelling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-tutorial/doc#introduction-micromagnetic-modelling">11.1. Introduction micromagnetic modelling</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-tutorial/doc#what-is-better-finite-differences-or-finite-elements">11.2. What is better: finite differences or finite elements?</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-tutorial/doc#what-size-of-the-cells-fd-and-tetrahedra-fe-should-i-choose">11.3. What size of the cells (FD) and tetrahedra (FE) should I choose?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-tutorial/doc#exchange-length">11.3.1. Exchange length</a></li>
<li class="toctree-l3"><a class="reference internal" href="manual.html#document-tutorial/doc#further-reading">11.3.2. Further reading</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-tutorial/doc#micromagnetic-packages">11.4. Micromagnetic packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="manual.html#document-tutorial/doc#summary">11.5. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="manual.html#document-acknowledgements">12. Acknowledgements</a></li>
</ul>
<div class="toctree-wrapper compound">
<span id="document-introduction"></span><div class="section" id="introduction">
<span id="id1"></span><h2>Introduction<a class="headerlink" href="manual.html#introduction" title="Permalink to this headline">¶</a></h2>
<p>Nmag is a flexible finite element micromagnetic simulation
package with an user interface based on the
<a class="reference external" href="http://www.python.org">Python</a> programming language.</p>
<p>If you use Nmag in your published work, please cite:</p>
<ul class="simple">
<li>Thomas Fischbacher, Matteo Franchin, Giuliano Bordignon, and Hans
Fangohr.  <em>A Systematic Approach to Multiphysics Extensions of
Finite-Element-Based Micromagnetic Simulations: Nmag</em>, in IEEE
Transactions on Magnetics, <strong>43</strong>, 6, 2896-2898 (2007). (Available <a class="reference external" href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4202717">online</a>)</li>
</ul>
<div class="section" id="nmag-philosophy">
<span id="id2"></span><h3>Nmag Philosophy<a class="headerlink" href="manual.html#nmag-philosophy" title="Permalink to this headline">¶</a></h3>
<p>Many specialized simulation codes used in research today
consist of a highly specialized core application which initially was
written to simulate the behaviour of some very specific
system. Often, the core application then evolved into a more broadly
applicable tool through the introduction of additional
parameters. Some simulation codes reach a point where it becomes
evident that they need an amount of flexibility that can only be
provided by including some script programming capabilities.</p>
<p>The approach underlying Nmag turns this very common pattern of
software evolution (which we also have seen in web browsers, CAD
software, word processors, etc) on its head: rather than gradually
providing more and more flexibility in an ad-hoc manner through adding
configuration parameters, slowly evolving into an extensive
specialized programming language, Nmag starts out as an extension to
a widely used programming language (<a class="reference external" href="http://www.python.org">Python</a>) from which it gains all its
flexibility and evolves towards more specialized notions to
conveniently define and study the properties of very specific physical
systems <a class="footnote-reference" href="manual.html#fischbacheretal1" id="id3">[1]</a>.</p>
<p>The main advantage of this approach is two-fold: first, we do not
gradually evolve another ad-hoc (and potentially badly implemented)
special purpose programming language. Second, by drawing upon the
capabilities of a well supported existing framework for flexibility,
we get a lot of additional power for free: the user can employ readily
available and well supported Python libraries for tasks such as data
post-processing and analysis, e.g. generating images for web pages
etc. In addition to this, some users may benefit from the capability
to use Nmag interactively from a command prompt, which can be very
helpful during the development phase of an involved simulation script <a class="footnote-reference" href="manual.html#fischbacheretal2" id="id4">[2]</a>.</p>
<p>The disadvantage is of course that a novice user may be confronted
with much more freedom than he can handle. We try to cope with this
issue by providing a collection of example scripts (in the <a class="reference internal" href="manual.html#guided-tour"><em>Guided Tour</em></a>) for the most common applications that only need very slight
modification for basic use (e.g. changing of the mesh filename or
material parameters).</p>
<p>At present, Nmag is based on the Python programming language. This
seems to be a somewhat reasonable choice at present, as Python is
especially friendly towards casual users who do not want to be forced
to first become expert programmers before they can produce any useful
results. Furthermore, Python is quite widespread and widely supported
these days.</p>
<table class="docutils footnote" frame="void" id="fischbacheretal1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id3">[1]</a></td><td>Thomas Fischbacher, Matteo Franchin, Giuliano Bordignon,, Hans Fangohr, <em>A Systematic Approach to Multiphysics Extensions of Finite-Element-Based Micromagnetic Simulations: Nmag</em>, IEEE Transactions on Magnetics <strong>43</strong>, 6, 2896-2898 (2007), online at <a class="reference external" href="http://eprints.soton.ac.uk/46725/">http://eprints.soton.ac.uk/46725/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fischbacheretal2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id4">[2]</a></td><td>Thomas Fischbacher, Matteo Franchin, Giuliano Bordignon, Andreas Knittel, Hans Fangohr, <em>Parallel execution and scriptability in micromagnetic simulations</em>, Journal of Applied Physics <strong>105</strong>, 07D527 (2009), online at <a class="reference external" href="http://link.aip.org/link/?JAPIAU/105/07D527/1">http://link.aip.org/link/?JAPIAU/105/07D527/1</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="how-to-read-this-document">
<span id="id5"></span><h3>How to read this document<a class="headerlink" href="manual.html#how-to-read-this-document" title="Permalink to this headline">¶</a></h3>
<p>We suggest you follow the <a class="reference internal" href="manual.html#guided-tour"><em>Guided Tour</em></a> through a number of examples
to get a quick overview of what nmag looks like in real use, and to
see examples that can be used to carry out typical simulations. We
provide a number of skeletons that are easily adapted to specific
systems which show how to compute hysteresis loops, do energy
minimisation, or compute time evolution.</p>
<p>The <a class="reference internal" href="manual.html#command-reference"><em>Command reference</em></a> section explains the relevant commands
provided by Nmag in full detail. This should be especially useful to
advanced users who want to design sophisticated simulation scripts in
Python.</p>
<p>If you are new to micromagnetic modelling, you may want to start with
the <a class="reference internal" href="manual.html#mini-tutorial-micromagnetic-modelling"><em>Mini tutorial micromagnetic modelling</em></a>.</p>
</div>
<div class="section" id="development-status">
<span id="id6"></span><h3>Development status<a class="headerlink" href="manual.html#development-status" title="Permalink to this headline">¶</a></h3>
<p>The first Nmag release was late in 2007, and many bugs have been fixed
since then. Having said that, without doubt there are bugs left in the
system, and there is a long list of wishes for extra features,
changes, improvements.</p>
<p>Currently, there is no significant amount of funding or man power
available to support Nmag users or develop it further. The software should
thus be seen to be provided as is.</p>
<p>Should you use Nmag for your work, please cite</p>
<ul class="simple">
<li>Thomas Fischbacher, Matteo Franchin, Giuliano Bordignon, and Hans Fangohr,
<em>A Systematic Approach to Multiphysics Extensions of Finite-Element-Based Micromagnetic Simulations: Nmag</em>,
IEEE Transactions on Magnetics <strong>43</strong>, 6, 2896-2898 (2007),
online: <a class="reference external" href="http://eprints.soton.ac.uk/46725/1/Fisc_07.pdf">preprint</a> and <a class="reference external" href="http://dx.doi.org/10.1109/TMAG.2007.893843">http://dx.doi.org/10.1109/TMAG.2007.893843</a></li>
</ul>
<p>to demonstrate the value of open-source infrastructure in the
community. (We should also cite the corresponding recommended
publications when using OOMMF, Magpar, Mumax, MicroMagnum etc).</p>
</div>
<div class="section" id="mailing-list">
<span id="id7"></span><h3>Mailing list<a class="headerlink" href="manual.html#mailing-list" title="Permalink to this headline">¶</a></h3>
<p>If you are using nmag, we recommend that you subscribe to at least
one of these following two lists. If you have a question about how to use the software, we
suggest you subscribe to <a class="reference internal" href="manual.html#nmag-users"><em>nmag-users</em></a>, and post it there.</p>
<div class="section" id="nmag-announce">
<span id="id8"></span><h4>nmag-announce<a class="headerlink" href="manual.html#nmag-announce" title="Permalink to this headline">¶</a></h4>
<p><strong>nmag-announce&#64;lists.soton.ac.uk</strong> is a low traffic read-only mailing
list which will broadcast updates of nmag and any other relevant news.</p>
<p>To subscribe to this list, send an email to
<a class="reference external" href="mailto:nmag-announce-request&#37;&#52;&#48;lists&#46;soton&#46;ac&#46;uk">nmag-announce-request<span>&#64;</span>lists<span>&#46;</span>soton<span>&#46;</span>ac<span>&#46;</span>uk</a> with an empty
subject and the word <tt class="docutils literal"><span class="pre">subscribe</span></tt> in the body of the email.</p>
<p>The <strong>archives</strong> can be found and searched at
<a class="reference external" href="http://groups.google.com/group/nmag-announce">http://groups.google.com/group/nmag-announce</a>.</p>
</div>
<div class="section" id="nmag-users">
<span id="id9"></span><h4>nmag-users<a class="headerlink" href="manual.html#nmag-users" title="Permalink to this headline">¶</a></h4>
<p><strong>nmag-users&#64;lists.soton.ac.uk</strong> is a mailing list to discuss the use of
nmag, and for users to support users. Any announcements to <tt class="docutils literal"><span class="pre">nmag-announce</span></tt> will also be sent to this
mailing list.</p>
<p>To subscribe to this list, send an email to
<a class="reference external" href="mailto:nmag-users-request&#37;&#52;&#48;lists&#46;soton&#46;ac&#46;uk">nmag-users-request<span>&#64;</span>lists<span>&#46;</span>soton<span>&#46;</span>ac<span>&#46;</span>uk</a> with an empty subject
and the word <tt class="docutils literal"><span class="pre">subscribe</span></tt> in the body of the email.</p>
<p>Information about how to unsubscribe are provided with the welcome
message once you have subscribed.</p>
<p>The <strong>archives</strong> can be found and searched at
<a class="reference external" href="http://groups.google.com/group/nmag-users">http://groups.google.com/group/nmag-users</a>.</p>
</div>
</div>
<div class="section" id="support">
<span id="id10"></span><h3>Support<a class="headerlink" href="manual.html#support" title="Permalink to this headline">¶</a></h3>
<p>Support will be provided within our limited resources (which may be None). After
consulting the manual, please feel free to use the <a class="reference internal" href="manual.html#mailing-list"><em>Mailing list</em></a>
<tt class="docutils literal"><span class="pre">nmag-users&#64;lists.soton.ac.uk</span></tt> to seek advice, or contact the
<a class="reference internal" href="manual.html#contact"><em>nmag team</em></a> directly.</p>
</div>
<div class="section" id="license-and-disclaimer">
<span id="id11"></span><h3>License and Disclaimer<a class="headerlink" href="manual.html#license-and-disclaimer" title="Permalink to this headline">¶</a></h3>
<p>This software was developed at the University of Southampton, United
Kingdom. It is released under the GNU General Public License (<a class="reference external" href="http://www.gnu.org/licenses/gpl2.txt">GPL</a>) as
published by the Free Software Foundation; either version 2, or (at
your option) any later version.</p>
<p>Nmag is an experimental system. Neither the University of
Southampton nor the authors assume any responsibility whatsoever for
its use by other parties, and makes no guarantees, expressed or
implied, about its quality, reliability, or any other characteristic.</p>
</div>
</div>
<span id="document-guided_tour"></span><div class="section" id="guided-tour">
<span id="id1"></span><h2>Guided Tour<a class="headerlink" href="manual.html#guided-tour" title="Permalink to this headline">¶</a></h2>
<p>We present a number of worked out examples that are explained in
detail and should cover most of the usual applications. (You may also
want to check the <a class="reference internal" href="manual.html#frequently-asked-questions"><em>Frequently Asked Questions</em></a>.)</p>
<div class="toctree-wrapper compound">
<span id="document-example1/doc"></span><div class="section" id="example-demag-field-in-uniformly-magnetised-sphere">
<span id="example-1"></span><h3>Example: Demag field in uniformly magnetised sphere<a class="headerlink" href="manual.html#example-demag-field-in-uniformly-magnetised-sphere" title="Permalink to this headline">¶</a></h3>
<p>This is the most basic example that computes the demagnetisation field
in an uniformly magnetised sphere. For this simple system, the exact
result is known analytically: the demag field vector has to be equal
to minus one-third of the magnetisation vector, everywhere.</p>
<p>When using finite element calculations, a crucial (and non-trivial)
part of the work is the <a class="reference internal" href="manual.html#finite-element-mesh-generation"><em>finite element mesh generation</em></a>. We provide
a very small mesh for this example (<a class="reference download internal" href="_downloads/sphere1.nmesh.h5"><tt class="xref download docutils literal"><span class="pre">sphere1.nmesh.h5</span></tt></a>) which was generated with <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a>
(from this <a class="reference download internal" href="_downloads/sphere1.geo"><tt class="xref download docutils literal"><span class="pre">geometry</span> <span class="pre">file</span></tt></a>). This gives us
a sphere of radius 10nm.</p>
<img alt="_images/spheremesh.png" class="align-center" src="_images/spheremesh.png" style="width: 325px; height: 327px;" />
<p>We can then use the following nmag script <a class="reference download internal" href="_downloads/sphere1.py"><tt class="xref download docutils literal"><span class="pre">sphere1.py</span></tt></a>:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span>

<span class="c">#create simulation object</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>

<span class="c"># define magnetic material</span>
<span class="n">Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;Py&#39;</span><span class="p">,</span>
                      <span class="n">Ms</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e6</span><span class="p">,</span> <span class="s">&#39;A/m&#39;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&#39;J/m&#39;</span><span class="p">))</span>

<span class="c"># load mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&#39;sphere1.nmesh.h5&#39;</span><span class="p">,</span>
              <span class="p">[(</span><span class="s">&#39;sphere&#39;</span><span class="p">,</span> <span class="n">Py</span><span class="p">)],</span>
              <span class="n">unit_length</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&#39;m&#39;</span><span class="p">))</span>

<span class="c"># set initial magnetisation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="c"># set external field</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_H_ext</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">SI</span><span class="p">(</span><span class="s">&#39;A/m&#39;</span><span class="p">))</span>

<span class="c"># Save and display data in a variety of ways</span>
<span class="n">sim</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">)</span> <span class="c"># save all fields spatially resolved</span>
                            <span class="c"># together with average data</span>

<span class="c"># sample demag field through sphere</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="mf">1e-9</span>                      <span class="c">#position in metres</span>
    <span class="n">H_demag</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">probe_subfield_siv</span><span class="p">(</span><span class="s">&#39;H_demag&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">print</span> <span class="s">&quot;x =&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s">&quot;: H_demag = &quot;</span><span class="p">,</span> <span class="n">H_demag</span>
</pre></div>
</div>
</div></blockquote>
<p>To execute this script, we have to give its name to the <a class="reference internal" href="manual.html#nsim"><em>nsim</em></a>
executable, for example (on linux):</p>
<div class="highlight-python"><pre>$ nsim sphere1.py</pre>
</div>
<p>Some simulations produce output files which nsim will refuse to
overwrite when run for a second time. The rationale is that big
simulations may have to run for a long time and so, there should be a
safeguard against accidental destruction of data.</p>
<p>In order to re-run a simulation, removing all old output data files,
the extra option <tt class="docutils literal"><span class="pre">--clean</span></tt> should be given, as in:</p>
<div class="highlight-python"><pre>$ nsim sphere1.py --clean</pre>
</div>
<p>Let us discuss the <tt class="docutils literal"><span class="pre">sphere1.py</span></tt> script step by step.</p>
<div class="section" id="importing-nmag">
<span id="id1"></span><h4>Importing nmag<a class="headerlink" href="manual.html#importing-nmag" title="Permalink to this headline">¶</a></h4>
<p>First we need to import the nmag module, and any subpackages of nmag
that we want to use. (In this basic example, this is just the SI
module for dimensionful physical quantities).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span>
</pre></div>
</div>
</div>
<div class="section" id="creating-the-simulation-object">
<h4>Creating the simulation object<a class="headerlink" href="manual.html#creating-the-simulation-object" title="Permalink to this headline">¶</a></h4>
<p>Next, we need to create a simulation object. This will contain and
provide information about our physical system.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="defining-magnetic-materials">
<span id="id2"></span><h4>Defining (magnetic) materials<a class="headerlink" href="manual.html#defining-magnetic-materials" title="Permalink to this headline">¶</a></h4>
<p>After importing the nmag module into Python&#8217;s workspace and creating
the simulation object <tt class="docutils literal"><span class="pre">sim</span></tt>, we need to define a material using
<tt class="docutils literal"><span class="pre">nmag.MagMaterial</span></tt>. We give it a name (as a Python string) which in
this case we choose to be <tt class="docutils literal"><span class="pre">&quot;Py&quot;</span></tt> (a common abbreviation for
PermAlloy) and we assign a saturation magnetisation and an exchange
coupling strength.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;Py&#39;</span><span class="p">,</span>
                      <span class="n">Ms</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e6</span><span class="p">,</span> <span class="s">&#39;A/m&#39;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&#39;J/m&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>The name of the material is important, as we may want to simulate
systems made up of multiple different materials, and the material name
will be used as a postfix to the name of some <a class="reference internal" href="manual.html#fields-and-subfields"><em>Fields and subfields</em></a>.
The output files will also use that name to label output data. Names
must be alphanumeric (i.e. formed exclusively out of the characters in
the set <tt class="docutils literal"><span class="pre">0-9\_a-zA-Z</span></tt>) here.</p>
<p>Rather than representing dimensionful physical quantities as numbers,
nmag uses a special object class, the &#8220;SI object&#8221;. The underlying
rationale is that this allows automated detection of mismatches of
physical dimensions. If some physical parameter is given to nmag in a
dimension different from the expected one, nmag will detect this and
report an error. Also, any nmag output [e.g. a three-dimensional VTK
visualisation file] will provide a sufficient amount of contextual
information to clarify the physical meaning (i.e. dimensions) of
numerical data.</p>
<p>We thus express the saturation magnetisation in Ampere per meter (<tt class="docutils literal"><span class="pre">Ms</span>
<span class="pre">=</span> <span class="pre">SI(1e6,&quot;A/m&quot;)</span></tt>) and the exchange coupling constant (often called A
in micromagnetism) in Joules per meter (<tt class="docutils literal"><span class="pre">exchange_coupling</span> <span class="pre">=</span>
<span class="pre">SI(13.0e-12,</span> <span class="pre">&quot;J/m&quot;)</span></tt>). (Note that these are not the true physical
parameters of PermAlloy, but have been chosen ad hoc for the sake
of providing a simple example!)</p>
</div>
<div class="section" id="loading-the-mesh">
<span id="id3"></span><h4>Loading the mesh<a class="headerlink" href="manual.html#loading-the-mesh" title="Permalink to this headline">¶</a></h4>
<p>The next step is to load the mesh.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&#39;sphere1.nmesh.h5&#39;</span><span class="p">,</span>
              <span class="p">[(</span><span class="s">&#39;sphere&#39;</span><span class="p">,</span> <span class="n">Py</span><span class="p">)],</span>
              <span class="n">unit_length</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&#39;m&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>The first argument is the file name (<tt class="docutils literal"><span class="pre">&quot;sphere1.nmesh.h5&quot;</span></tt>). The
second argument is a list of tuples which describe the domains (also
called regions) within the mesh. In this example we have a one-element
list containing the 2-tuple <tt class="docutils literal"><span class="pre">(&quot;sphere&quot;,</span> <span class="pre">Py)</span></tt>. The left element of
this pair, <tt class="docutils literal"><span class="pre">&quot;sphere&quot;</span></tt>, is a string (of the user&#8217;s choice) and this
is the name given to mesh region 1 (i.e. the space occupied by all
simplices that have the region id 1 in the mesh file).</p>
<p>[This information is currently only used for debugging purposes (such
as when printing the simulation object).]</p>
<p>The second part of the tuple is the <tt class="docutils literal"><span class="pre">MagMaterial</span></tt> object that has
been created in <a class="reference internal" href="manual.html#defining-magnetic-materials"><em>Defining (magnetic) materials</em></a> and bound to the
variable <tt class="docutils literal"><span class="pre">Py</span></tt>. This object determines the material properties of the
material in this domain; in this example, we have specified the
properties of PermAlloy.</p>
<p>The third argument to <a class="reference internal" href="manual.html#load-mesh"><em>load_mesh</em></a> is an <a class="reference internal" href="manual.html#si-object"><em>SI object</em></a> which defines what
physical distance should be associated with the length 1.0 as given in
the mesh file. In this example, the mesh has been created in
nanometers, i.e. the distance 1.0 in the mesh file should correspond
to 1 nanometer in the real world. We thus use a SI object representing
1 nm.</p>
</div>
<div class="section" id="setting-the-initial-magnetisation">
<span id="id4"></span><h4>Setting the initial magnetisation<a class="headerlink" href="manual.html#setting-the-initial-magnetisation" title="Permalink to this headline">¶</a></h4>
<p>To set the initial magnetisation, we use the <a class="reference internal" href="manual.html#set-m"><em>set_m</em></a> method.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>The field <tt class="docutils literal"><span class="pre">m</span></tt> describes the direction of magnetisation (as a
field of normalised vectors) whereas the
field <tt class="docutils literal"><span class="pre">M</span></tt> contains the magnetisation with its proper magnitude.
So, <tt class="docutils literal"><span class="pre">|M|</span></tt> is the saturation magnetisation (in Amperes per meter),
whereas <tt class="docutils literal"><span class="pre">m</span></tt> is dimensionless with <tt class="docutils literal"><span class="pre">|m|=1.0</span></tt>. There are different
ways to set a particular magnetisation, in the simplest case of a
homogeneously magnetised body, it is sufficient to provide the
magnetisation vector. So, in this example, we provide a unit vector
pointing in positive x-direction. (We could provide a vector with
non-normalised magnitude, which would be normalised
automatically. This is convenient for, say, setting an initial
magnetisation in the x-y-plane with a 45 degree angle towards
the x axis by specifying <tt class="docutils literal"><span class="pre">[1,1,0]</span></tt>).</p>
</div>
<div class="section" id="setting-the-external-field">
<span id="id5"></span><h4>Setting the external field<a class="headerlink" href="manual.html#setting-the-external-field" title="Permalink to this headline">¶</a></h4>
<p>We can set the external field using the <a class="reference internal" href="manual.html#set-h-ext"><em>set_H_ext</em></a> command</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">set_H_ext</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">SI</span><span class="p">(</span><span class="s">&#39;A/m&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>In contrast to <a class="reference internal" href="manual.html#set-m"><em>set_m</em></a>, this method takes two arguments. The first
defines numerical values for the direction and magnitude of the
external field. The second determines the meaning of these numerical
values using an SI object. Suppose we would like an external field of
1e6 A/m acting in the y-direction, then the command would read:
<tt class="docutils literal"><span class="pre">sim.set_H_ext([0,1e6,0],SI(1,&quot;A/m&quot;))</span></tt>. However, we could also use
<tt class="docutils literal"><span class="pre">sim.set_H_ext([0,1,0],SI(1e6,&quot;A/m&quot;))</span></tt>.</p>
<p>The default value for the external field is [0,0,0] A/m, so for this
example, we could have omitted the <a class="reference internal" href="manual.html#set-h-ext"><em>set_H_ext</em></a> command altogether.</p>
</div>
<div class="section" id="extracting-and-saving-data">
<span id="id6"></span><h4>Extracting and saving data<a class="headerlink" href="manual.html#extracting-and-saving-data" title="Permalink to this headline">¶</a></h4>
<p>We have three different ways of extracting data from the simulation:</p>
<ol class="arabic simple">
<li>saving averaged values of fields (which can be analysed later)</li>
<li>saving spatially resolved fields (which can be analysed later)</li>
<li>extracting field values at arbitrary positions from within the
running program</li>
</ol>
<p>In this basic example, we demonstrate the use of all three methods:</p>
<div class="section" id="saving-averaged-data">
<span id="id7"></span><h5>Saving averaged data<a class="headerlink" href="manual.html#saving-averaged-data" title="Permalink to this headline">¶</a></h5>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">save_data</span><span class="p">()</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="manual.html#save-data"><em>save_data</em></a> method writes (spatial) averages of all fields (see
<a class="reference internal" href="manual.html#fields-and-subfields"><em>Fields and subfields</em></a>) into a text file (which will be named
<tt class="docutils literal"><span class="pre">sphere1_dat.ndt</span></tt>, see below). This file is best analysed using the
<a class="reference internal" href="manual.html#ncol"><em>ncol</em></a> tool but can also just be read with a text editor. The format
follows OOMMF&#8217;s <tt class="docutils literal"><span class="pre">odt</span></tt> file format: every row corresponds to one
snapshot of the system (see <a class="reference internal" href="manual.html#save-data"><em>save_data</em></a>).</p>
<p>The function can also be called with parameters to save spatially
resolved field data (see <a class="reference internal" href="manual.html#saving-spatially-resolved-data"><em>Saving spatially resolved data</em></a>).</p>
<p>The first and second line in the data file are headers that explain
(by column) the physical quantities (and their dimensions).</p>
<p>The <a class="reference internal" href="manual.html#ncol"><em>ncol</em></a> tool allows to extract particular columns easily so that
these can be plotted later (useful for hysteresis loop studies). In
this example we have only one &#8220;timestep&#8221;: there only is one row of
data in this file. We will therefore discuss this in more detail in a
subsequent example.</p>
</div>
<div class="section" id="extracting-arbitrary-data-from-the-running-program">
<span id="id8"></span><h5>Extracting arbitrary data from the running program<a class="headerlink" href="manual.html#extracting-arbitrary-data-from-the-running-program" title="Permalink to this headline">¶</a></h5>
<p>The line</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">H_demag</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">probe_subfield_siv</span><span class="p">(</span> <span class="s">&#39;H_demag&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>obtains the demagnetisation field (see <a class="reference internal" href="manual.html#fields-and-subfields-in-nmag"><em>Fields and Subfields in Nmag</em></a>) at position (x,0,0). The suffix &#8220;_siv&#8221; to this function means
that both positions and return values will be given as SI values.</p>
<p>The for-loop in the program (which iterates <tt class="docutils literal"><span class="pre">x</span></tt> in the range from
-10*1e-9 to 10*1e-9 in steps of 1e-9) produces the following output</p>
<div class="highlight-python"><pre>x = -1e-08 : H_demag =  None
x = -9e-09 : H_demag =  [-329655.76203912671, 130.62999726469423, 194.84338557811344]
x = -8e-09 : H_demag =  [-329781.46587966662, 66.963624669268853, 137.47161381890737]
x = -7e-09 : H_demag =  [-329838.57852402801, 181.46249265908259, 160.61298054099865]
x = -6e-09 : H_demag =  [-329899.63327447395, 131.06488858715838, 71.383139326493094]
x = -5e-09 : H_demag =  [-329967.79622912291, 82.209856975234786, -16.893046828024836]
x = -4e-09 : H_demag =  [-329994.67306536058, 61.622521557150371, -34.433041910642359]
x = -3e-09 : H_demag =  [-329997.62759666931, 23.222244635691535, -65.991127111463769]
x = -2e-09 : H_demag =  [-330013.90370482224, 10.11035370824321, -61.358763616681067]
x = -1e-09 : H_demag =  [-330023.50844056415, -6.9714476825652287, -54.900260456937708]
x = 0.0   : H_demag =  [-330030.98847923806, -26.808832466764223, -48.465748009067141]
x = 1e-09 : H_demag =  [-330062.38479507214, -38.660812022013424, -42.83439139610747]
x = 2e-09 : H_demag =  [-330093.78111090627, -50.512791577262625, -37.2030347831478]
x = 3e-09 : H_demag =  [-330150.72580001026, -64.552170478617398, -23.120555702674721]
x = 4e-09 : H_demag =  [-330226.19050178828, -77.236085707456397, -5.5373829923226916]
x = 5e-09 : H_demag =  [-330304.59300913941, -90.584413821813229, 14.090609104026118]
x = 6e-09 : H_demag =  [-330380.1392610991, -115.83746059068679, 37.072085708324757]
x = 7e-09 : H_demag =  [-330418.85831447819, -122.47512022500726, 62.379121138009992]
x = 8e-09 : H_demag =  [-330476.40747455234, -110.84257225592108, 108.06217226524763]
x = 9e-09 : H_demag =  [-330500.20126762061, -68.175725285038382, 162.46166752217249]
x = 1e-08 : H_demag =  [-330517.86675206106, -24.351273685146875, 214.40344001233677]</pre>
</div>
<p>At position -1e-8, there is no field defined (this point lies just
outside our sphere-mesh) and therefore the value <tt class="xref docutils literal"><span class="pre">None</span></tt> is returned.</p>
<p>We can see how the demagnetisation field varies slightly throughout
the sphere. The x-component is approximately a third of the
magnetisation, and the y- and z-components are close to zero (as would
be expected for a perfectly round sphere).</p>
<p>We mention for completeness that most fields (such as magnetisation,
exchange field, anisotropy field etc) are only defined within the
region(s) occupied by magnetic material. However, there is a special
function <a class="reference internal" href="manual.html#probe-h-demag-siv"><em>probe_H_demag_siv</em></a> to probe the demagnetisation field
anywhere in space.</p>
</div>
<div class="section" id="saving-spatially-resolved-data">
<span id="id9"></span><h5>Saving spatially resolved data<a class="headerlink" href="manual.html#saving-spatially-resolved-data" title="Permalink to this headline">¶</a></h5>
<p>The command</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>will save full spatially resolved data on all fields (see <a class="reference internal" href="manual.html#fields-and-subfields"><em>Fields and subfields</em></a>) for the current configuration into a file with name
<tt class="docutils literal"><span class="pre">sphere1_dat.h5</span></tt>. (It will also save the spatially averaged values
as described in <a class="reference internal" href="manual.html#saving-averaged-data"><em>Saving averaged data</em></a>.) Whenever the <a class="reference internal" href="manual.html#save-data"><em>save_data</em></a>
function is called, it will write the averaged field values into the
<a class="reference internal" href="manual.html#ndt"><em>Data files (.ndt)</em></a> file. This name is, by default, based on the name of the
simulation script, but can be overridden with an optional argument to
the <a class="reference internal" href="manual.html#simulation"><em>Simulation</em></a> constructor. The data in this file are kept in some
compressed binary format (built on the <a class="reference external" href="http://www.hdfgroup.org/">hdf5</a> standard) and can be
extracted and converted later using the <a class="reference internal" href="manual.html#nmagpp"><em>nmagpp</em></a> tool.</p>
<p>For example, we can extract the magnetisation field from this file
with the command:</p>
<div class="highlight-python"><pre>$ nmagpp --dump sphere1</pre>
</div>
<p>However, here we are interested in creating a <a class="reference internal" href="manual.html#vtk"><em>vtk</em></a> from the saved data
file for visualisation. We use:</p>
<div class="highlight-python"><pre>$ nmagpp --vtk sphere1.vtk sphere1</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">sphere1.vtk</span></tt> is the base name of the vtk file that is to be
generated.</p>
<p>In this manual, we use <a class="reference internal" href="manual.html#mayavi"><em>MayaVi</em></a> as the visualisation tool for vtk files
but there are others available (see <a class="reference internal" href="manual.html#vtk"><em>vtk</em></a>).</p>
<p>Starting MayaVi with the command <tt class="docutils literal"><span class="pre">mayavi</span> <span class="pre">-d</span> <span class="pre">sphere1-000000.vtk</span></tt> will load
our simulation data. Using the pull-down menu <tt class="docutils literal"><span class="pre">Visualize</span> <span class="pre">-&gt;</span> <span class="pre">Modules</span> <span class="pre">-&gt;</span>
<span class="pre">VelocityVector</span></tt> will then tell MayaVi to display the magnetisation
vector field. (Likewise, we can use <tt class="docutils literal"><span class="pre">Visualize</span> <span class="pre">-&gt;</span> <span class="pre">Modules</span> <span class="pre">-&gt;</span> <span class="pre">Axes</span></tt> to
add a 3d coordinate system to the visualization):</p>
<img alt="_images/sphere1_h5_m.png" class="align-center" src="_images/sphere1_h5_m.png" style="width: 1033px; height: 910px;" />
<p>The magnetisation is pointing in positive x-direction because we
initialised the magnetisation in this orientation by issuing the
command <tt class="docutils literal"><span class="pre">sim.set_m([1,0,0])</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">Configure</span> <span class="pre">Data</span></tt> button in the DataVizManager section of
MayaVi&#8217;s user interface allows to select:</p>
<ul class="simple">
<li>a vector field and</li>
<li>a scalar field</li>
</ul>
<p>which provide the data that is used for subsequent visualisation
modules. Above, we have used the <tt class="docutils literal"><span class="pre">m_Py</span></tt> vector field.</p>
<p>The demagnetisation field should point in the opposite direction of
the magnetisation. However, let&#8217;s first create a colour-coded plot of
the scalar magnetic potential, phi, from which the demag field is
computed (by taking its negative gradient):</p>
<img alt="_images/sphere1_h5_phi.png" class="align-center" src="_images/sphere1_h5_phi.png" style="width: 1033px; height: 910px;" />
<p>We first need to select <tt class="docutils literal"><span class="pre">phi</span></tt> as the data source for &#8216;scalar&#8217;
visualisation modules: Through clicking on the <tt class="docutils literal"><span class="pre">Configure</span> <span class="pre">Data</span></tt>
button in the DataVizManager section of MayaVi&#8217;s user interface, we
can select <tt class="docutils literal"><span class="pre">phi&lt;A&gt;</span></tt> as the data source for scalar
visualisations. (The <tt class="docutils literal"><span class="pre">&lt;A&gt;</span></tt> simply indicates that the units of the
potential are Ampere).</p>
<p>To show the scalar potential, we use the
<tt class="docutils literal"><span class="pre">Visualize-&gt;Module-&gt;SurfaceMap</span></tt> module.</p>
<p>We can see that the potential varies along the x-direction. The legend
at the bottom of the figure shows the colour code used. We can also
see from the legend title that the physical dimension of the potential
phi is Ampere (this is the <tt class="docutils literal"><span class="pre">&lt;A&gt;</span></tt>).</p>
<p>Unless the user specifies a particular request for physical dimensions,
the following rules apply for vtk files:</p>
<ul class="simple">
<li>position are given in the same coordinates as the mesh coordinates
(that is why in this example, the x, y and z axis have values going
from -10 to 10).</li>
<li>all field data are given in SI units.</li>
</ul>
<p>The next plot shows the demag field (the vectors) together with
isosurfaces of the magnetic potential:</p>
<img alt="_images/sphere1_h5_demag.png" class="align-center" src="_images/sphere1_h5_demag.png" style="width: 1033px; height: 910px;" />
<p>It can be seen that the isosurfaces are completely flat planes
(i.e. the potential is changing only along x) and the demagnetisation
field is perpendicular to the isosurfaces. The color bar on the left
refers to the magnitude of the demagnetisation field which is
expressed in Ampere per meter, as can be seen from the label
<tt class="docutils literal"><span class="pre">&lt;A/m&gt;</span></tt>. (Note that all the <tt class="docutils literal"><span class="pre">H_demag</span></tt> arrows are colored red
as they have identical length.)</p>
</div>
</div>
</div>
<span id="document-example2/doc"></span><div class="section" id="example-2-computing-the-time-development-of-a-system">
<span id="example-2"></span><h3>Example 2: Computing the time development of a system<a class="headerlink" href="manual.html#example-2-computing-the-time-development-of-a-system" title="Permalink to this headline">¶</a></h3>
<p>This example computes the time development of the magnetisation in a
bar with (x,y,z) dimensions 30 nm x 30 nm x 100 nm. The initial
magnetisation is pointing in the [1,0,1] direction, i.e. 45 degrees
away from the x axis in the direction of the (long) z-axis. We first
show the simulation code and then discuss it in more detail.</p>
<div class="section" id="mesh-generation">
<span id="id1"></span><h4>Mesh generation<a class="headerlink" href="manual.html#mesh-generation" title="Permalink to this headline">¶</a></h4>
<p>While it is down to the mesh generation software (see also <a class="reference internal" href="manual.html#finite-element-mesh-generation"><em>Finite element mesh generation</em></a>) to explain how to generate finite element
meshes, we briefly summarize the steps necessary to create a mesh for
this example in <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a>, and how to convert it into an <tt class="docutils literal"><span class="pre">nmesh</span></tt> mesh.</p>
<ol class="arabic">
<li><p class="first">The finite element method requires the domain of interest to be
broken down into small regions. Such a subdivision of space is
known as a mesh or grid. We use <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> to create this mesh.
Netgen reads a <a class="reference download internal" href="_downloads/bar30_30_100.geo"><tt class="xref download docutils literal"><span class="pre">geometry</span> <span class="pre">file</span></tt></a> describing the
three-dimensional structure. To create the mesh used here,
we can start Netgen and load the geometry file by using the menu:
<tt class="docutils literal"><span class="pre">File-&gt;</span> <span class="pre">Load</span> <span class="pre">Geometry</span></tt>. We then tell Netgen that we like the edge
length to be shorter than 3 by going to <tt class="docutils literal"><span class="pre">Mesh-&gt;Meshing</span> <span class="pre">Options-&gt;Mesh</span> <span class="pre">Size</span></tt>
and enter <tt class="docutils literal"><span class="pre">3.0</span></tt> in the <tt class="docutils literal"><span class="pre">max</span> <span class="pre">mesh-size</span></tt> box. Then a click on the
<tt class="docutils literal"><span class="pre">Generate</span> <span class="pre">Mesh</span></tt> button will generate the mesh. Finally, using
<tt class="docutils literal"><span class="pre">File-&gt;Export</span></tt> will save the mesh as a &#8220;<em>neutral</em>&#8221; file
(this is the default) under the name <tt class="docutils literal"><span class="pre">bar30_30_100.neutral</span></tt>.
(We provide a <a class="reference download internal" href="http://nmag.soton.ac.uk/nmag/0.2/manual/singlehtml/_downloads/bar30_30_100.neutral.gz"><tt class="xref download docutils literal"><span class="pre">gzipped</span> <span class="pre">version</span> <span class="pre">of</span> <span class="pre">this</span> <span class="pre">file</span></tt></a>
for completeness.)</p>
</li>
<li><p class="first">This neutral file needs to be converted into a nmesh file. We do
this using the command:</p>
<div class="highlight-python"><pre>$ nmeshimport --netgen bar30_30_100.neutral bar30_30_100.nmesh.h5</pre>
</div>
<p>By providing the <tt class="docutils literal"><span class="pre">.h5</span></tt> extension, we tell nmeshimport to write a
compressed mesh file which is significantly smaller than an ascii
file (see <a class="reference internal" href="manual.html#mesh-file-size"><em>mesh file size</em></a>).</p>
</li>
</ol>
<p>The generated mesh looks like this:</p>
<img alt="_images/bar30_30_100.png" class="align-center" src="_images/bar30_30_100.png" style="width: 973px; height: 605px;" />
<p>We can examine the mesh using <a class="reference internal" href="manual.html#nmeshpp"><em>nmeshpp</em></a> to obtain information about
mesh quality, the statistical distribution of edge lengths, the
overall number of points and elements etc.</p>
<p>If you like to script the mesh generation starting from a Netgen geometry file and ending with the nmesh file, you could use (for the example above), the following shell commands:</p>
<div class="highlight-python"><pre>netgen -geofile=bar30_30_100.geo -meshfiletype="Neutral Format" -meshfile=bar30_30_100.neutral -batchmode
nmeshimport --netgen bar30_30_100.neutral bar30_30_100.nmesh.h5</pre>
</div>
</div>
<div class="section" id="the-simulation">
<span id="id2"></span><h4>The simulation<a class="headerlink" href="manual.html#the-simulation" title="Permalink to this headline">¶</a></h4>
<p>Having obtained the mesh file <a class="reference download internal" href="_downloads/bar30_30_100.nmesh.h5"><tt class="xref download docutils literal"><span class="pre">bar30_30_100.nmesh.h5</span></tt></a>, we can use the
program <a class="reference download internal" href="_downloads/bar30_30_100.py"><tt class="xref download docutils literal"><span class="pre">bar30_30_100.py</span></tt></a>
to run the simulation:</p>
<blockquote>
<div><pre class="literal-block">
import nmag
from nmag import SI

mat_Py = nmag.MagMaterial(name=&#8221;Py&#8221;,
                          Ms=SI(0.86e6,&#8221;A/m&#8221;),
                          exchange_coupling=SI(13.0e-12, &#8220;J/m&#8221;),
                          llg_damping=0.5)

sim = nmag.Simulation(&#8220;bar&#8221;)

sim.load_mesh(&#8220;bar30_30_100.nmesh.h5&#8221;,
              [(&#8220;Py&#8221;, mat_Py)],
              unit_length=SI(1e-9,&#8221;m&#8221;))

sim.set_m([1,0,1])

dt = SI(5e-12, &#8220;s&#8221;) 

for i in range(0, 61):
    sim.advance_time(dt*i)                  #compute time development

    if i % 10 == 0:                         #every 10 loop iterations, 
        sim.save_data(fields=&#8217;all&#8217;)         #save averages and all
                                            #fields spatially resolved
    else:
        sim.save_data()                     #otherwise just save averages


</pre>
</div></blockquote>
<p>As in <a class="reference internal" href="manual.html#example-1"><em>Example: demag field in uniformly magnetised sphere</em></a>, we start
by importing nmag and creating the material object.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span>

<span class="n">mat_Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                          <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.86e6</span><span class="p">,</span><span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                          <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                          <span class="n">llg_damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>We set the <tt class="docutils literal"><span class="pre">llg_damping</span></tt> parameter to 0.5. As this is a
dimensionless parameter, we can pass a number. Alternatively, we may
give it as <tt class="docutils literal"><span class="pre">SI(0.5)</span></tt>. (Note that in this example, we give the
appropriate physical value for the saturisation magnetisation of
PermAlloy.)</p>
<p>The next line creates the simulation object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we provide a name for the simulation, which is <tt class="docutils literal"><span class="pre">bar</span></tt>. This
will be used as the stem of the name of any data files that are being
written. If this name is not specified (as in <a class="reference internal" href="manual.html#example-1"><em>Example: demag field in
uniformly magnetised sphere</em></a>), it defaults to the name of the file
that contains the script (but without the <tt class="docutils literal"><span class="pre">.py</span></tt> extension).</p>
<p>Next, we load the mesh file, and set the initial (normalised)
magnetisation to point in the <tt class="docutils literal"><span class="pre">[1,0,1]</span></tt> direction, i.e. to have
equal magnitude in the x- and z-direction and 0 in the
y-direction.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;bar30_30_100.nmesh.h5&quot;</span><span class="p">,</span>
              <span class="p">[(</span><span class="s">&quot;Py&quot;</span><span class="p">,</span> <span class="n">mat_Py</span><span class="p">)],</span>
              <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">))</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>This vector will automatically be normalised within nmag, so that
<tt class="docutils literal"><span class="pre">[1,0,1]</span></tt> is equivalent to the normalised vector
<tt class="docutils literal"><span class="pre">[0.70710678,0,0.70710678]</span></tt>.</p>
<p>In this example, we would like to study a dynamic process and will ask
nmag to compute the time development over a certain amount of time
<tt class="docutils literal"><span class="pre">dt</span></tt>. The line:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dt</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">5e-12</span><span class="p">,</span> <span class="s">&quot;s&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>simply creates a <a class="reference internal" href="manual.html#si-object"><em>SI object</em></a> which represents our timescale.</p>
<p>We then have a Python <tt class="docutils literal"><span class="pre">for</span></tt>-loop in which <tt class="docutils literal"><span class="pre">i</span></tt> will take integer
values ranging from 0 to 60 for subsequent iterations. All indented
lines are the body of the for-loop. (In the Python programming
language, scoping is expressed through indentation rather than braces
or other types of parentheses. Text editors such as Emacs come with
built-in support for properly indenting Python code [by pressing the
<tt class="docutils literal"><span class="pre">Tab</span></tt> key on a line to be indented].)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">61</span><span class="p">):</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">advance_time</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">save_data</span><span class="p">()</span>
</pre></div>
</div>
<p>In each iteration, we first call <tt class="docutils literal"><span class="pre">sim.advance_time(i*dt)</span></tt> which
instructs nmag to carry on time integration up to the time
<tt class="docutils literal"><span class="pre">i*dt</span></tt>.</p>
<p>The call to <a class="reference internal" href="manual.html#save-data"><em>save_data</em></a> will save the average data into the
<tt class="docutils literal"><span class="pre">bar_dat.ndt</span></tt> file.</p>
<p>The last four lines contain an <tt class="docutils literal"><span class="pre">if</span></tt> statement which is used to save
spatially resolved data every ten time steps only, and averaged data
every time step. The percent operator <tt class="docutils literal"><span class="pre">%</span></tt> computes <tt class="docutils literal"><span class="pre">i</span></tt> modulo
10. This will be 0 when <tt class="docutils literal"><span class="pre">i</span></tt> takes values 0, 10, 20, 30, ... In this
case, we call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>which will save the (spatial) averages of all <a class="reference internal" href="manual.html#field"><em>fields</em></a> (going into the
<tt class="docutils literal"><span class="pre">bar_dat.ndt</span></tt> file), <em>and</em> the spatially resolved data for all
fields (that are saved to <tt class="docutils literal"><span class="pre">bar_dat.h5</span></tt>).</p>
<p>If <tt class="docutils literal"><span class="pre">i</span></tt> is not an integer multiple of 10, then the command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">save_data</span><span class="p">()</span>
</pre></div>
</div>
<p>is called, which only saves spatially averaged data.</p>
</div>
<div class="section" id="analysing-the-data">
<span id="id3"></span><h4>Analysing the data<a class="headerlink" href="manual.html#analysing-the-data" title="Permalink to this headline">¶</a></h4>
<div class="section" id="time-dependent-averages">
<span id="id4"></span><h5>Time dependent averages<a class="headerlink" href="manual.html#time-dependent-averages" title="Permalink to this headline">¶</a></h5>
<p>We first plot the average magnetisation vector against time. To
see what data is available, we call <a class="reference internal" href="manual.html#ncol"><em>ncol</em></a> with just the name of the
simulation (which here is <tt class="docutils literal"><span class="pre">bar</span></tt>):</p>
<div class="highlight-python"><pre>$ ncol bar
 0:         #time           #&lt;s&gt;              0
 1:            id             &lt;&gt;              1
 2:          step             &lt;&gt;              0
 3:    stage_time            &lt;s&gt;              0
 4:    stage_step             &lt;&gt;              0
 5:         stage             &lt;&gt;              0
 6:    E_total_Py      &lt;kg/ms^2&gt;  -0.2603465789714
 7:           phi            &lt;A&gt;  0.0002507410390772
 8:      E_ext_Py      &lt;kg/ms^2&gt;              0
 9:     H_demag_0          &lt;A/m&gt;  -263661.6680783
10:     H_demag_1          &lt;A/m&gt;  -8.218106743355
11:     H_demag_2          &lt;A/m&gt;  -77027.641984
12:     dmdt_Py_0         &lt;A/ms&gt;  -8.250904652583e+15
13:     dmdt_Py_1         &lt;A/ms&gt;  2.333344983225e+16
14:     dmdt_Py_2         &lt;A/ms&gt;  8.250904652583e+15
15:   H_anis_Py_0          &lt;A/m&gt;              0
16:   H_anis_Py_1          &lt;A/m&gt;              0
17:   H_anis_Py_2          &lt;A/m&gt;              0
18:        m_Py_0             &lt;&gt;  0.7071067811865
19:        m_Py_1             &lt;&gt;              0
20:        m_Py_2             &lt;&gt;  0.7071067811865
21:        M_Py_0          &lt;A/m&gt;  608111.8318204
22:        M_Py_1          &lt;A/m&gt;              0
23:        M_Py_2          &lt;A/m&gt;  608111.8318204
24:     E_anis_Py      &lt;kg/ms^2&gt;              0
25:     E_exch_Py      &lt;kg/ms^2&gt;  5.046530179037e-17
26:           rho        &lt;A/m^2&gt;  0.03469702141876
27:       H_ext_0          &lt;A/m&gt;              0
28:       H_ext_1          &lt;A/m&gt;              0
29:       H_ext_2          &lt;A/m&gt;              0
30:  H_total_Py_0          &lt;A/m&gt;  -263661.6680783
31:  H_total_Py_1          &lt;A/m&gt;  -8.218106743352
32:  H_total_Py_2          &lt;A/m&gt;  -77027.641984
33:    E_demag_Py      &lt;kg/ms^2&gt;  -0.2603465789714
34:   H_exch_Py_0          &lt;A/m&gt;  3.301942533099e-11
35:   H_exch_Py_1          &lt;A/m&gt;              0
36:   H_exch_Py_2          &lt;A/m&gt;  3.301942533099e-11
37: maxangle_m_Py          &lt;deg&gt;              0
38:     localtime             &lt;&gt;  2007/08/15-11:16:19
39:      unixtime            &lt;s&gt;   1187172979.6</pre>
</div>
<p>The meaning of the various entries is discussed in detail in section
<a class="reference internal" href="manual.html#ncol"><em>ncol</em></a>. Here, we simply note that the column indices (given by the
number at the beginning of every line) we are most interested in are:</p>
<ul class="simple">
<li>0 for the <tt class="docutils literal"><span class="pre">time</span></tt>,</li>
<li>21 for <tt class="docutils literal"><span class="pre">M_Py_0</span></tt> which is the x-component of the magnetisation of
the Py material,</li>
<li>22 for <tt class="docutils literal"><span class="pre">M_Py_1</span></tt> which is the y-component of the magnetisation of
the Py material, and</li>
<li>23 for <tt class="docutils literal"><span class="pre">M_Py_2</span></tt> which is the z-component of the magnetisation of
the Py material,</li>
</ul>
<p>We can use <a class="reference internal" href="manual.html#ncol"><em>ncol</em></a> to extract this data into a file <tt class="docutils literal"><span class="pre">data_M.dat</span></tt> which
has the time for each time step in the first column and the x, y and z
component of the magnetisation in columns 2, 3 and 4, respectively:</p>
<div class="highlight-python"><pre>$ ncol bar 0 21 22 23 &gt; data_M.txt</pre>
</div>
<p>This creates a text file <a class="reference download internal" href="_downloads/data_M.txt"><tt class="xref download docutils literal"><span class="pre">data_M.txt</span></tt></a> that
can be read by other applications to create a plot.</p>
<p>Note, however, that the order of the entries in the ndt file is not
guaranteed, i.e. the numbers corresponding to fields may change with
different versions of the software, or different simulations (for
example, the user may add extra fields). Therefore, the recommended
approach is to directly specify the names of the columns that are to be
extracted (i.e. <tt class="docutils literal"><span class="pre">time</span> <span class="pre">M_Py_0</span> <span class="pre">M_Py_1</span> <span class="pre">M_Py_2</span></tt>):</p>
<div class="highlight-python"><pre>$ ncol bar time M_Py_0 M_Py_1 M_Py_2 &gt; data_M.txt</pre>
</div>
<p>We use the <a class="reference external" href="http://plasma-gate.weizmann.ac.il/Grace/">xmgrace</a> command:</p>
<div class="highlight-python"><pre>xmgrace -nxy data_M.txt</pre>
</div>
<p>to create the following plot (manually adding the legend and axis labels):</p>
<img alt="_images/data_M.png" class="align-center" src="_images/data_M.png" style="width: 789px; height: 437px;" />
</div>
<div class="section" id="comparison-with-oommf-and-magpar">
<span id="id5"></span><h5>Comparison with OOMMF and Magpar<a class="headerlink" href="manual.html#comparison-with-oommf-and-magpar" title="Permalink to this headline">¶</a></h5>
<p>We have carried out the same simulation with <a class="reference external" href="http://www.magpar.net/">Magpar</a> and <a class="reference external" href="http://math.nist.gov/oommf/">OOMMF</a>. The
following plot shows the corresponding OOMMF-curves (as spheres)
together with nmag&#8216;s results. (The Magpar curve, which is not shown
here, follows the nmag data very closely.)</p>
<img alt="_images/data_M_OOMMF.png" class="align-center" src="_images/data_M_OOMMF.png" style="width: 789px; height: 437px;" />
</div>
<div class="section" id="spatially-resolved-fields">
<span id="id6"></span><h5>Spatially resolved fields<a class="headerlink" href="manual.html#spatially-resolved-fields" title="Permalink to this headline">¶</a></h5>
<p>The command <tt class="docutils literal"><span class="pre">sim.save_data(fields='all')</span></tt> saves all <a class="reference internal" href="manual.html#field"><em>fields</em></a> into the
file <tt class="docutils literal"><span class="pre">bar_dat.h5</span></tt> (as explained, the filename is composed of the name
of the simulation [here <tt class="docutils literal"><span class="pre">bar</span></tt>] and the extension <tt class="docutils literal"><span class="pre">_dat.h5</span></tt>). The
code <tt class="docutils literal"><span class="pre">bar30_30_100.py</span></tt> above calls the <a class="reference internal" href="manual.html#save-data"><em>save_data</em></a> command every 10
iterations. As every <tt class="docutils literal"><span class="pre">dt</span></tt> corresponds to 0.5 picoseconds, the
data hence is saved every 5 picoseconds.</p>
<p>We can confirm this by using the <a class="reference internal" href="manual.html#nmagpp"><em>nmagpp</em></a> command:</p>
<div class="highlight-python"><pre>$ nmagpp --idlist bar</pre>
</div>
<p>which produces the following output:</p>
<div class="highlight-python"><pre> id   stage   step      time  fields
 0-&gt;    1      0         0 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
10-&gt;    1    312     5e-11 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
20-&gt;    1    495     1e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
30-&gt;    1    603   1.5e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
40-&gt;    1    678     2e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
50-&gt;    1    726   2.5e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
60-&gt;    1    762     3e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho</pre>
</div>
<p>The first column is a <a class="reference internal" href="manual.html#unique-identifier-id"><em>unique identifier id</em></a>  for a configuration of the
system. We can use the <tt class="docutils literal"><span class="pre">--range</span></tt> argument to select entries for
further processing. The <tt class="docutils literal"><span class="pre">stage</span></tt> is only relevant for calculations of
hysteresis curves (see <a class="reference internal" href="manual.html#simple-hysteresis-example"><em>Example: Simple hysteresis loop</em></a>). The <tt class="docutils literal"><span class="pre">step</span></tt> is the
time-stepper iteration counter for this calculation. The time is given
in seconds (<tt class="docutils literal"><span class="pre">&lt;s&gt;</span></tt>). (Note the 5 pico-second interval between
entries.) The stage, step and time data is provided for
convenience. What follows is a list of fields that have been saved for
each of these configurations.</p>
<p>We convert the first saved time step into a vtk file
with base name <tt class="docutils literal"><span class="pre">bar_initial.vtk</span></tt> using</p>
<div class="highlight-python"><pre>$ nmagpp --range 0 --vtk bar_initial.vtk bar</pre>
</div>
<p>and we also convert the last saved time step at 300 picoseconds to a
vtk file with base name <tt class="docutils literal"><span class="pre">bar_final.vtk</span></tt> using:</p>
<div class="highlight-python"><pre>$ nmagpp --range 60 --vtk bar_final.vtk bar</pre>
</div>
<p>The actual file names that are created by these two commands are
<tt class="docutils literal"><span class="pre">bar_initial-000000.vtk</span></tt> and <tt class="docutils literal"><span class="pre">bar_final-000060.vtk</span></tt>. The appended number
is the <tt class="docutils literal"><span class="pre">id</span></tt> of the saved configuration. This is useful if one wants to create vtk files for all saved configurations. For example:</p>
<div class="highlight-python"><pre>$ nmagpp --vtk bar.vtk bar</pre>
</div>
<p>will create the files:</p>
<div class="highlight-python"><pre>bar-000000.vtk
bar-000010.vtk
bar-000020.vtk
bar-000030.vtk
bar-000040.vtk
bar-000050.vtk
bar-000060.vtk</pre>
</div>
<p>Using <a class="reference internal" href="manual.html#mayavi"><em>MayaVi</em></a>, we can display this data in a variety of ways. Remember
that all field values are shown in SI units by default (see <a class="reference internal" href="manual.html#nmagpp"><em>nmagpp</em></a>),
and positions are as provided in the mesh file. In this case,
positions are expressed in nanometers (this comes from the
<tt class="docutils literal"><span class="pre">unit_length=SI(1e-9,&quot;m&quot;)</span></tt> expression in the <tt class="docutils literal"><span class="pre">sim.load_mesh()</span></tt>
command.</p>
<p>This is the initial configuration with magnetisation pointing in the
[1,0,1] direction:</p>
<img alt="_images/bar_initial_M.png" class="align-center" src="_images/bar_initial_M.png" style="width: 1039px; height: 682px;" />
<p>The &#8220;final&#8221; configuration shows that the magnetisation aligns along
the z-direction. The coloured surface shows the x-component of the
magnetisation (and the colorbar provides the scale). It can be seen
that the magnetisation at position z=100 nm goes into a flower state
to minimise the overall energy. (Note that, strictly speaking, this
system is not yet in a meta-stable state after 300 ps &#8211; but already
quite close.):</p>
<img alt="_images/bar_final_M.png" class="align-center" src="_images/bar_final_M.png" style="width: 1039px; height: 682px;" />
<p>Because we have saved all fields (not just the magnetisation), we can
also study other properties. For example, the following image shows
the demagnetisation field as vectors (and the legend refers to the
magnitude of the vectors), as well as the magnetic scalar potential
(as a stack of isosurfaces). Because the demagnetisation field is the
(negative) gradient of the scalar potential, the vectors are
perpendicular on the isosurfaces:</p>
<img alt="_images/bar_final_demag.png" class="align-center" src="_images/bar_final_demag.png" style="width: 1039px; height: 682px;" />
</div>
</div>
<div class="section" id="higher-level-functions">
<span id="id7"></span><h4>Higher level functions<a class="headerlink" href="manual.html#higher-level-functions" title="Permalink to this headline">¶</a></h4>
<p>We now have seen an overview over the fundamental commands used to set
up a micromagnetic simulation and demonstrate how to advance the
configuration of the system through time. In principle, this is all
one would need to know to compute hysteresis loops and carry out most
micromagnetic computations. However, there are more advanced functions
that simplify and automatise the most frequent tasks, such as
computing a hysteresis loop.</p>
</div>
<div class="section" id="relaxing-the-system">
<span id="id8"></span><h4>&#8220;Relaxing&#8221; the system<a class="headerlink" href="manual.html#relaxing-the-system" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="manual.html#relax"><em>relax</em></a> command takes the current magnetisation configuration of a
simulation and computes the time development until the torque on each
mesh site is smaller than a certain threshold. This is useful for this
particular example as we do not know for how long we need to integrate
the system until it stops in a local energy minimum configuration. We
can adjust the code of this example to make use of the <tt class="docutils literal"><span class="pre">relax</span></tt>
command (<a class="reference download internal" href="_downloads/bar_relax.py"><tt class="xref download docutils literal"><span class="pre">modified</span> <span class="pre">source</span> <span class="pre">code</span></tt></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">every</span><span class="p">,</span> <span class="n">at</span>

<span class="n">mat_Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                           <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.86e6</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                           <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                           <span class="n">llg_damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>


<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="s">&quot;bar_relax&quot;</span><span class="p">)</span>

<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;bar30_30_100.nmesh.h5&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;Py&quot;</span><span class="p">,</span> <span class="n">mat_Py</span><span class="p">)],</span>
              <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">))</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="n">ps</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-12</span><span class="p">,</span><span class="s">&quot;s&quot;</span><span class="p">)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">ps</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>
</pre></div>
</div>
<p>(Note the additions to the <tt class="docutils literal"><span class="pre">import</span></tt> statement!)</p>
<p>The particular <tt class="docutils literal"><span class="pre">relax</span></tt> command employed here:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="mi">5</span><span class="o">*</span><span class="n">ps</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>
</pre></div>
</div>
<p>works as follows:</p>
<p>The argument <tt class="docutils literal"><span class="pre">save</span> <span class="pre">=</span> <span class="pre">[</span> <span class="pre">]</span></tt> tells <tt class="docutils literal"><span class="pre">relax</span></tt> to save data according to
the instructions given in the form of a python list (i.e. enclosed by
square brackets). The first relax instruction is this tuple:</p>
<div class="highlight-python"><pre>('averages', every('time',5*ps)</pre>
</div>
<p>and means that the <em>averages</em> should be saved <em>every 5 picoseconds</em>.
The syntax used here breaks down into the following parts:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">'averages'</span></tt> is just the keyword (a string) to say that the
average data should be saved.</li>
<li><tt class="docutils literal"><span class="pre">every(...)</span></tt> is a special object which takes two parameters. They are here:<ul>
<li><tt class="docutils literal"><span class="pre">'time'</span></tt> to indicate that something should be done every time a certain
amount of simulated time has passed, and</li>
<li><tt class="docutils literal"><span class="pre">5*ps</span></tt> which is the amount of time after which the data
should be saved again. This has to be a <a class="reference internal" href="manual.html#si-object"><em>SI object</em></a>, which we here
obtain by multiplying a number (<tt class="docutils literal"><span class="pre">5</span></tt>) with the SI object <tt class="docutils literal"><span class="pre">ps</span></tt> which
has been defined earlier in our example program to represent a pico-second.</li>
<li>We can provide further keywords to the <tt class="docutils literal"><span class="pre">every</span></tt> object (for example
to save the data every <tt class="docutils literal"><span class="pre">10</span></tt> iteration steps we can use <tt class="docutils literal"><span class="pre">every('step',</span> <span class="pre">10)</span></tt>).</li>
</ul>
</li>
</ul>
</div></blockquote>
<p>Internally, the <a class="reference internal" href="manual.html#relax"><em>relax</em></a> command uses the <a class="reference internal" href="manual.html#hysteresis"><em>hysteresis</em></a> command, so the documentation of
<a class="reference internal" href="manual.html#hysteresis"><em>hysteresis</em></a> should be consulted for a more detailed explanation of parameters.</p>
<p>The second relax instruction is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>which means that the <em>fields</em> should be saved <em>at convergence</em>,
i.e. when the relaxation process has finished and the magnetisation
has converged to its (meta)stable configuration:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">'fields'</span></tt> is a string that indicates that we would like to save
all the defined fields.</li>
<li><tt class="docutils literal"><span class="pre">at('convergence')</span></tt> is a special object that indicates that this
should happen exactly when the relaxation process has converged.</li>
</ul>
</div></blockquote>
<p>After running this program, we can use the <a class="reference internal" href="manual.html#ncol"><em>ncol</em></a> tool to look at
the averages saved:</p>
<div class="highlight-python"><pre>$ ncol bar_relax step time</pre>
</div>
<p>gives output which starts like this:</p>
<div class="highlight-python"><pre>  0              0
 82          5e-12
120          1e-11
146        1.5e-11
176          2e-11
201        2.5e-11
227          3e-11
248        3.5e-11</pre>
</div>
<p>Here, we see the iterations on the left and the simulated time (in
seconds) on the right. As requested, there is one data entry
(i.e. line) every 5 picoseconds.</p>
<p>Note that it may happen that the system saves the data not exactly at
the requested time, i.e.:</p>
<div class="highlight-python"><pre>532        6.5e-11
580  7.047908066945e-11
620        7.5e-11</pre>
</div>
<p>The middle line shows that the data has been saved when the simulated
time was approximately 7.05e-11 seconds whereas we requested 7e-11
seconds. Such small deviations are tolerated by the system to improve
performance <a class="footnote-reference" href="manual.html#timeintegrator" id="id9">[1]</a>.</p>
<p>From the data saved, we can obtain the following plot:</p>
<img alt="_images/bar_relax_data_M.png" class="align-center" src="_images/bar_relax_data_M.png" style="width: 789px; height: 437px;" />
<p>In summary, the <a class="reference internal" href="manual.html#relax"><em>relax</em></a> function is useful to obtain a meta-stable
configuration of the system. In particular, it will carry out the time
integration until the remaining torque at any point in the system has
dropped below a certain threshold.</p>
<table class="docutils footnote" frame="void" id="timeintegrator" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id9">[1]</a></td><td>The time integrator (here, <a class="reference external" href="http://www.llnl.gov/CASC/sundials/">Sundials</a> CVODE) would have to do an
extra step to get to the requested time. If the current time is
very close to the requested time, it will simply report this value.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="relaxing-the-system-faster">
<span id="id10"></span><h4>&#8220;Relaxing&#8221; the system faster<a class="headerlink" href="manual.html#relaxing-the-system-faster" title="Permalink to this headline">¶</a></h4>
<p>If we are only interested in the final (meta-stable) configuration of
a run, we can switch off the precession term in the Laundau Lifshitz
and Gilbert equation. The MagMaterial definition in the following
example shows how to do this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">every</span><span class="p">,</span> <span class="n">at</span>

<span class="n">mat_Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                           <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.86e6</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                           <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                           <span class="n">llg_damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                           <span class="n">do_precession</span><span class="o">=</span><span class="bp">False</span> <span class="p">)</span>


<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="s">&quot;bar_relax2&quot;</span><span class="p">)</span>

<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;bar30_30_100.nmesh.h5&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;Py&quot;</span><span class="p">,</span> <span class="n">mat_Py</span><span class="p">)],</span>
              <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">))</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="n">ps</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-12</span><span class="p">,</span><span class="s">&quot;s&quot;</span><span class="p">)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">ps</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>
</pre></div>
</div>
<p>The new option is <tt class="docutils literal"><span class="pre">do_precession=False</span></tt> in the constructor of the
PermAlloy material <tt class="docutils literal"><span class="pre">mat_Py</span></tt>. As a result, there will be no
precession term in the equation of motion:</p>
<img alt="_images/bar_relax2_data_M.png" class="align-center" src="_images/bar_relax2_data_M.png" style="width: 789px; height: 437px;" />
<p>While the time-development of the system happens at the same time
scale as for the system with the precession term (see <a class="reference internal" href="manual.html#relaxing-the-system">&#8220;Relaxing&#8221; the
system</a>), the computation of the system without the precession is
significantly faster (for this example, we needed about 3500
iterations with the precession term and 1500 without it, and the
computation time scales similarly).</p>
<p>Note, that the &#8216;&#8217;dynamics&#8217;&#8217; shown here are of course artificial and
only used to obtain a meta-stable physical configuration more
efficiently!</p>
</div>
<div class="section" id="decreasing-execution-time">
<span id="id11"></span><h4>Decreasing execution time<a class="headerlink" href="manual.html#decreasing-execution-time" title="Permalink to this headline">¶</a></h4>
<p>Note that the execution time can generally be reduced significantly by
decreasing the tolerances for the time integrator. In short, one has
to use the <a class="reference internal" href="manual.html#set-params"><em>set_params</em></a> function (after <a class="reference internal" href="manual.html#set-m"><em>set_m</em></a> has been called).
Decreasing the requested accuracy will of course make the simulation
results less accurate but this is often acceptable. An example of how
to use the <a class="reference internal" href="manual.html#set-m"><em>set_m</em></a> function and detailed discussion of the
micromagnetic example shown in this section for a variety of tolerance
values is given in the section <a class="reference internal" href="manual.html#example-tolerances"><em>Example timestepper tolerances</em></a>.</p>
</div>
</div>
<span id="document-example_hysteresis_ellipsoid/doc"></span><div class="section" id="example-simple-hysteresis-loop">
<span id="simple-hysteresis-example"></span><h3>Example: Simple hysteresis loop<a class="headerlink" href="manual.html#example-simple-hysteresis-loop" title="Permalink to this headline">¶</a></h3>
<p>This example computes the hysteresis loop of an ellipsoidal magnetic
object. We use an ellipsoid whose x,y,z semi-axes
have lengths 30 nm, 10 nm and 10 nm, respectively. (The mesh is contained
in <a class="reference download internal" href="_downloads/ellipsoid.nmesh.h5"><tt class="xref download docutils literal"><span class="pre">ellipsoid.nmesh.h5</span></tt></a>
and produced with <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> from <a class="reference download internal" href="_downloads/ellipsoid.geo"><tt class="xref download docutils literal"><span class="pre">ellipsoid.geo</span></tt></a>):</p>
<img alt="_images/mesh2.png" class="align-center" src="_images/mesh2.png" style="width: 800px; height: 531px;" />
<p>This picture has been obtained by converting the mesh to a <a class="reference internal" href="manual.html#vtk"><em>vtk</em></a> file using:</p>
<div class="highlight-python"><pre>$ nmeshpp --vtk ellipsoid.nmesh.h5 mesh.vtk</pre>
</div>
<p>and subsequent visualisation with <a class="reference internal" href="manual.html#mayavi"><em>MayaVi</em></a>:</p>
<div class="highlight-python"><pre>$ mayavi -d mesh.vtk -m SurfaceMap</pre>
</div>
<p>We have further added the axes within MayaVi
(Visualize-&gt;Modules-&gt;Axes), and changed the display color from blue to
red (Double click on <tt class="docutils literal"><span class="pre">SurfaceMap</span></tt> in the selected Modules list, then
uncheck the <tt class="docutils literal"><span class="pre">Scalar</span> <span class="pre">Coloring</span></tt> box, click on <tt class="docutils literal"><span class="pre">Change</span> <span class="pre">Object</span> <span class="pre">Color</span></tt>
and select a suitable color).</p>
<p>We provide the mayavi file <a class="reference download internal" href="_downloads/mesh.mv"><tt class="xref download docutils literal"><span class="pre">mesh.mv</span></tt></a> that shows the
visulisation as in the figure above. (If you want to load this file
into MayaVi, just use <tt class="docutils literal"><span class="pre">$</span> <span class="pre">mayavi</span> <span class="pre">mesh.mv</span></tt> but make sure that
<tt class="docutils literal"><span class="pre">mesh.vtk</span></tt> is in the same directory as mayavi will need to read
this.)</p>
<div class="section" id="hysteresis-simulation-script">
<span id="id1"></span><h4>Hysteresis simulation script<a class="headerlink" href="manual.html#hysteresis-simulation-script" title="Permalink to this headline">¶</a></h4>
<p>To compute the hysteresis loop for the ellipsoid, we use the
script <a class="reference download internal" href="_downloads/ellipsoid.py"><tt class="xref download docutils literal"><span class="pre">ellipsoid.py</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">at</span>

<span class="c">#create simulation object</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>

<span class="c"># define magnetic material</span>
<span class="n">Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e6</span><span class="p">,</span><span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">))</span>

<span class="c"># load mesh: the mesh dimensions are scaled by 0.5 nm</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;ellipsoid.nmesh.h5&quot;</span><span class="p">,</span>
              <span class="p">[(</span><span class="s">&quot;ellipsoid&quot;</span><span class="p">,</span> <span class="n">Py</span><span class="p">)],</span>
              <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">))</span>

<span class="c"># set initial magnetisation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>

<span class="n">Hs</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">vector_set</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.01</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                     <span class="n">norm_list</span><span class="o">=</span><span class="p">[</span> <span class="mf">1.00</span><span class="p">,</span>  <span class="mf">0.95</span><span class="p">,</span> <span class="p">[],</span> <span class="o">-</span><span class="mf">1.00</span><span class="p">,</span>
                                <span class="o">-</span><span class="mf">0.95</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.90</span><span class="p">,</span> <span class="p">[],</span>  <span class="mf">1.00</span><span class="p">],</span>
                     <span class="n">units</span><span class="o">=</span><span class="mf">1e6</span><span class="o">*</span><span class="n">SI</span><span class="p">(</span><span class="s">&#39;A/m&#39;</span><span class="p">))</span>

<span class="c"># loop over the applied fields Hs</span>
<span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;restart&#39;</span><span class="p">,</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>
</pre></div>
</div>
<p>As in the previous examples, we first need to import the modules
necessary for the simulation. <tt class="docutils literal"><span class="pre">at('convergence')</span></tt> allows us to save
the fields and the averages whenever convergence is reached.
We then define the material of the magnetic object, load the mesh and set
the initial configuration of the magnetisation as well as the
external field.</p>
</div>
<div class="section" id="hysteresis-loop-computation">
<span id="id2"></span><h4>Hysteresis loop computation<a class="headerlink" href="manual.html#hysteresis-loop-computation" title="Permalink to this headline">¶</a></h4>
<p>We apply the external magnetic fields in the x-direction with range of
1e6 A/m down to -1e6 A/m in steps of <tt class="docutils literal"><span class="pre">0.05e6</span> <span class="pre">A/m</span></tt>.</p>
<p>To convey this information efficiently to nmag, we use:</p>
<ol class="arabic simple">
<li>a direction for the applied field (here just <tt class="docutils literal"><span class="pre">[1,0.01,0]</span></tt>), (note
that we have a small y-component of 1% in the applied field to break
the symmetry)</li>
<li>a list of magnitudes of the field that will be multiplied with the
direction vector,</li>
<li>another multiplier that defines the physical dimension of the applied fields
(here <tt class="docutils literal"><span class="pre">1000kA/m</span></tt>, given as <tt class="docutils literal"><span class="pre">1e6*SI('A/m')</span></tt>).</li>
</ol>
<p>Putting all this together, we obtain this command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Hs</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">vector_set</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                     <span class="n">norm_list</span><span class="o">=</span><span class="p">[</span> <span class="mf">1.00</span><span class="p">,</span>  <span class="mf">0.95</span><span class="p">,</span> <span class="p">[],</span> <span class="o">-</span><span class="mf">1.00</span><span class="p">,</span>
                                <span class="o">-</span><span class="mf">0.95</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.90</span><span class="p">,</span> <span class="p">[],</span>  <span class="mf">1.00</span><span class="p">],</span>
                     <span class="n">units</span><span class="o">=</span><span class="mf">1e6</span><span class="o">*</span><span class="n">SI</span><span class="p">(</span><span class="s">&#39;A/m&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>which computes a list of vectors <tt class="docutils literal"><span class="pre">Hs</span></tt>. Each entry in the list
corresponds to one applied field.</p>
<p>The <a class="reference internal" href="manual.html#hysteresis"><em>hysteresis</em></a> command takes this list of applied fields <tt class="docutils literal"><span class="pre">Hs</span></tt> as
one input parameter, and computes the hysteresis loop for these
fields:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;restart&#39;</span><span class="p">,</span> <span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">save</span></tt> parameter is used to tell the hysteresis command what
data to save, and how often. We have come across this notation when
explaining the <tt class="docutils literal"><span class="pre">relax</span></tt> command in the section <a class="reference internal" href="manual.html#relaxing-the-system"><em>&#8220;Relaxing&#8221; the system</em></a> of the previous example. In the example shown here, we
request that the <em>fields</em> and the <em>restart</em> data should be saved <em>at</em>
the point in time where we reach <em>convergence</em>. (The spatially
averaged data is saved automatically to the <a class="reference internal" href="manual.html#ndt"><em>Data files (.ndt)</em></a> file when the
<em>fields</em> are saved.) This is done in a compact notation shown above
which is equivalent to this more explicit version:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span>
               <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;restart&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">)),</span>
                     <span class="p">(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span>   <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>
</pre></div>
</div>
<p>The compact notation can be used because here we want to save
<em>fields</em> and <em>restart</em> data at the same time.</p>
<p>The <a class="reference internal" href="manual.html#hysteresis"><em>hysteresis</em></a> command computes the time development of the system
for one applied field until a convergence criterion is met. It then
proceeds to the next external field value provided in <tt class="docutils literal"><span class="pre">Hs</span></tt>.</p>
<p>We run the simulation as usual using:</p>
<div class="highlight-python"><pre>$ nsim ellipsoid.py</pre>
</div>
<p>If you have run the simulation before, we need to use the <tt class="docutils literal"><span class="pre">--clean</span></tt>
switch to enforce overriding of existing data files:</p>
<div class="highlight-python"><pre>$ nsim ellipsoid.py --clean</pre>
</div>
<p>The simulation should take only a few minutes (for example 3 minutes
on an Athlon64 3800+), and needs about 75MB of RAM.</p>
<p>If the simulation has been interrupted, it can be continued using</p>
<blockquote>
<div>$ nsim ellipsoid.py &#8211;restart</div></blockquote>
</div>
<div class="section" id="obtaining-the-hysteresis-loop-data">
<span id="id3"></span><h4>Obtaining the hysteresis loop data<a class="headerlink" href="manual.html#obtaining-the-hysteresis-loop-data" title="Permalink to this headline">¶</a></h4>
<p>Once the calculation has finished, we can plot the graph of the
magnetisation (projected along the direction of the applied field) as a
function of the applied field.</p>
<p>We use the <a class="reference internal" href="manual.html#ncol"><em>ncol</em></a> command to extract the data into a text file named <a class="reference download internal" href="_downloads/plot1.dat"><tt class="xref download docutils literal"><span class="pre">plot.dat</span></tt></a>:</p>
<div class="highlight-python"><pre>$ ncol ellipsoid H_ext_0 m_Py_0 &gt; plot.dat</pre>
</div>
</div>
<div class="section" id="plotting-the-hysteresis-loop-with-gnuplot">
<span id="id4"></span><h4>Plotting the hysteresis loop with Gnuplot<a class="headerlink" href="manual.html#plotting-the-hysteresis-loop-with-gnuplot" title="Permalink to this headline">¶</a></h4>
<p>In this example, rather than using <a class="reference external" href="http://plasma-gate.weizmann.ac.il/Grace/">xmgrace</a>, we show how to plot data
using <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a>:</p>
<div class="highlight-python"><pre>$ gnuplot make_plot.gnu</pre>
</div>
<p>The contents of the gnuplot script <a class="reference download internal" href="_downloads/make_plot1.gnu"><tt class="xref download docutils literal"><span class="pre">make_plot.gnu</span></tt></a> are:</p>
<pre class="literal-block">
set term postscript eps enhanced color
set out &#8216;hysteresis.eps&#8217;
set xlabel &#8216;Applied field H_x   (A/m)&#8217;
set ylabel &#8216;M_x / M_s&#8217;
set xrange [-1050000:1050000]
set yrange [-1.2:1.2]
plot &#8216;plot.dat&#8217; u 1:2 ti &#8216;ellipsoid example&#8217; w lp 3
</pre>
<p>which generates the following hysteresis loop graph:</p>
<img alt="_images/hysteresis.png" class="align-center" src="_images/hysteresis.png" style="width: 725px; height: 494px;" />
</div>
</div>
<span id="document-example_stoner_wohlfarth/doc"></span><div class="section" id="example-hysteresis-loop-for-stoner-wohlfarth-particle">
<span id="stoner-wohlfarth-example"></span><h3>Example: Hysteresis loop for Stoner-Wohlfarth particle<a class="headerlink" href="manual.html#example-hysteresis-loop-for-stoner-wohlfarth-particle" title="Permalink to this headline">¶</a></h3>
<p>This example is very similar to <a class="reference internal" href="manual.html#simple-hysteresis-example"><em>Example: Simple hysteresis loop</em></a> but
computes the hysteresis loop of a smaller ellipsoidal magnetic
object. This allows to compare the results with the analytical
solution given by the Stoner-Wohlfarth model.  We use an ellipsoid
whose x,y,z semi-axes have lengths 9 nm, 3 nm and 3 nm,
respectively. (The mesh is contained in <a class="reference download internal" href="_downloads/ellipsoid.nmesh.h5"><tt class="xref download docutils literal"><span class="pre">ellipsoid.nmesh.h5</span></tt></a> and produced with
<a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> from <a class="reference download internal" href="_downloads/ellipsoid1.geo"><tt class="xref download docutils literal"><span class="pre">ellipsoid.geo</span></tt></a>):</p>
<img alt="_images/ellipsoid_mesh.png" class="align-center" src="_images/ellipsoid_mesh.png" style="width: 488px; height: 424px;" />
<p>To compute the hysteresis loop for the ellipsoid, we use the
script <a class="reference download internal" href="_downloads/ellipsoid1.py"><tt class="xref download docutils literal"><span class="pre">ellipsoid.py</span></tt></a>:</p>
<pre class="literal-block">
import nmag
from nmag import SI, at

#create simulation object
sim = nmag.Simulation()

# define magnetic material
Py = nmag.MagMaterial(name=&#8221;Py&#8221;,
                      Ms=SI(1e6,&#8221;A/m&#8221;),
                      exchange_coupling=SI(13.0e-12, &#8220;J/m&#8221;))

# load mesh: the mesh dimensions are scaled by 0.5 nm
sim.load_mesh(&#8220;ellipsoid.nmesh.h5&#8221;,
              [(&#8220;ellipsoid&#8221;, Py)],
              unit_length=SI(1e-9,&#8221;m&#8221;))

# set initial magnetisation
sim.set_m([1.,1.,0.])

Hs = nmag.vector_set(direction=[1.,1.,0.],
                     norm_list=[1.0, 0.995, [], -1.0,
                                -0.995, -0.990, [], 1.0],
                     units=1e6*SI(&#8216;A/m&#8217;))

# loop over the applied fields Hs
sim.hysteresis(Hs, save=[(&#8216;averages&#8217;, at(&#8216;convergence&#8217;))])


</pre>
<p>We apply external magnetic fields in [110] direction (i.e. 45 degrees
between the x and the y-axis) to this system, with strengths in the
range of 1000 kA/m down to -1000 kA/m in steps of <tt class="docutils literal"><span class="pre">5</span> <span class="pre">kA/m</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">save</span></tt> parameter is used to tell the hysteresis command what
data to save, and how often. Here, we are only interested in saving
the spatially averaged magnetisation values for every stage (i.e.
meta-stable equilibrium before the applied field is changed).</p>
<div class="section" id="plotting-the-hysteresis-loop">
<span id="id1"></span><h4>Plotting the hysteresis loop<a class="headerlink" href="manual.html#plotting-the-hysteresis-loop" title="Permalink to this headline">¶</a></h4>
<p>To extract the data needed for plotting the hysteresis loop
we proceed as explained in the previous
example <a class="reference internal" href="manual.html#simple-hysteresis-example"><em>Example: Simple hysteresis loop</em></a>.
We use the <a class="reference internal" href="manual.html#ncol"><em>ncol</em></a> command and extract the data into a text file
named <a class="reference download internal" href="_downloads/plot2.dat"><tt class="xref download docutils literal"><span class="pre">plot.dat</span></tt></a>:</p>
<div class="highlight-python"><pre>$ ncol ellipsoid H_ext_0 H_ext_1 H_ext_2 m_Py_0 m_Py_1 m_Py_2 &gt; plot.dat</pre>
</div>
<p>We then use <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> to plot the loop:</p>
<div class="highlight-python"><pre>$ gnuplot make_plot.gnu</pre>
</div>
<p>The gnuplot script <a class="reference download internal" href="_downloads/make_plot2.gnu"><tt class="xref download docutils literal"><span class="pre">make_plot.gnu</span></tt></a> is:</p>
<div class="highlight-python"><pre>set term postscript eps enhanced color
set out 'hysteresis.eps'
set xlabel 'Applied field (kA/m)'
set ylabel 'M / Ms'
versor_x = 1/sqrt(2)
versor_y = 1/sqrt(2)
versor_z = 0.0
scalar_prod(x1,x2,x3) = x1*versor_x + x2*versor_y + x3*versor_z

set mxtics 5            # minor tics and grid
set ytics 1
set mytics 5
set grid xtics ytics mxtics mytics lt -1 lw 0.5, lt 0
plot [-1050:1050] [-1.2:1.2] \
  'plot.dat' u (scalar_prod($1,$2,$3)/1000):(scalar_prod($4,$5,$6)) t 'Stoner-Wohlfarth' w lp 4

</pre>
</div>
<p>Note that within the gnuplot file, we project the magnetisation data
in the <tt class="docutils literal"><span class="pre">[1,1,0]</span></tt> direction because the applied field was acting
in this direction. We obtain this hysteresis loop:</p>
<img alt="_images/hysteresis1.png" class="align-center" src="_images/hysteresis1.png" style="width: 718px; height: 508px;" />
<p>The coercive field, which is located somewhere between 165 and 170
kA/m, can now be compared with the analytically known result for this
particular system. To compute it, we need the demagnetizing factors
Nx, Ny, Nz of the particle along the main axes. Since we deal with a
prolate ellipsoid where two of the axes have the same dimension (y and
z in this case), it is sufficient to compute the factor along the
longest axis (x axis). The other two are easily derived from the
relation Nx + Ny + Nz = 1.  The expression to compute Nx is</p>
<div class="math">
<p><img src="_images/math/eeb9670c74eb574bb351dab2163cda5573abfabb.png" alt="N_x = \frac{1}{m^2-1} \cdot \left[ \frac{m}{2\sqrt{m^2-1}} \cdot \ln\left( \frac{m+\sqrt{m^2-1}}{m-\sqrt{m^2-1}} \right) - 1 \right]" /></p>
</div><p>where we call the length of the x semi-axis <tt class="docutils literal"><span class="pre">a</span></tt>, the length of the y
(or z) semi-axis <tt class="docutils literal"><span class="pre">c</span></tt>, and take <tt class="docutils literal"><span class="pre">m</span></tt> to be the ratio
<tt class="docutils literal"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">a/c</span></tt>. Here, the value of Nx is therefore 0.1087, so we have
Ny = Nz = 0.4456. With these values the shape anisotropy is easily
computed according to the expression:</p>
<div class="math">
<p><img src="_images/math/464c9a50062ec44f76d8966cdeb3121b925ebf6e.png" alt="H_a = M_s \cdot \Delta N = M_s \cdot \left(N_z-N_x\right)" /></p>
</div><p>This gives Ha = 337 kA/m in the case of Ms = 1000 kA/m.  The final
step is to compute the coercive field hc using this analytical
(Stoner-Wohlfarth) result:</p>
<div class="math">
<p><img src="_images/math/31f87efdabf5943ef4b42427eb3e139f318e99aa.png" alt="h_c = \frac{H_c}{H_a} = \sin \theta_0 \cdot \cos \theta_0" /></p>
</div><p>Here, theta_0 is the angle between the easy-axis of the particle
(x-axis in our case) and the direction of the applied
field. Substituting theta_0 = 45 (degrees) in the formula, we obtain
hc = 0.5, that is Hc = 0.5 * Ha = 168 kA/m.  As we have seen before,
the simulated hysteresis loop gives a value between 165 and 170 kA/m,
which is in agreement with the analytical solution.</p>
<p>Note that this simulation is relatively slow due to a number of
constraints: to get good Stoner-Wolfarth behaviour, we need to
describe the shape of the ellipsoid well, and thus need a small
edgelength when we generate the mesh. We further need uniform
behaviour of the magnetisation, which limits the overall size of the
ellipsoid. A general property of micromagnetic simulations is that the
associated differential equations get stiffer if the edge lengths (or
more generally: distances between neighbouring degrees of freedom)
become smaller. Stiffer systems of differential equations are harder
to intergrate, and thus take more time.</p>
</div>
</div>
<span id="document-example_hysteresis_disk/doc"></span><div class="section" id="example-hysteresis-loop-for-thin-disk">
<span id="example-hysteresis-disk"></span><h3>Example: Hysteresis loop for thin disk<a class="headerlink" href="manual.html#example-hysteresis-loop-for-thin-disk" title="Permalink to this headline">¶</a></h3>
<p>This example computes the hysteresis loop of a flat disc magnetised
along a direction orthogonal to the main axis. In comparison to the
previous <a class="reference internal" href="manual.html#stoner-wohlfarth-example"><em>Example: Hysteresis loop for Stoner-Wohlfarth particle</em></a>, it demonstrates the use of a
more complex sequence of applied fields.</p>
<p>We use a disc 20 nm thick and 200 nm in diameter for this example (the
mesh is contained in <a class="reference download internal" href="_downloads/nanodot1.nmesh.h5"><tt class="xref download docutils literal"><span class="pre">nanodot1.nmesh.h5</span></tt></a>
which is created from <a class="reference download internal" href="_downloads/the_nanodot.geo"><tt class="xref download docutils literal"><span class="pre">the_nanodot.geo</span></tt></a> with <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a>):</p>
<img alt="_images/nanodot1_mesh.png" class="align-center" src="_images/nanodot1_mesh.png" style="width: 515px; height: 346px;" />
<p>To compute the hysteresis loop for the disc, we use the script
<a class="reference download internal" href="_downloads/nanodot1.py"><tt class="xref download docutils literal"><span class="pre">nanodot1.py</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">at</span>

<span class="c">#create simulation object</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>

<span class="c"># define magnetic material</span>
<span class="n">Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                       <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mi">795774</span><span class="p">,</span><span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                       <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">)</span>
                     <span class="p">)</span>

<span class="c"># load mesh: the mesh dimensions are scaled by 100nm</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span> <span class="s">&quot;nanodot1.nmesh.h5&quot;</span><span class="p">,</span>
               <span class="p">[(</span><span class="s">&quot;cylinder&quot;</span><span class="p">,</span> <span class="n">Py</span><span class="p">)],</span>
               <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">100e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">)</span>
             <span class="p">)</span>

<span class="c"># set initial magnetisation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>

<span class="n">Hs</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">vector_set</span><span class="p">(</span> <span class="n">direction</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],</span>
                      <span class="n">norm_list</span><span class="o">=</span><span class="p">[</span><span class="mf">1000.0</span><span class="p">,</span> <span class="mf">900.0</span><span class="p">,</span> <span class="p">[],</span>
                                 <span class="mf">95.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">,</span> <span class="p">[],</span>
                                 <span class="o">-</span><span class="mf">100.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">200.0</span><span class="p">,</span> <span class="p">[],</span>
                                 <span class="o">-</span><span class="mf">1000.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">900.0</span><span class="p">,</span> <span class="p">[],</span>
                                 <span class="o">-</span><span class="mf">95.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">90.0</span><span class="p">,</span> <span class="p">[],</span>
                                 <span class="mf">100.0</span><span class="p">,</span> <span class="mf">200.0</span><span class="p">,</span> <span class="p">[],</span> <span class="mf">1000.0</span><span class="p">],</span>
                      <span class="n">units</span><span class="o">=</span><span class="mf">1e3</span><span class="o">*</span><span class="n">SI</span><span class="p">(</span><span class="s">&#39;A/m&#39;</span><span class="p">)</span>
                    <span class="p">)</span>


<span class="c"># loop over the applied fields Hs</span>
<span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span>
               <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="s">&#39;restart&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))]</span>
               <span class="p">)</span>
</pre></div>
</div>
<p>We assume that the previous example have been sufficiently instructive
to explain the basic steps such as importing nmag, creating a
simulation object, defining the material and leading the mesh. Here,
we focus on the <a class="reference internal" href="manual.html#hysteresis"><em>hysteresis</em></a> command:</p>
<p>We would like to apply fields ranging from <tt class="docutils literal"><span class="pre">[1e6,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt> to
<tt class="docutils literal"><span class="pre">[100e3,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt> in steps of <tt class="docutils literal"><span class="pre">100e3</span> <span class="pre">A/m</span></tt>. Then, from <tt class="docutils literal"><span class="pre">[95e3,</span>
<span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt> to <tt class="docutils literal"><span class="pre">[-95e3,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt> we would like to use a smaller
step size of <tt class="docutils literal"><span class="pre">5e3</span> <span class="pre">A/m</span></tt> (to resolve this applied field range better).</p>
<p>This will take us through zero applied field (<tt class="docutils literal"><span class="pre">[0,0,0]</span> <span class="pre">A/m</span></tt>). Now,
symmetrically to the positive field values, we would like to use a
step size of <tt class="docutils literal"><span class="pre">100e3</span> <span class="pre">A/m</span></tt> again to go from <tt class="docutils literal"><span class="pre">[-100e3,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt> to
<tt class="docutils literal"><span class="pre">[-1e6,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt>. At this point, we would like to reverse the whole
sequence (to sweep the field back to the initial value).</p>
<p>The information we need for the <a class="reference internal" href="manual.html#hysteresis"><em>hysteresis</em></a> command includes:</p>
<ol class="arabic">
<li><p class="first">a direction for the applied field (here just <tt class="docutils literal"><span class="pre">[1,0,0]</span></tt>),</p>
</li>
<li><p class="first">a list of magnitudes of the field (this is the <tt class="docutils literal"><span class="pre">norm_list</span></tt>) that
will be interpreted, and then multiplied with the direction vector,</p>
<p>As in the <a class="reference internal" href="manual.html#simple-hysteresis-example"><em>Example: Simple hysteresis loop</em></a> and in the
<a class="reference internal" href="manual.html#stoner-wohlfarth-example"><em>Example: Hysteresis loop for Stoner-Wohlfarth particle</em></a>, we employ a special notation for
ranges of field strengths understood by <tt class="docutils literal"><span class="pre">nmag.vector_set</span></tt>.  The
expression:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="mf">1000.0</span><span class="p">,</span> <span class="mf">900.0</span><span class="p">,</span> <span class="p">[],</span> <span class="mf">95.0</span><span class="p">]</span>
</pre></div>
</div>
<p>means that we start with a magnitude of 1000, the next magnitude is
900. The empty brackets (<tt class="docutils literal"><span class="pre">[]</span></tt>) indicate that this sequence should
be continued (i.e. 800, 700, 600, 500, 400, 300, 200, 100) up to but
not beyond the next value given (i.e. 95).</p>
</li>
<li><p class="first">another multiplier that defines the strength of the applied fields
(here, <tt class="docutils literal"><span class="pre">1e3*SI('A/m')</span></tt>).</p>
</li>
</ol>
<p>The corresponding command is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Hs</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">vector_set</span><span class="p">(</span> <span class="n">direction</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                      <span class="n">norm_list</span><span class="o">=</span><span class="p">[</span><span class="mf">1000.0</span><span class="p">,</span> <span class="mf">900.0</span><span class="p">,</span> <span class="p">[],</span>
                                   <span class="mf">95.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">,</span> <span class="p">[],</span>
                                 <span class="o">-</span><span class="mf">100.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">200.0</span><span class="p">,</span> <span class="p">[],</span>
                                 <span class="o">-</span><span class="mf">1000.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">900.0</span><span class="p">,</span> <span class="p">[],</span>
                                 <span class="o">-</span><span class="mf">95.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">90.0</span><span class="p">,</span> <span class="p">[],</span>
                                 <span class="mf">100.0</span><span class="p">,</span> <span class="mf">200.0</span><span class="p">,</span> <span class="p">[],</span> <span class="mf">1000.0</span><span class="p">],</span>
                      <span class="n">units</span><span class="o">=</span><span class="mf">1e6</span><span class="o">*</span><span class="n">SI</span><span class="p">(</span><span class="s">&#39;A/m&#39;</span><span class="p">)</span>
                    <span class="p">)</span>
</pre></div>
</div>
<p>which computes a list of vectors <tt class="docutils literal"><span class="pre">Hs</span></tt>. The <a class="reference internal" href="manual.html#hysteresis"><em>hysteresis</em></a> command takes
this list of applied fields <tt class="docutils literal"><span class="pre">Hs</span></tt> as one input parameter, and will
compute the hysteresis loop for these fields:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span>
               <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="s">&#39;restart&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))]</span>
              <span class="p">)</span>
</pre></div>
</div>
<p>Again, the second parameter (<tt class="docutils literal"><span class="pre">save</span></tt>) is used to tell the hysteresis
command what data to save, and how often. We request that the
<em>averages</em> of the fields, the <em>fields</em> and the <em>restart</em> data
should be saved <em>at</em> those points in time where we reach <em>convergence</em>.
(See also <a class="reference internal" href="manual.html#restart-example"><em>Restart example</em></a>).</p>
<div class="section" id="thin-disk-hysteresis-loop">
<span id="id1"></span><h4>Thin disk hysteresis loop<a class="headerlink" href="manual.html#thin-disk-hysteresis-loop" title="Permalink to this headline">¶</a></h4>
<p>Once the calculation has finished, we can plot the hysteresis loop,
i.e. the graph of the magnetisation computed along the direction of
the applied field as a function of the applied field strength.</p>
<p>We use the <a class="reference internal" href="manual.html#ncol"><em>ncol</em></a> command to extract the data into a text file <a class="reference download internal" href="_downloads/plot.dat"><tt class="xref download docutils literal"><span class="pre">plot.dat</span></tt></a>:</p>
<div class="highlight-python"><pre>$ ncol nanodot1 H_ext_0 m_Py_0 &gt; plot.dat</pre>
</div>
<p>This file starts as follows:</p>
<div class="highlight-python"><pre>      1000000  0.9995058139817 
      1000000  0.9995058139817 
       900000  0.9994226410102 
       900000  0.9994226410102 
       800000  0.9993139080655 
</pre>
</div>
<p>We use <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> to plot the hysteresis loop:</p>
<div class="highlight-python"><pre>$ gnuplot make_plot.gnu</pre>
</div>
<p>using the gnuplot script <a class="reference download internal" href="_downloads/make_plot.gnu"><tt class="xref download docutils literal"><span class="pre">make_plot.gnu</span></tt></a>:</p>
<div class="highlight-python"><pre>set term postscript eps enhanced color
set out 'nanodot_hyst.eps'
set xlabel 'Applied field (A/m)'
set ylabel 'M / Ms'
set xrange [-1.2e6:1.2e6]
set yrange [-1.2:1.2]
plot 'plot.dat' u 1:2 ti 'nmag' with linespoints lw 3 pt 5
</pre>
</div>
<p>The resulting graph is:</p>
<img alt="_images/nanodot_hyst.png" class="align-center" src="_images/nanodot_hyst.png" style="width: 717px; height: 508px;" />
<p>and the comparison with the <a class="reference external" href="http://www.magpar.net/">Magpar</a> data, obtained with the
script <a class="reference download internal" href="_downloads/make_comparison_plot.gnu"><tt class="xref download docutils literal"><span class="pre">make_comparison_plot.gnu</span></tt></a>:</p>
<div class="highlight-python"><pre>set term postscript eps enhanced color
set out 'nanodot_comparison_hyst.eps'
set xlabel 'Applied field (kA/m)'
set ylabel 'M / Ms'
set xrange [-0.2e3:0.2e3]
set yrange [-1.2:1.2]
plot 'plot.dat' u ($1/1000):2  ti 'nmag' w lp 3, 'magpar.dat' u 1:2  ti 'magpar' w p 4
</pre>
</div>
<p>is shown here (note that the <a class="reference external" href="http://www.magpar.net/">Magpar</a> computation only shows half of
the hysteresis loop.):</p>
<img alt="_images/nanodot_comparison_hyst.png" class="align-center" src="_images/nanodot_comparison_hyst.png" style="width: 730px; height: 508px;" />
<p>Here we can see a slight difference between nmag and <a class="reference external" href="http://www.magpar.net/">Magpar</a> in the
location of the switching point, probably due to different tolerances
in both programs when determining time integrator convergence.</p>
</div>
</div>
<span id="document-example_vortex/doc"></span><div class="section" id="example-vortex-formation-and-propagation-in-disk">
<h3>Example: Vortex formation and propagation in disk<a class="headerlink" href="manual.html#example-vortex-formation-and-propagation-in-disk" title="Permalink to this headline">¶</a></h3>
<p>This example computes the evolution of a vortex in a flat cylinder
magnetised along a direction orthogonal to the main axis.</p>
<p>We use the same geometry as in the <a class="reference internal" href="manual.html#example-hysteresis-disk"><em>Hysteresis loop for thin
disk example</em></a>: a flat cylinder, 20 nm thick and 200 nm in diameter (the mesh
is contained in <a class="reference download internal" href="_downloads/nanodot.nmesh.h5"><tt class="xref download docutils literal"><span class="pre">nanodot.nmesh.h5</span></tt></a>):</p>
<img alt="_images/nanodot_mesh.png" class="align-center" src="_images/nanodot_mesh.png" style="width: 515px; height: 346px;" />
<p>To simulate the magnetised disc, we use the following
script (<a class="reference download internal" href="_downloads/nanodot.py"><tt class="xref download docutils literal"><span class="pre">nanodot.py</span></tt></a>):</p>
<pre class="literal-block">
import nmag
from nmag import SI, at

#create simulation object
sim = nmag.Simulation()

# define magnetic material
Py = nmag.MagMaterial( name=&#8221;Py&#8221;,
                       Ms=SI(795774,&#8221;A/m&#8221;),
                       exchange_coupling=SI(13.0e-12, &#8220;J/m&#8221;)
                     )

# load mesh: the mesh dimensions are scaled by 100nm
sim.load_mesh( &#8221;../example_vortex/nanodot.nmesh.h5&#8221;,
               [(&#8220;cylinder&#8221;, Py)],
               unit_length=SI(100e-9,&#8221;m&#8221;)
             )

# set initial magnetisation
sim.set_m([1.,0.,0.])

Hs = nmag.vector_set( direction=[1.,0.,0.],
                      norm_list=[12.0, 7.0, [], -200.0],
                      units=1e3*SI(&#8216;A/m&#8217;)
                    )


# loop over the applied fields Hs
sim.hysteresis(Hs,
               save=[(&#8216;averages&#8217;, at(&#8216;convergence&#8217;)),
                     (&#8216;fields&#8217;,   at(&#8216;convergence&#8217;)),
                     (&#8216;restart&#8217;,  at(&#8216;convergence&#8217;)) 
                    ]
               )


</pre>
<p>We would like to compute the magnetisation behaviour in the applied
fields ranging from <tt class="docutils literal"><span class="pre">[12e3,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt> to <tt class="docutils literal"><span class="pre">[-200e3,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt> in
steps of <tt class="docutils literal"><span class="pre">-5e3</span> <span class="pre">A/m</span></tt>. The command for this is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Hs</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">vector_set</span><span class="p">(</span> <span class="n">direction</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                      <span class="n">norm_list</span><span class="o">=</span><span class="p">[</span><span class="mf">12.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="p">[],</span> <span class="o">-</span><span class="mf">200.0</span><span class="p">],</span>
                      <span class="n">units</span><span class="o">=</span><span class="mf">1e3</span><span class="o">*</span><span class="n">SI</span><span class="p">(</span><span class="s">&#39;A/m&#39;</span><span class="p">)</span>
                    <span class="p">)</span>

<span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span>
               <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">)),</span>
                     <span class="p">(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span>   <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">)),</span>
                     <span class="p">(</span><span class="s">&#39;restart&#39;</span><span class="p">,</span>  <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))</span>
                    <span class="p">]</span>
              <span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="manual.html#ncol"><em>ncol</em></a> command allows us to extract the data and we redirect it to
a text file with name <a class="reference download internal" href="_downloads/nmag.dat"><tt class="xref download docutils literal"><span class="pre">nmag.dat</span></tt></a>:</p>
<div class="highlight-python"><pre>$ ncol nanodot H_ext_0 m_Py_0 &gt; nmag.dat</pre>
</div>
<p>Plotting the data with <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a>:</p>
<div class="highlight-python"><pre>$ gnuplot make_comparison_plot.gnu</pre>
</div>
<p>which uses the script in <a class="reference download internal" href="_downloads/make_comparison_plot1.gnu"><tt class="xref download docutils literal"><span class="pre">make_comparison_plot.gnu</span></tt></a>:</p>
<pre class="literal-block">
set term postscript eps enhanced color  
set out &#8216;nanodot_evo.eps&#8217;
set xlabel &#8216;Applied field (kA/m)&#8217;
set ylabel &#8216;M / M_s&#8217;
plot [-250:50] [-1.2:1.2] &#8216;magpar.dat&#8217; u 2:3 ti &#8216;magpar&#8217; w lp 4 , &#8216;nmag.dat&#8217; u ($1/1000):2  ti &#8216;nmag&#8217; w lp 3


</pre>
<p>The resulting graph is shown here:</p>
<img alt="_images/nanodot_evo.png" class="align-center" src="_images/nanodot_evo.png" style="width: 750px; height: 525px;" />
<p>and we can see that the results from <a class="reference internal" href="manual.html#nsim"><em>nsim</em></a> match those from <a class="reference external" href="http://www.magpar.net/">magpar</a>.
The magnetisation configurations during the switching process are
shown in the following snapshots:</p>
<div class="figure align-center">
<img alt="nanodot-1" src="_images/nanodot-1.png" />
<p class="caption">Magnetisation configuration for a decreasing applied field of 20 kA/m. The x-axis is increasing from left to right for this and the subsequent plots.</p>
</div>
<div class="figure align-center">
<img alt="nanodot-2" src="_images/nanodot-2.png" />
<p class="caption">Magnetisation configuration for a decreasing applied field of 15 kA/m.</p>
</div>
<div class="figure align-center">
<img alt="nanodot-3" src="_images/nanodot-3.png" />
<p class="caption">Magnetisation configuration for a decreasing applied field of 10 kA/m.</p>
</div>
<div class="figure align-center">
<img alt="nanodot-4" src="_images/nanodot-4.png" />
<p class="caption">Magnetisation configuration for a decreasing applied field of -30 kA/m.</p>
</div>
<div class="figure align-center">
<img alt="nanodot-5" src="_images/nanodot-5.png" />
<p class="caption">Magnetisation configuration for a decreasing applied field of -95 kA/m.</p>
</div>
<div class="figure align-center">
<img alt="nanodot-6" src="_images/nanodot-6.png" />
<p class="caption">Magnetisation configuration for a decreasing applied field of -100 kA/m.</p>
</div>
<p>We see that during magnetisation reversal a vortex nucleates on the
boundary of the disc when the field is sufficiently decreased from its
saturation value. As the field direction is aligned with the x-axis,
the vortex appears in the disc region with the largest y component,
and it moves downwards towards the centre along the y-axis. With a
further decrease of the applied field the vortex moves towards the
opposite side of the disc with respect to the nucleation position, and
it is eventually expelled when the magnetisation aligns with the field
direction over all the disc.</p>
</div>
<span id="document-example_manipulate/doc"></span><div class="section" id="example-manipulating-magnetisation">
<h3>Example: Manipulating magnetisation<a class="headerlink" href="manual.html#example-manipulating-magnetisation" title="Permalink to this headline">¶</a></h3>
<p>There are two basic techniques to modify the magnetisation: on the one
hand, we can use the <a class="reference internal" href="manual.html#set-m"><em>set_m</em></a> method to replace the current
magnetisation configuration with a new one. We can use <a class="reference internal" href="manual.html#set-m"><em>set_m</em></a> to specify
both homogeneous (see <a class="reference internal" href="manual.html#setting-the-initial-magnetisation"><em>Setting the initial magnetisation</em></a>)
and non-homogeneous magnetisations (see the <a class="reference internal" href="manual.html#spin-waves-example"><em>Spin-waves example</em></a>).
Alternatively, we can selectively change magnetic moments at individual mesh sites.
This example demonstrates how to use the latter technique.</p>
<p>The basics of this system are as in <a class="reference internal" href="manual.html#example-1"><em>Example: Demag field in uniformly
magnetised sphere</em></a>: we study a ferromagnetic sphere with initially
homogeneous magnetisation. The corresponding script file is
<a class="reference download internal" href="_downloads/sphere_manipulate.py"><tt class="xref download docutils literal"><span class="pre">sphere_manipulate.py</span></tt></a></p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span>

<span class="c"># Create simulation object</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>

<span class="c"># Define magnetic material</span>
<span class="n">Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e6</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">))</span>

<span class="c"># Load mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;sphere1.nmesh.h5&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;sphere&quot;</span><span class="p">,</span> <span class="n">Py</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">))</span>

<span class="c"># Set initial magnetisation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="c"># Set external field</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_H_ext</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">SI</span><span class="p">(</span><span class="s">&quot;A/m&quot;</span><span class="p">))</span>

<span class="c"># Save and display data in a variety of ways</span>
<span class="c"># Step 1: save all fields spatially resolved</span>

<span class="n">sim</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">)</span>

<span class="c"># Step 2: sample demag field through sphere</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="mf">1e-9</span>                      <span class="c"># position in metres</span>
    <span class="n">H_demag</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">probe_subfield_siv</span><span class="p">(</span><span class="s">&#39;H_demag&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">print</span> <span class="s">&quot;x =&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s">&quot;: H_demag = &quot;</span><span class="p">,</span> <span class="n">H_demag</span>

<span class="c"># Step 3: sample exchange field through sphere</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="mf">1e-9</span>                      <span class="c"># position in metres</span>
    <span class="n">H_exch_Py</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">probe_subfield_siv</span><span class="p">(</span><span class="s">&#39;H_exch_Py&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">print</span> <span class="s">&quot;x =&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s">&quot;: H_exch_Py = &quot;</span><span class="p">,</span> <span class="n">H_exch_Py</span>


<span class="c"># Now modify the magnetisation at position (0,0,0) (this happens to be</span>
<span class="c"># node 0 in the mesh) in steps 4 to 6:</span>

<span class="c"># Step 4: request a vector with the magnetisation of all sites in the mesh</span>
<span class="n">myM</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_subfield</span><span class="p">(</span><span class="s">&#39;m_Py&#39;</span><span class="p">)</span>

<span class="c"># Step 5:  We modify the first entry:</span>
<span class="n">myM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="c"># Step 6: Set the magnetisation to the new (modified) values</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">(</span><span class="n">myM</span><span class="p">)</span>

<span class="c"># Step 7: saving the fields again (so that we can later plot the demag</span>
<span class="c"># and exchange field)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">)</span> 

<span class="c"># Step 8: sample demag field through sphere (as step 2)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="mf">1e-9</span>                      <span class="c"># position in metres</span>
    <span class="n">H_demag</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">probe_subfield_siv</span><span class="p">(</span><span class="s">&#39;H_demag&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">print</span> <span class="s">&quot;x =&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s">&quot;: H_demag = &quot;</span><span class="p">,</span> <span class="n">H_demag</span>

<span class="c"># Step 9: sample exchange field through sphere (as step 3)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="mf">1e-9</span>                      <span class="c"># position in metres</span>
    <span class="n">H_exch_Py</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">probe_subfield_siv</span><span class="p">(</span><span class="s">&#39;H_exch_Py&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">print</span> <span class="s">&quot;x =&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s">&quot;: H_exch_Py = &quot;</span><span class="p">,</span> <span class="n">H_exch_Py</span>
</pre></div>
</div>
<p>To execute this script, we have to give its name to the <a class="reference internal" href="manual.html#nsim"><em>nsim</em></a>
executable, for example (on linux):</p>
<div class="highlight-python"><pre>$ nsim sphere_manipulate.py</pre>
</div>
<p>After having created the simulation object, defined the material,
loaded the mesh, set the initial magnetisation and the external field,
we save the data the first time (Step 1).</p>
<p>We could visualise the magnetisation and all other fields as described
in <a class="reference internal" href="manual.html#example-1"><em>Example: Demag field in uniformly magnetised sphere</em></a>, and would
obtain the same figures as shown in section
<a class="reference internal" href="manual.html#saving-spatially-resolved-data"><em>Saving spatially resolved data</em></a>.</p>
<p>In step 2, we probe the demag field at positions along a line going
from [-10,0,0]nm to [10,0,0]nm, and then print the values. This
produces the following output:</p>
<div class="highlight-python"><pre>x = -1e-08 : H_demag =  None
x = -9e-09 : H_demag =  [-329656.18892701436, 131.69946810517845, 197.13873034397167]
x = -8e-09 : H_demag =  [-329783.31649797881, 68.617197264295427, 140.00328871543459]
x = -7e-09 : H_demag =  [-329842.17628131888, 183.37401011699876, 163.01612229436262]
x = -6e-09 : H_demag =  [-329904.84956877632, 133.62473797637142, 74.090532749764847]
x = -5e-09 : H_demag =  [-329974.43178624194, 85.517390832982983, -13.956465964930704]
x = -4e-09 : H_demag =  [-330002.69224229571, 64.187663119270084, -30.832135394870004]
x = -3e-09 : H_demag =  [-330006.79488959321, 25.479055440690821, -61.958073893954818]
x = -2e-09 : H_demag =  [-330020.18327401817, 11.70722487517595, -58.143562276077219]
x = -1e-09 : H_demag =  [-330025.52325345919, -5.7120648683347452, -52.237341988696294]
x = 0.0    : H_demag =  [-330028.67095553532, -25.707310077918752, -46.346108473560378]
x = 1e-09  : H_demag =  [-330058.98559210222, -37.699378078580203, -41.167364094137213]
x = 2e-09  : H_demag =  [-330089.30022866925, -49.691446079241658, -35.988619714714041]
x = 3e-09  : H_demag =  [-330145.36618529289, -63.819285767062581, -22.213920341440794]
x = 4e-09  : H_demag =  [-330220.13307247689, -76.54950394725968, -5.0509172407556262]
x = 5e-09  : H_demag =  [-330298.69089200837, -90.534514175273259, 13.57279800234617]
x = 6e-09  : H_demag =  [-330375.34327985492, -117.01128011426778, 35.262477275758371]
x = 7e-09  : H_demag =  [-330415.38940687838, -123.68558207391983, 60.580352625726341]
x = 8e-09  : H_demag =  [-330474.37719032855, -112.22952205433305, 106.13032196062491]
x = 9e-09  : H_demag =  [-330499.64039893239, -69.97070465326442, 160.41688110297264]
x = 1e-08  : H_demag =  [-330518.649930441, -26.536490670368085, 212.32392103651733]</pre>
</div>
<p>The data is approximately 1/3 Ms = 333333 (A/m) in the direction of the
magnetisation, and approximately zero in the other directions, as we
would expect in a homogeneously magnetised sphere. The deviations we
see are due to (i) the shape of the sphere not being perfectly
resolved (<em>ie</em> we actually look at the demag field of a polyhedron)
and (ii) numerical errors.</p>
<p>In step 3, we probe the exchange field along the same line. The
exchange field is effectively zero because the magnetisation is
pointing everywhere in the same direction:</p>
<div class="highlight-python"><pre>x = -1e-08 : H_exch_Py =  None
x = -9e-09 : H_exch_Py =  [-1.264324643856989e-09, 0.0, 0.0]
x = -8e-09 : H_exch_Py =  [-2.0419540595507732e-10, 0.0, 0.0]
x = -7e-09 : H_exch_Py =  [-1.4334754136843496e-09, 0.0, 0.0]
x = -6e-09 : H_exch_Py =  [-2.7214181426130964e-10, 0.0, 0.0]
x = -5e-09 : H_exch_Py =  [1.6323042074911775e-09, 0.0, 0.0]
x = -4e-09 : H_exch_Py =  [-1.6243345875473033e-09, 0.0, 0.0]
x = -3e-09 : H_exch_Py =  [-5.6526341264934703e-09, 0.0, 0.0]
x = -2e-09 : H_exch_Py =  [-6.1145979552370084e-09, 0.0, 0.0]
x = -1e-09 : H_exch_Py =  [-3.0929969691649876e-09, 0.0, 0.0]
x = 0.0    : H_exch_Py =  [9.2633407053741312e-10, 0.0, 0.0]
x = 1e-09  : H_exch_Py =  [1.9476821552904271e-09, 0.0, 0.0]
x = 2e-09  : H_exch_Py =  [2.9690302400434413e-09, 0.0, 0.0]
x = 3e-09  : H_exch_Py =  [2.6077357277001043e-09, 0.0, 0.0]
x = 4e-09  : H_exch_Py =  [1.5836815585162886e-09, 0.0, 0.0]
x = 5e-09  : H_exch_Py =  [1.6602158583197139e-09, 0.0, 0.0]
x = 6e-09  : H_exch_Py =  [1.8844573960991853e-09, 0.0, 0.0]
x = 7e-09  : H_exch_Py =  [-6.2460015649740799e-09, 0.0, 0.0]
x = 8e-09  : H_exch_Py =  [-1.1231714572170603e-08, 0.0, 0.0]
x = 9e-09  : H_exch_Py =  [-7.3643182171284044e-09, 0.0, 0.0]
x = 1e-08  : H_exch_Py =  [-3.4351784609779937e-09, 0.0, 0.0]</pre>
</div>
<p>Note that the subfield name we are probing for the exchange field is
<tt class="docutils literal"><span class="pre">H_exch_Py</span></tt> whereas the subfield name we used to probe the demag
field is <tt class="docutils literal"><span class="pre">H_demag</span></tt> (without the extension <tt class="docutils literal"><span class="pre">_Py</span></tt>. The reason for
this is that the exchange field is a something that is associated with
a particular material (here Py) whereas there is only one demag field
that is experienced by all materials (see also <a class="reference internal" href="manual.html#fields-and-subfields"><em>Fields and subfields</em></a>).</p>
<div class="section" id="modifying-the-magnetisation">
<span id="id1"></span><h4>Modifying the magnetisation<a class="headerlink" href="manual.html#modifying-the-magnetisation" title="Permalink to this headline">¶</a></h4>
<p>In step 4, we use the <a class="reference internal" href="manual.html#get-subfield"><em>get_subfield</em></a> command. This will return a
(<a class="reference internal" href="manual.html#numpy"><em>NumPy</em></a>) array that contains one 3d vector for every <a class="reference internal" href="manual.html#site"><em>Site</em></a> of the
finite element mesh.</p>
<p>In step 5, we modify the first entry in this array (which has index
0), and set its value to <tt class="docutils literal"><span class="pre">[0,1,0]</span></tt>. Whereas the magnetisation is
pointing everywhere in [1,0,0] (because we have used the <a class="reference internal" href="manual.html#set-m"><em>set_m</em></a>
command in the very beginning of the program, it is now pointing in
the [0,1,0] at site 0.</p>
<p>The information, which site corresponds to which entry in the data
vector, that we have obtained using <a class="reference internal" href="manual.html#get-subfield"><em>get_subfield</em></a>, can be retrieved from
<a class="reference internal" href="manual.html#get-subfield-sites"><em>get_subfield_sites</em></a>. Correspondingly, the position of the sites can be
obtained using <a class="reference internal" href="manual.html#get-subfield-positions"><em>get_subfield_positions</em></a>.</p>
<p>We now need to set this modified magnetisation vector (Step 6) using
the <a class="reference internal" href="manual.html#set-m"><em>set_m</em></a> command.</p>
<p>If we save the data again to the file (Step 7), we can subsequently
convert this to a vtk file (using, for example, <tt class="docutils literal"><span class="pre">nmagpp</span> <span class="pre">--vtk</span> <span class="pre">data</span>
<span class="pre">sphere_manipulate</span></tt>) and visualise with <a class="reference internal" href="manual.html#mayavi"><em>MayaVi</em></a>:</p>
<img alt="_images/step7.png" class="align-center" src="_images/step7.png" style="width: 800px; height: 732px;" />
<p>We can see one blue cone in the centre of the sphere - this is the
one site that he have modified to point in the y-direction (whereas all
other cones point in the x-direction).</p>
<p>As before, we can probe the fields along a line through the center of
the sphere (Step 8). For the demag field we obtain:</p>
<div class="highlight-python"><pre>x = -1e-08 : H_demag =  None
x = -9e-09 : H_demag =  [-333816.99138074159, -1884.643376396662, 16.665519199152595]
x = -8e-09 : H_demag =  [-334670.87148225965, -2293.608410913705, -102.38526828192296]
x = -7e-09 : H_demag =  [-335258.77403632947, -3061.1708540342884, -532.73877752122235]
x = -6e-09 : H_demag =  [-339506.72150998382, -5316.1506383768137, -969.36630578549921]
x = -5e-09 : H_demag =  [-344177.83909963415, -8732.9787600552572, -1610.433091871927]
x = -4e-09 : H_demag =  [-344725.75257842313, -16708.164927667149, -5224.2484897904633]
x = -3e-09 : H_demag =  [-337963.49070659198, -24567.078937669514, -3321.016613832679]
x = -2e-09 : H_demag =  [-321612.85117992124, -30613.873989917105, -1385.6383061516099]
x = -1e-09 : H_demag =  [-298312.3363571504, -41265.117003123923, 636.60703829516081]
x = 0.0    : H_demag =  [-273449.78240732534, -52534.176864875568, 2793.5027588779139]
x = 1e-09  : H_demag =  [-293644.21931918303, -39844.049389551074, 4310.6449471266505]
x = 2e-09  : H_demag =  [-313838.65623104072, -27153.921914226579, 5827.7871353753881]
x = 3e-09  : H_demag =  [-330296.09687372146, -21814.293451835449, 5525.7290665358933]
x = 4e-09  : H_demag =  [-343611.94111195666, -18185.932406317523, 4931.5464761658959]
x = 5e-09  : H_demag =  [-348062.40814087034, -11029.603829202088, 3781.8263522408147]
x = 6e-09  : H_demag =  [-342272.36888512014, -6604.210117819096, 50.151907623841332]
x = 7e-09  : H_demag =  [-338716.66400897497, -3860.7761876767272, 485.90273674867018]
x = 8e-09  : H_demag =  [-335656.89887674141, -2610.0345208853882, 586.74812908870092]
x = 9e-09  : H_demag =  [-334985.59512328985, -2169.9546280837162, 542.76746044672041]
x = 1e-08  : H_demag =  [-334441.59096545313, -1634.8337299563193, 627.17874011463311]</pre>
</div>
<p>The change of the magnetisation at position [0,0,0] from [1,0,0] to
[0,1,0] has reduced the x-component of the demag field somewhat around
x=0, and has introduced a significant demag field in the -y direction
around x=0.</p>
<p>Looking at the exchange field (Step 9):</p>
<div class="highlight-python"><pre>x = -1e-08 : H_exch_Py =  None
x = -9e-09 : H_exch_Py =  [-1.264324643856989e-09, 0.0, 0.0]
x = -8e-09 : H_exch_Py =  [-2.0419540595507732e-10, 0.0, 0.0]
x = -7e-09 : H_exch_Py =  [-1.4334754136843496e-09, 0.0, 0.0]
x = -6e-09 : H_exch_Py =  [-2.7214181426130964e-10, 0.0, 0.0]
x = -5e-09 : H_exch_Py =  [1.6323042074911775e-09, 0.0, 0.0]
x = -4e-09 : H_exch_Py =  [-153858.81305452777, 153858.81305452611, 0.0]
x = -3e-09 : H_exch_Py =  [-972420.67935341748, 972420.67935341166, 0.0]
x = -2e-09 : H_exch_Py =  [-2445371.8369108676, 2445371.8369108611, 0.0]
x = -1e-09 : H_exch_Py =  [5283169.701234119, -5283169.7012341227, 0.0]
x = 0.0    : H_exch_Py =  [15888993.991894867, -15888993.991894867, 0.0]
x = 1e-09 :  H_exch_Py =  [8434471.7912872285, -8434471.7912872266, 0.0]
x = 2e-09 :  H_exch_Py =  [979949.59067958547, -979949.59067958279, 0.0]
x = 3e-09 :  H_exch_Py =  [-1112837.3087986181, 1112837.3087986207, 0.0]
x = 4e-09 :  H_exch_Py =  [-193877.66176242317, 193877.6617624248, 0.0]
x = 5e-09 :  H_exch_Py =  [1.6602158583197139e-09, 0.0, 0.0]
x = 6e-09 :  H_exch_Py =  [1.8844573960991853e-09, 0.0, 0.0]
x = 7e-09 :  H_exch_Py =  [-6.2460015649740799e-09, 0.0, 0.0]
x = 8e-09 :  H_exch_Py =  [-1.1231714572170603e-08, 0.0, 0.0]
x = 9e-09 :  H_exch_Py =  [-7.3643182171284044e-09, 0.0, 0.0]
x = 1e-08 :  H_exch_Py =  [-3.4351784609779937e-09, 0.0, 0.0]</pre>
</div>
<p>We can see that the exchange field is indeed very large around x=0.</p>
<p>Note that one of the fundamental problem of micromagnetic simulations
is that the magnetisation must not vary significantly from one site to
another. In this example, we have manually violated this requirement
<em>only to demonstrate</em> how the magnetisation can be modified, and to see that
this is reflected in the dependant fields (such as demag and exchange)
immediately.</p>
</div>
</div>
<span id="document-example_ipython/doc"></span><div class="section" id="example-ipython">
<span id="id1"></span><h3>Example: IPython<a class="headerlink" href="manual.html#example-ipython" title="Permalink to this headline">¶</a></h3>
<p>The basics of this file are as in <a class="reference internal" href="manual.html#example-1"><em>Example: Demag field in uniformly
magnetised sphere</em></a>: a ferromagnetic sphere is studied, and initially
configured to have homogeneous magnetisation.</p>
<p>Here is the source code of <a class="reference download internal" href="_downloads/sphere_ipython.py"><tt class="xref download docutils literal"><span class="pre">sphere_ipython.py</span></tt></a></p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span>

<span class="c"># Create simulation object</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>

<span class="c"># Define magnetic material</span>
<span class="n">Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e6</span><span class="p">,</span><span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">))</span>

<span class="c"># Load mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;sphere1.nmesh.h5&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;sphere&quot;</span><span class="p">,</span> <span class="n">Py</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">))</span>

<span class="c"># Set initial magnetisation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="c"># Activate interactive python session</span>
<span class="n">nmag</span><span class="o">.</span><span class="n">ipython</span><span class="p">()</span>

<span class="k">print</span> <span class="s">&quot;Back in main code&quot;</span>
</pre></div>
</div>
<p>To execute this script, we have to give its name to the <a class="reference internal" href="manual.html#nsim"><em>nsim</em></a>
executable, for example (on linux):</p>
<div class="highlight-python"><pre>$ nsim sphere_ipython.py</pre>
</div>
<p>The new command appearing here is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">nmag</span><span class="o">.</span><span class="n">ipython</span><span class="p">()</span>
</pre></div>
</div>
<p>This calls an interactive python interpreter (this is like the
standard <tt class="docutils literal"><span class="pre">ipython</span></tt> interpreter called from the command prompt).</p>
<p>Once we are &#8220;inside&#8221; this ipython interpreter, we can interactively work with
the simulation object. We demonstrate this with the transcript of such
a session:</p>
<div class="highlight-python"><pre>$ nsim sphere_ipython.py

&lt;snip&gt;

In [1]: sim.get_subfield("H_demag")
Out[1]:
array([[ -3.30028671e+05,  -2.57073101e+01,  -4.63461085e+01],
       [ -3.30518650e+05,  -2.65364907e+01,   2.12323921e+02],
       [ -3.30380750e+05,  -1.34382835e+02,   1.94635283e+01],
       ...,
       [ -3.30063839e+05,   4.56312711e+01,  -1.31204248e+02],
       [ -3.30056243e+05,  -3.23341645e+01,  -2.26732582e+02],
       [ -3.29950815e+05,   4.44150291e+01,  -5.41700794e+01]])

In [2]: sim.set_m([0,0,1])

In [3]: sim.get_subfield("H_demag")
Out[3]:
array([[ -6.86773473e+01,   4.44496808e+01,  -3.30084368e+05],
       [ -2.83792944e+02,   1.78935681e+02,  -3.30268314e+05],
       [ -2.04396266e+02,   2.48374212e+02,  -3.30180923e+05],
       ...,
       [ -1.02055030e+02,  -9.53215211e+01,  -3.30239401e+05],
       [  1.94875407e+02,   1.22757584e+02,  -3.29771010e+05],
       [  6.16259262e+01,   1.66071597e+02,  -3.29848851e+05]])</pre>
</div>
<p>Note that within ipython, one can just press the TAB key to
autocomplete object names, functions and commands.</p>
<p>You can leave the ipython environment by pressing CTRL+D. For the
script shown here, this will print <tt class="docutils literal"><span class="pre">Back</span> <span class="pre">in</span> <span class="pre">main</span> <span class="pre">code</span></tt> before the
end of the script is reached. The <tt class="docutils literal"><span class="pre">ipython()</span></tt> command is
occasionally a handy debugging feature: in order to investigate the
behaviour of the system &#8220;on the spot&#8221;, one can insert an <tt class="docutils literal"><span class="pre">ipython</span></tt> call
into the script which will open an interactive command line.</p>
</div>
<span id="document-example_pinning/doc"></span><div class="section" id="example-pinning-magnetisation">
<h3>Example: Pinning Magnetisation<a class="headerlink" href="manual.html#example-pinning-magnetisation" title="Permalink to this headline">¶</a></h3>
<p>In this example we show how to pin (<em>i.e.</em> fix) magnetisation
in certain parts of a material.</p>
<div class="section" id="pinning-simulation-script">
<span id="id1"></span><h4>Pinning simulation script<a class="headerlink" href="manual.html#pinning-simulation-script" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">si</span>

<span class="c"># Create simulation object</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>

<span class="c"># Define magnetic material: PermAlloy</span>
<span class="n">Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.86e6</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">))</span>

<span class="c"># Load mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;sphere1.nmesh.h5&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;sphere&quot;</span><span class="p">,</span> <span class="n">Py</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">))</span>

<span class="c"># Set initial magnetisation to +x direction</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="c"># Pin magnetisation at center in radius of 4e-9m</span>
<span class="k">def</span> <span class="nf">pin_at_center</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)):</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mf">4e-9</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">4e-9</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.0</span> <span class="c"># Inside the 4nm sphere -&gt; pin</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="mf">1.0</span> <span class="c"># Outside -&gt; do not pin</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_pinning</span><span class="p">(</span><span class="n">pin_at_center</span><span class="p">)</span>

<span class="c"># Apply external field in +y direction</span>
<span class="n">unit</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">si</span><span class="o">.</span><span class="n">Tesla</span><span class="o">/</span><span class="n">si</span><span class="o">.</span><span class="n">mu0</span> <span class="c"># 500mT in A/m</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_H_ext</span><span class="p">([</span><span class="mi">0</span><span class="o">*</span><span class="n">unit</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="n">unit</span><span class="p">,</span> <span class="mi">0</span><span class="o">*</span><span class="n">unit</span><span class="p">])</span>

<span class="c"># Relax the magnetisation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="pinning-magnetisation">
<span id="id2"></span><h4>Pinning magnetisation<a class="headerlink" href="manual.html#pinning-magnetisation" title="Permalink to this headline">¶</a></h4>
<p>In order to allow the user to fix the magnetisation, nmag provides a
scalar field, the so-called <em>pinning field</em>: its value at each site is
used as a scale factor for <tt class="docutils literal"><span class="pre">dm/dt</span></tt>, hence by setting it to 0 at
certain locations of the mesh we can force magnetisation to remain
constant at these locations for the entire simulation.</p>
<p>We set the pinning field using <a class="reference internal" href="manual.html#set-pinning"><em>set_pinning</em></a> (which is used like
<a class="reference internal" href="manual.html#set-m"><em>set_m</em></a> and <a class="reference internal" href="manual.html#set-h-ext"><em>set_H_ext</em></a>, except that it is a scalar field whereas the
latter are vector fields) such that magnetisation is fixed at sites
with distance less than 4 nm from the sphere&#8217;s center. First we define
a Python function which we decide to call <tt class="docutils literal"><span class="pre">pin_at_center</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">pin_at_center</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)):</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mf">4e-9</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">4e-9</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="mf">1.0</span>
</pre></div>
</div>
<p>The function is called for each site of the mesh
and receives the site position as an argument,
a 3-tuple <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></tt> containing the three
components <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">y</span></tt> and <tt class="docutils literal"><span class="pre">z</span></tt> (three floating point numbers),
given in metres.
The function returns either 0.0 (which means the magnetisation
at this position is pinned) or 1.0 (in which case there is no pinning),
for the given position vector.</p>
<p>The formula in the <tt class="docutils literal"><span class="pre">if</span></tt> statement simply evaluates the magnitude
of the vector <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></tt> by squaring each component.
This number is then compared against (4nm)^2.
As a result, the magnetisation is pinned at all the mesh nodes that are
located within a sphere with center <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></tt> and radius 4 nm.
All the nodes that are located outside this sphere can change
their magnetisation as usual.</p>
<p>Second, we need to tell nmag that it should use this function to
decide where the magnetisation should be pinned:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">set_pinning</span><span class="p">(</span><span class="n">pin_at_center</span><span class="p">)</span>
</pre></div>
</div>
<p>Note the slightly counterintuitive fact that value 1 means &#8220;no pinning&#8221;.</p>
<p>Finally we apply an external field of 0.5 T in +y direction, and use
<a class="reference internal" href="manual.html#relax"><em>relax</em></a> to compute the equilibrium configuration.</p>
<p>The <a class="reference internal" href="manual.html#relax"><em>relax</em></a> command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">()</span>
</pre></div>
</div>
<p>will save the fields and averages at convergence (this is the default
of the <a class="reference internal" href="manual.html#relax"><em>relax</em></a> command).</p>
</div>
<div class="section" id="visualisation">
<span id="id3"></span><h4>Visualisation<a class="headerlink" href="manual.html#visualisation" title="Permalink to this headline">¶</a></h4>
<p>After running the example via <tt class="docutils literal"><span class="pre">nsim</span> <span class="pre">sphere.py</span></tt> we convert the equilibrium
data to VTK format:</p>
<div class="highlight-python"><pre>$ nmagpp --vtk=sphere.vtk sphere</pre>
</div>
<p>We would first like to verify that the pinning field has been set up
properly.  Hence we use <a class="reference internal" href="manual.html#mayavi"><em>MayaVi</em></a> to visualise it by showing an
isosurface of the pinning field (shown in blue), together with the
magnetisation vector field.</p>
<img alt="_images/pinned_core.png" class="align-center" src="_images/pinned_core.png" style="width: 800px; height: 836px;" />
<p>The blue blob in the center of the sphere is the collection of those
tetrahedra that have corners just inside the 4nm sphere. Because we
have not generated the mesh to have nodes coinciding with the 4nm
sphere, the shape of the blue region is not particularly spherical.</p>
<p>In the above diagram, we also see the magnetisation vectors of the
final configuration. Their colour corresponds to the pinning field at
their location. It can be seen that the blue magnetisation vectors
emerging from the central region of the sphere are all pointing
(strictly) in the x-direction. The magnetisation vectors outside the
blue sphere are coloured red. The applied field drives these vectors
to point into the y-direction. However, the magnetisation in the
centre is pinned and the exchange interaction requires a gradual
spatial change of magnetisation. This explains the spatial variation
of the magnetisation.</p>
<p>The next figure shows the same data as the last figure but in addition a
<tt class="docutils literal"><span class="pre">ScalarCutPlane</span></tt> (in MayaVi terminology) has been introduced which
is coloured according to the x-component of the magnetisation. Red
corresponds to 1.0 and blue corresponds to 0.73 (we have not shown the
legend to provide a larger main plot). This demonstrates the gradual
change from the pinned magnetisation in the centre to the outside.</p>
<img alt="_images/magnetisation.png" class="align-center" src="_images/magnetisation.png" style="width: 800px; height: 777px;" />
</div>
</div>
<span id="document-example_uniaxial_anis/doc"></span><div class="section" id="example-uniaxial-anisotropy">
<h3>Example: Uniaxial anisotropy<a class="headerlink" href="manual.html#example-uniaxial-anisotropy" title="Permalink to this headline">¶</a></h3>
<p>In this example we would like to simulate the development of a Bloch type
domain wall on a thin cobalt bar of dimension 504 x 1 x 1 nm
(<a class="reference download internal" href="_downloads/bar.nmesh.h5"><tt class="xref download docutils literal"><span class="pre">bar.nmesh.h5</span></tt></a>) due to uniaxial
anisotropy.</p>
<div class="section" id="uniaxial-anisotropy-simulation-script">
<span id="id1"></span><h4>Uniaxial anisotropy simulation script<a class="headerlink" href="manual.html#uniaxial-anisotropy-simulation-script" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">every</span><span class="p">,</span> <span class="n">at</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c"># Create simulation object (no demag field!)</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">do_demag</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c"># Define magnetic material (data from OOMMF materials file)</span>
<span class="n">Co</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Co&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1400e3</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">30e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                      <span class="n">anisotropy</span><span class="o">=</span><span class="n">nmag</span><span class="o">.</span><span class="n">uniaxial_anisotropy</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">K1</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">520e3</span><span class="p">,</span> <span class="s">&quot;J/m^3&quot;</span><span class="p">)))</span>

<span class="c"># Load the mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;bar.nmesh.h5&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="n">Co</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">)</span> <span class="p">)</span>

<span class="c"># Our bar is subdivided into 3 regions:</span>
<span class="c"># - region A: for x &lt; offset;</span>
<span class="c"># - region B: for x between offset and offset+length</span>
<span class="c"># - region C: for x &gt; offset+length;</span>
<span class="c"># The magnetisation is defined over all the three regions,</span>
<span class="c"># but is pinned in region A and C.</span>
<span class="n">offset</span> <span class="o">=</span> <span class="mf">2e-9</span>   <span class="c"># m (meters)</span>
<span class="n">length</span> <span class="o">=</span> <span class="mf">500e-9</span> <span class="c"># m</span>

<span class="c"># Set initial magnetisation</span>
<span class="k">def</span> <span class="nf">sample_m0</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)):</span>
  <span class="c"># relative_position goes linearly from -1 to +1 in region B</span>
  <span class="n">relative_position</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span><span class="o">/</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">mz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">relative_position</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mz</span><span class="o">*</span><span class="n">mz</span><span class="p">),</span> <span class="n">mz</span><span class="p">]</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">(</span><span class="n">sample_m0</span><span class="p">)</span>

<span class="c"># Pin magnetisation outside region B</span>
<span class="k">def</span> <span class="nf">sample_pinning</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)):</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">offset</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">length</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_pinning</span><span class="p">(</span><span class="n">sample_pinning</span><span class="p">)</span>

<span class="c"># Save the magnetisation along the x-axis</span>
<span class="k">def</span> <span class="nf">save_magnetisation_along_x</span><span class="p">(</span><span class="n">sim</span><span class="p">):</span>
  <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;bar_mag_x.dat&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">504</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span> <span class="o">*</span> <span class="mf">1e-9</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">probe_subfield_siv</span><span class="p">(</span><span class="s">&#39;M_Co&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">print</span> <span class="o">&gt;&gt;</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="c"># Relax the system</span>
<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="n">save_magnetisation_along_x</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>
</pre></div>
</div>
<p>We shall now discuss the <a class="reference download internal" href="_downloads/bar.py"><tt class="xref download docutils literal"><span class="pre">bar.py</span></tt></a>  script
step-by-step:</p>
<p>In this particular example we are solely interested in energy terms resulting
from exchange interaction and anisotropy. Hence we disable the demagnetisation
field as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">do_demag</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>We then create the material <tt class="docutils literal"><span class="pre">Co</span></tt> used for the bar, cobalt in this case, which exhibits <a class="reference internal" href="manual.html#uniaxial-anisotropy"><em>uniaxial_anisotropy</em></a> in z direction with phenomenological anisotropy constant
<tt class="docutils literal"><span class="pre">K1</span> <span class="pre">=</span> <span class="pre">SI(520e3,</span> <span class="pre">&quot;J/m^3&quot;)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Co</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Co&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1400e3</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">30e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                      <span class="n">anisotropy</span><span class="o">=</span><span class="n">nmag</span><span class="o">.</span><span class="n">uniaxial_anisotropy</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">K1</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">520e3</span><span class="p">,</span> <span class="s">&quot;J/m^3&quot;</span><span class="p">)))</span>
</pre></div>
</div>
<p>After loading the mesh, we set the initial magnetisation direction such that
it rotates from +z to -z while staying in the plane normal to x direction
(hence suggesting the development of a Bloch type domain wall):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">sample_m0</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)):</span>
  <span class="c"># relative_position goes linearly from -1 to +1 in region B</span>
  <span class="n">relative_position</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span><span class="o">/</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">mz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">relative_position</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mz</span><span class="o">*</span><span class="n">mz</span><span class="p">),</span> <span class="n">mz</span><span class="p">]</span>
</pre></div>
</div>
<p>We further pin the magnetisation at the very left (x &lt; offset = 2 nm)
and right (x &gt; offset + length = 502 nm) of the bar
(note that the pinning function may also just return a python truth
value rather than the number 0.0 or 1.0):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">sample_pinning</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)):</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">offset</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">length</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_pinning</span><span class="p">(</span><span class="n">sample_pinning</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we relax the system to find the equilibrium magnetisation
configuration, which is saved to the file <tt class="docutils literal"><span class="pre">bar_mag_x.dat</span></tt> in a format
understandable by <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a>.</p>
</div>
<div class="section" id="visualization">
<span id="id2"></span><h4>Visualization<a class="headerlink" href="manual.html#visualization" title="Permalink to this headline">¶</a></h4>
<p>We can then use the following <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> script to visualize
the equilibrium magnetisation:</p>
<div class="highlight-python"><pre>set term png giant size 800, 600
set out 'bar_mag_x.png'
set xlabel 'x (nm)'
set ylabel 'M.z (millions of A/m)'

plot [0:504] [-1.5:1.5] \
  1.4 t "" w l 0, -1.4 t "" w l 0, \
  'bar_mag_x.dat' u ($1/1e-9):($4/1e6) t 'nmag' w l 2
</pre>
</div>
<p>The resulting plot clearly shows that a Bloch type domain wall has developed:</p>
<img alt="_images/bar_mag_x.png" class="align-center" src="_images/bar_mag_x.png" style="width: 800px; height: 600px;" />
<p>The figure shows also that the Bloch domain wall is well localized at the center
of the bar, in the region where x goes from 200 to 300 nm.</p>
</div>
<div class="section" id="comparison">
<span id="id3"></span><h4>Comparison<a class="headerlink" href="manual.html#comparison" title="Permalink to this headline">¶</a></h4>
<p>After simulating the same scenario with
OOMMF (see <a class="reference download internal" href="_downloads/bar.mif"><tt class="xref download docutils literal"><span class="pre">oommf/bar.mif</span></tt></a>),
we can compare results using another <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> script:</p>
<div class="highlight-python"><pre>#set term postscript enhanced eps color
set term png giant size 800, 600
set out 'bar_mag_x_compared.png'

set xlabel 'x (nm)'
set ylabel 'M.z (millions of A/m)'

Mz(x) = 1400e3 * cos(pi/2 + atan(sinh((x - 252e-9)/sqrt(30e-12/520e3))))

plot [220:280] [-1.5:1.5] \
  1.4 t "" w l 0, -1.4 t "" w l 0, \
  'bar_mag_x.dat' u ($1/1e-9):($4/1e6) t 'nmag' w lp 2, \
  'oommf/bar_mag_x.txt'u ($1/1e-9):($4/1e6) t 'oommf' w lp 1, \
  Mz(x*1e-9)/1e6 ti 'analytical' w l 3
</pre>
</div>
<p>which generates the following plot showing good agreement of both systems:</p>
<img alt="_images/bar_mag_x_compared.png" class="align-center" src="_images/bar_mag_x_compared.png" style="width: 800px; height: 600px;" />
<p>The plot shows also the known analytical solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Mz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ms</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">atan</span><span class="p">(</span><span class="n">sinh</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_wall</span><span class="p">)</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="o">/</span><span class="n">K1</span><span class="p">))))</span>
</pre></div>
</div>
<p>The plot shows only a restricted region located at the center of the bar,
thus allowing an easier comparison between the three sets of data.</p>
</div>
</div>
<span id="document-example_cubic_anis/doc"></span><div class="section" id="example-cubic-anisotropy">
<h3>Example: Cubic Anisotropy<a class="headerlink" href="manual.html#example-cubic-anisotropy" title="Permalink to this headline">¶</a></h3>
<p>In this example we will study the behaviour of a 10 x 10 x 10 nm iron
cube with <a class="reference internal" href="manual.html#cubic-anisotropy"><em>cubic_anisotropy</em></a> in an external field.</p>
<div class="section" id="cubic-anisotropy-simulation-script">
<span id="id1"></span><h4>Cubic anisotropy simulation script<a class="headerlink" href="manual.html#cubic-anisotropy-simulation-script" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">si</span>

<span class="c"># Create the simulation object</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>

<span class="c"># Define the magnetic material (data from OOMMF materials file)</span>
<span class="n">Fe</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Fe&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1700e3</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">21e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                      <span class="n">anisotropy</span><span class="o">=</span><span class="n">nmag</span><span class="o">.</span><span class="n">cubic_anisotropy</span><span class="p">(</span><span class="n">axis1</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                       <span class="n">axis2</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                       <span class="n">K1</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">48e3</span><span class="p">,</span> <span class="s">&quot;J/m^3&quot;</span><span class="p">)))</span>

<span class="c"># Load the mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;cube.nmesh&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;cube&quot;</span><span class="p">,</span> <span class="n">Fe</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">))</span>

<span class="c"># Set the initial magnetisation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="c"># Launch the hysteresis loop</span>
<span class="n">Hs</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">vector_set</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">],</span>
                     <span class="n">norm_list</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">19</span><span class="p">,</span> <span class="mf">19.1</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">50</span><span class="p">],</span>
                     <span class="n">units</span><span class="o">=</span><span class="mf">0.001</span><span class="o">*</span><span class="n">si</span><span class="o">.</span><span class="n">Tesla</span><span class="o">/</span><span class="n">si</span><span class="o">.</span><span class="n">mu0</span><span class="p">)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="n">Hs</span><span class="p">)</span>
</pre></div>
</div>
<p>We will now discuss the <a class="reference download internal" href="_downloads/cube.py"><tt class="xref download docutils literal"><span class="pre">cube.py</span></tt></a> script step-by-step:</p>
<p>After creating the simulation object we define a magnetic material <tt class="docutils literal"><span class="pre">Fe</span></tt>
with cubic anisotropy representing iron:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Fe</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Fe&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1700e3</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">21e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                      <span class="n">anisotropy</span><span class="o">=</span><span class="n">nmag</span><span class="o">.</span><span class="n">cubic_anisotropy</span><span class="p">(</span><span class="n">axis1</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                                       <span class="n">axis2</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                                       <span class="n">K1</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">48e3</span><span class="p">,</span> <span class="s">&quot;J/m^3&quot;</span><span class="p">)))</span>
</pre></div>
</div>
<p>We load the mesh and set initial magnetisation pointing in +z direction
(that is, in a local minimum of anisotropy energy density).</p>
<p>Finally, we use <a class="reference internal" href="manual.html#hysteresis"><em>hysteresis</em></a> to apply gradually stronger fields in +x direction (up to 50 mT):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Hs</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">vector_set</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">],</span>
                     <span class="n">norm_list</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">19</span><span class="p">,</span> <span class="mf">19.1</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">50</span><span class="p">],</span>
                     <span class="n">units</span><span class="o">=</span><span class="mf">0.001</span><span class="o">*</span><span class="n">si</span><span class="o">.</span><span class="n">Tesla</span><span class="o">/</span><span class="n">si</span><span class="o">.</span><span class="n">mu0</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we sample more often the region between 19 and 21 mT where
magnetisation direction changes rapidly due to having crossed the anisotropy
energy &#8220;barrier&#8221; between +z and +x (as can be seen in the graph below).</p>
</div>
<div class="section" id="analyzing-the-result">
<span id="id2"></span><h4>Analyzing the result<a class="headerlink" href="manual.html#analyzing-the-result" title="Permalink to this headline">¶</a></h4>
<p>First, we extract the magnitude of the applied field and the x component of
magnetisation:</p>
<div class="highlight-python"><pre>ncol cube H_ext_0 M_Fe_0 &gt; cube_hext_vs_m.txt</pre>
</div>
<p>Then we compare the result with OOMMF&#8217;s result (generated from the
equivalent scene description <a class="reference download internal" href="_downloads/cube.mif"><tt class="xref download docutils literal"><span class="pre">oommf/cube.mif</span></tt></a>)
using the following <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> script:</p>
<div class="highlight-python"><pre>set term png giant size 800,600
set out 'cube_hext_vs_m.png'
set xlabel 'H_ext.x (A/m)'
set ylabel 'M.x (A/m)'
plot 'cube_hext_vs_m.txt' t 'nmag' w l 2,\
 'oommf/cube_hext_vs_m.txt' u ($1*795.77471545947674):2 ti 'oommf' w p 1
</pre>
</div>
<p>which gives the following result:</p>
<img alt="_images/cube_hext_vs_m.png" class="align-center" src="_images/cube_hext_vs_m.png" style="width: 800px; height: 600px;" />
<p>Nmag provides advanced capabilities to conveniently handle
arbitrary-order anisotropy energy functions. Details can be found in
the documentation of the <a class="reference internal" href="manual.html#magmaterial"><em>MagMaterial</em></a> class.</p>
</div>
</div>
<span id="document-example_user_anis/doc"></span><div class="section" id="example-arbitrary-anisotropy">
<h3>Example: Arbitrary Anisotropy<a class="headerlink" href="manual.html#example-arbitrary-anisotropy" title="Permalink to this headline">¶</a></h3>
<p>In this example we discuss
the script <a class="reference download internal" href="_downloads/coin.py"><tt class="xref download docutils literal"><span class="pre">coin.py</span></tt></a>
which shows how the user can include in his simulations
a customised magnetic anisotropy.</p>
<div class="section" id="arbitrary-anisotropy-simulation-script">
<span id="id1"></span><h4>Arbitrary anisotropy simulation script<a class="headerlink" href="manual.html#arbitrary-anisotropy-simulation-script" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">every</span><span class="p">,</span> <span class="n">at</span>
<span class="kn">from</span> <span class="nn">nsim.si_units</span> <span class="kn">import</span> <span class="n">si</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c"># Create simulation object (no demag field!)</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">do_demag</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c"># Function to compute the scalar product of the vectors a and b</span>
<span class="k">def</span> <span class="nf">scalar_product</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="c"># Here we define a function which returns the energy for a uniaxial</span>
<span class="c"># anisotropy of order 4.</span>
<span class="n">K1</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">43e3</span><span class="p">,</span> <span class="s">&quot;J/m^3&quot;</span><span class="p">)</span>
<span class="n">K2</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">21e3</span><span class="p">,</span> <span class="s">&quot;J/m^3&quot;</span><span class="p">)</span>
<span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>        <span class="c"># The (normalised) axis</span>
<span class="k">def</span> <span class="nf">my_anisotropy</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">scalar_product</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">K1</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">K2</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">4</span>

<span class="n">my_material</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;MyMat&quot;</span><span class="p">,</span>
                               <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e6</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                               <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">10e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                               <span class="n">anisotropy</span><span class="o">=</span><span class="n">my_anisotropy</span><span class="p">,</span>
                               <span class="n">anisotropy_order</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

<span class="c"># Load the mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;coin.nmesh.h5&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;coin&quot;</span><span class="p">,</span> <span class="n">my_material</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">))</span>

<span class="c"># Set the magnetization</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="c"># Compute the hysteresis loop</span>
<span class="n">Hs</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">vector_set</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">],</span>
                     <span class="n">norm_list</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.35</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.005</span><span class="p">,</span> <span class="p">[],</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="p">[],</span> <span class="mf">0.4</span><span class="p">],</span>
                     <span class="n">units</span><span class="o">=</span><span class="n">si</span><span class="o">.</span><span class="n">Tesla</span><span class="o">/</span><span class="n">si</span><span class="o">.</span><span class="n">mu0</span><span class="p">)</span>

<span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>
</pre></div>
</div>
<p>We simulate the hysteresis loop for a ferromagnetic thin disc,
where the field is applied orthogonal to the axis of disc.
This script includes one main element of novelty, which concerns the way
the magnetic anisotropy is specified.
In previous examples we found lines such as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">my_material</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;MyMat&quot;</span><span class="p">,</span>
                               <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e6</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                               <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">10e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                               <span class="n">anisotropy</span><span class="o">=</span><span class="n">nmag</span><span class="o">.</span><span class="n">uniaxial_anisotropy</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                                                   <span class="n">K1</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">43e3</span><span class="p">,</span> <span class="s">&quot;J/m^3&quot;</span><span class="p">),</span>
                                                                   <span class="n">K2</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">21e3</span><span class="p">,</span> <span class="s">&quot;J/m^3&quot;</span><span class="p">)))</span>
</pre></div>
</div>
<p>where the material anisotropy was specified using the provided functions
<tt class="docutils literal"><span class="pre">nmag.uniaxial_anisotropy</span></tt> (<a class="reference internal" href="manual.html#uniaxial-anisotropy"><em>uniaxial_anisotropy</em></a>) and <tt class="docutils literal"><span class="pre">nmag.cubic_anisotropy</span></tt> (<a class="reference internal" href="manual.html#cubic-anisotropy"><em>cubic_anisotropy</em></a>).
In this example we are using a different approach to define the anisotropy.
First we define the function <tt class="docutils literal"><span class="pre">my_anisotropy</span></tt>, which returns the energy density
for the magnetic anisotropy:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Here we define a function which returns the energy for a uniaxial</span>
<span class="c"># anisotropy of order 4.</span>
<span class="n">K1</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">43e3</span><span class="p">,</span> <span class="s">&quot;J/m^3&quot;</span><span class="p">)</span>
<span class="n">K2</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">21e3</span><span class="p">,</span> <span class="s">&quot;J/m^3&quot;</span><span class="p">)</span>
<span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>        <span class="c"># The (normalised) axis</span>
<span class="k">def</span> <span class="nf">my_anisotropy</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">scalar_product</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">K1</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">K2</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">4</span>
</pre></div>
</div>
<p>Note that the function returns a SI object with units &#8220;J/m^3&#8221; (energy density).
The reader may have recognised the familiar expression for the uniaxial anisotropy:
in fact the two code snippets we just presented are defining exactly the same
anisotropy, they are just doing it in different ways.
The function <tt class="docutils literal"><span class="pre">scalar_product</span></tt>, which we have used in the second code snippet
just returns the scalar product of two three dimensional vectors <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt>
and is defined in the line above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">scalar_product</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>The function <tt class="docutils literal"><span class="pre">my_anisotropy</span></tt> has to be specified in the material definition:
instead of passing <tt class="docutils literal"><span class="pre">anisotropy=nmag.uniaxial_anisotropy(...)</span></tt>
we just pass <tt class="docutils literal"><span class="pre">anisotropy=my_anisotropy</span></tt> to the material constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">my_material</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;MyMat&quot;</span><span class="p">,</span>
                               <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e6</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                               <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">10e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                               <span class="n">anisotropy</span><span class="o">=</span><span class="n">my_anisotropy</span><span class="p">,</span>
                               <span class="n">anisotropy_order</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>An important point to notice is that here we also provide an anisotropy order.
To understand what this number is, we have to explain briefly what is going on
behind the scenes. nsim calculates the values of the user provided function
for an appropriately chosen set of normalised vectors,
it then finds the polynomial in <tt class="docutils literal"><span class="pre">mx</span></tt>, <tt class="docutils literal"><span class="pre">my</span></tt> and <tt class="docutils literal"><span class="pre">mz</span></tt>
(the components of the normalised magnetisation) of the specified order,
which matches the sampled values.</p>
<p>The strength of this approach stands in the fact that the user has to provide
just the energy density for the custom anisotropy.
nsim is taking care of working out the other quantities which
are needed for the simulation, such as the magnetic field resulting
from the provided anisotropy energy, which would require a differentiation
of the energy with respect to the normalised magnetisation.</p>
<p>However the user must be sure that the provided function can be expressed
by a polynomial of the specified order in <tt class="docutils literal"><span class="pre">mx</span></tt>, <tt class="docutils literal"><span class="pre">my</span></tt> and <tt class="docutils literal"><span class="pre">mz</span></tt>.
In the present case we are specifying <tt class="docutils literal"><span class="pre">anisotropy_order=4</span></tt> because the energy
for the uniaxial anisotropy can be expressed as a 4th-order polynomial
in <tt class="docutils literal"><span class="pre">mx</span></tt>, <tt class="docutils literal"><span class="pre">my</span></tt> and <tt class="docutils literal"><span class="pre">mz</span></tt>.</p>
<p>In some cases the user may find useful to know that the functions
<tt class="docutils literal"><span class="pre">nmag.uniaxial_anisotropy</span></tt> and <tt class="docutils literal"><span class="pre">nmag.cubic_anisotropy</span></tt>
can be added: the resulting anisotropy will have as energy
the sum of the energies of the original anisotropies.</p>
</div>
<div class="section" id="the-result">
<span id="id2"></span><h4>The result<a class="headerlink" href="manual.html#the-result" title="Permalink to this headline">¶</a></h4>
<p>The steps involved to extract and plot the data for the simulation discussed
in the previous section should be familiar to the user at this point of the manual.
We then just show the graph obtained from the results
of the script <a class="reference download internal" href="_downloads/coin.py"><tt class="xref download docutils literal"><span class="pre">coin.py</span></tt></a>.</p>
<img alt="_images/coin.png" class="align-center" src="_images/coin.png" style="width: 730px; height: 500px;" />
<p>During the switching the system falls into an intermediate state,
where the magnetisation is nearly aligned with the anisotropy easy axis.</p>
</div>
</div>
<span id="document-example_restart/doc"></span><div class="section" id="restart-example">
<span id="id1"></span><h3>Restart example<a class="headerlink" href="manual.html#restart-example" title="Permalink to this headline">¶</a></h3>
<p>Micromagnetic simulations can last for many hours or even many days.
It is then important to be able to save periodically the state
of the simulation, in such a way that, if a hardware failure
or a power cut occurs, the simulation can be restarted
exactly at the point where its state was last saved.
In this example we show how an nmag script can be modified
to be &#8220;restartable&#8221;. The only thing the user needs to do
is to periodically save the state of the simulation in what we call
a &#8220;restart file&#8221;. The simulation can then be restarted
using the appropriate command line option.</p>
<p>The restart feature applies only to the <a class="reference internal" href="manual.html#hysteresis"><em>hysteresis</em></a> method.</p>
<div class="section" id="saving-the-state-of-the-simulation">
<span id="id2"></span><h4>Saving the state of the simulation<a class="headerlink" href="manual.html#saving-the-state-of-the-simulation" title="Permalink to this headline">¶</a></h4>
<p>We re-consider the cubic anisotropy example
(<a class="reference internal" href="manual.html#cubic-anisotropy-simulation-script"><em>Cubic anisotropy simulation script</em></a>)
and replace the last line:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="n">Hs</span><span class="p">)</span>
</pre></div>
</div>
<p>with the following lines:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">every</span><span class="p">,</span> <span class="n">at</span>
<span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;stage_end&#39;</span><span class="p">)),</span>
                         <span class="p">(</span><span class="s">&#39;restart&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;stage_end&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))])</span>
</pre></div>
</div>
<p>The first two lines reproduce the default behaviour:
the fields and their averages are saved at the end of each stage.
The third line specifies that the restart file should be saved
at the end of each stage and also every 1000 steps.</p>
<p>For convenience the modified script <a class="reference download internal" href="_downloads/cube_restartable.py"><tt class="xref download docutils literal"><span class="pre">cube_restartable.py</span></tt></a> is shown below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">si</span>

<span class="c"># Create the simulation object</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>

<span class="c"># Define the magnetic material (data from OOMMF materials file)</span>
<span class="n">Fe</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Fe&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1700e3</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">21e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                      <span class="n">anisotropy</span><span class="o">=</span><span class="n">nmag</span><span class="o">.</span><span class="n">cubic_anisotropy</span><span class="p">(</span><span class="n">axis1</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                       <span class="n">axis2</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                       <span class="n">K1</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">48e3</span><span class="p">,</span> <span class="s">&quot;J/m^3&quot;</span><span class="p">)))</span>

<span class="c"># Load the mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;cube.nmesh&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;cube&quot;</span><span class="p">,</span> <span class="n">Fe</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">))</span>

<span class="c"># Set the initial magnetisation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="c"># Launch the hysteresis loop</span>
<span class="n">Hs</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">vector_set</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">],</span>
                     <span class="n">norm_list</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">19</span><span class="p">,</span> <span class="mf">19.1</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">50</span><span class="p">],</span>
                     <span class="n">units</span><span class="o">=</span><span class="mf">0.001</span><span class="o">*</span><span class="n">si</span><span class="o">.</span><span class="n">Tesla</span><span class="o">/</span><span class="n">si</span><span class="o">.</span><span class="n">mu0</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">every</span><span class="p">,</span> <span class="n">at</span>
<span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;stage_end&#39;</span><span class="p">)),</span>
                         <span class="p">(</span><span class="s">&#39;restart&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;stage_end&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))])</span>
</pre></div>
</div>
</div>
<div class="section" id="starting-and-restarting-the-simulation">
<span id="id3"></span><h4>Starting and restarting the simulation<a class="headerlink" href="manual.html#starting-and-restarting-the-simulation" title="Permalink to this headline">¶</a></h4>
<p>We will now demonstrate how the discussed nmag script can be
restarted. To do that, we will have to interrupt it artificially. We
start the simulation in the usual way:</p>
<div class="highlight-python"><pre>$ nsim cube_restartable.py</pre>
</div>
<p>We interrupt the execution after the hysteresis loop has started and
several stages have been computed. Do this by pressing simultaneously
the keys CTRL and C (in the same terminal window where nsim was
started), thus simulating what could have been the result of a power
cut.  We then use the command:</p>
<div class="highlight-python"><pre>$ ncol cube_restartable stage step time</pre>
</div>
<p>to see at what point of the hysteresis loop the simulation was interrupted.
We obtain (for this particular interruption):</p>
<div class="highlight-python"><pre> 1            330  3.320127110062e-11
 2            480  5.042492488627e-10
 3            640  9.926580643272e-10
 4            805  1.464971830453e-09
 5            980  1.927649646634e-09
 6           1150  2.406521613682e-09
 7           1340  2.882400372552e-09
 8           1515  3.371522550051e-09
 9           1705  3.863380029345e-09
10           1920  4.365560120394e-09
11           2095  4.893234441813e-09
12           2295  5.436617525896e-09
13           2480  5.997866344586e-09
14           2680  6.570733097131e-09
15           2890  7.172534305054e-09
16           3100  7.803577637245e-09
17           3315  8.462827284047e-09</pre>
</div>
<p>The simulation was interrupted at the seventeenth stage.
We now try to run the simulation again with the command:</p>
<div class="highlight-python"><pre>$ nsim cube_restartable.py</pre>
</div>
<p>obtaining the following output:</p>
<div class="highlight-python"><pre>&lt;snip&gt;
NmagUserError: Error: Found old file ./cube_restartable_dat.ndt -- cannot proceed.
To start a simulation script with old data files present you either need
to use '--clean' (and then the old files will be deleted), or use '--restart'
in which case the run will be continued.</pre>
</div>
<p>nsim suggests the possible alternatives. We can start the simulation from scratch with the command (but this will override any data from the previous run):</p>
<div class="highlight-python"><pre>$ nsim cube_restartable.py --clean</pre>
</div>
<p>or we can continue from the configuration which was last saved:</p>
<div class="highlight-python"><pre>$ nsim cube_restartable.py --restart</pre>
</div>
<p>Here we choose the second possibility.
After the simulation has finished we issue again
the command <tt class="docutils literal"><span class="pre">ncol</span> <span class="pre">cube_restartable</span> <span class="pre">stage</span> <span class="pre">step</span> <span class="pre">time</span></tt>, obtaining
the following output:</p>
<div class="highlight-python"><pre>    1            330  3.320127110062e-11
    2            480  5.042492488627e-10
    3            640  9.926580643272e-10
    4            805  1.464971830453e-09
    5            980  1.927649646634e-09
    6           1150  2.406521613682e-09
    7           1340  2.882400372552e-09
    8           1515  3.371522550051e-09
    9           1705  3.863380029345e-09
   10           1920  4.365560120394e-09
   11           2095  4.893234441813e-09
   12           2295  5.436617525896e-09
   13           2480  5.997866344586e-09
   14           2680  6.570733097131e-09
   15           2890  7.172534305054e-09
   16           3100  7.803577637245e-09
   17           3315  8.462827284047e-09
stage           step          #time
   &lt;&gt;             &lt;&gt;           #&lt;s&gt;
   18           3715  8.519843629989e-09
   19           3975  9.300878866142e-09
   ...</pre>
</div>
<p>The two lines between stage 17 and 18 stand as a reminder that the
simulation was restarted at that point. (They need to be removed
manually from the <tt class="docutils literal"><span class="pre">cube_restartable_dat.ndt</span></tt> file, before <a class="reference internal" href="manual.html#ncol"><em>ncol</em></a> can
work in the usual way on the ndt file.)</p>
</div>
</div>
<span id="document-example_changing_space_time_field/doc"></span><div class="section" id="applying-a-field-that-changes-both-in-time-and-in-space">
<h3>Applying a field that changes both in time and in space<a class="headerlink" href="manual.html#applying-a-field-that-changes-both-in-time-and-in-space" title="Permalink to this headline">¶</a></h3>
<div class="section" id="idea-pass-simulation-object-to-field-setting-function">
<h4>Idea: pass simulation object to field-setting function<a class="headerlink" href="manual.html#idea-pass-simulation-object-to-field-setting-function" title="Permalink to this headline">¶</a></h4>
<p>You can simulate an applied field which both changes in space and
time: this may be useful to mimic the effect of a write head on the
magnetic grains of an hard disk while the head is moving.  The way we
do this is by changing the applied field every <tt class="docutils literal"><span class="pre">delta_t</span></tt>
picoseconds. This means that the applied field won&#8217;t change
continuously in time: it will be piecewise constant in time (but, in
general, it can be non uniform in space).  You can do something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">set_H</span><span class="p">(</span><span class="n">sim</span><span class="p">):</span>
  <span class="n">width</span> <span class="o">=</span> <span class="mf">10.0</span>        <span class="c"># nm</span>
  <span class="n">v</span> <span class="o">=</span> <span class="mf">100.0</span>           <span class="c"># nm/ns == m/s</span>
  <span class="n">H_amplitude</span> <span class="o">=</span> <span class="mf">0.5e6</span> <span class="c"># A/m</span>

  <span class="n">t</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">time</span><span class="o">/</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">))</span> <span class="c"># get the time in ns</span>
  <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c"># center of the applied field region</span>
  <span class="k">def</span> <span class="nf">H</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">ri</span><span class="o">/</span><span class="mf">1e-9</span> <span class="o">-</span> <span class="n">ci</span> <span class="k">for</span> <span class="n">ri</span><span class="p">,</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">center</span><span class="p">)]</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">H_amplitude</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">width</span><span class="o">*</span><span class="n">width</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">factor</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">factor</span><span class="p">]</span>

  <span class="n">sim</span><span class="o">.</span><span class="n">set_H_ext</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="s">&#39;A/m&#39;</span><span class="p">))</span>

<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">do</span><span class="o">=</span><span class="p">[(</span><span class="n">set_H</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">50e-12</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">))),</span>
              <span class="p">(</span><span class="s">&#39;exit&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1000e-12</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">)))])</span>
</pre></div>
</div>
<p>The function <tt class="docutils literal"><span class="pre">set_H</span></tt> is called every 50 ps and does the following: it
sets a new field from the function <tt class="docutils literal"><span class="pre">H(r)</span></tt>.  This function sets a field
which directed along the direction [1, 1, 1] and almost vanishes
outside a sphere with radius ~ 30.0 nm.  The center of this sphere
moves along the direction [1, 0, 0] with velocity 100 nm/ns, thus
simulating the motion of a write head in a hard disk.  Obviously the
piece of code is not complete, it shows only the technique in order to
have a field changing in time and space.  For a complete example see
the next section.</p>
</div>
<div class="section" id="complete-example-simple-moving-write-head-example">
<h4>Complete example: simple moving write-head example<a class="headerlink" href="manual.html#complete-example-simple-moving-write-head-example" title="Permalink to this headline">¶</a></h4>
<p>Here is a simulation of five cubes made of cobalt and a write-head
which moves on the top of the cubes and applies a time-varying field
in order to change their magnetisation. At the beginning the
magnetisation of all the cubes is pointing in the [0, 0, 1]
direction. After the write-head has passed over the cubes, the
magnetisation of cube 1, 3 and 5 are switched in the opposite
direction, while cube 2 and 4 have unchanged magnetisation.  This is
possible because the write-head field, which is space-dependent (being
intense only inside a sphere of radius 15-20 nm), changes also in
time. It indeed translates in space, but also change in intensity,
being directed in the [0, 0, -1] direction when the sphere is at the
center of cube 1, 3 and 5 and in the [0, 0, 1] direction when the
center of the sphere is in cube 2 and 4.</p>
<p>Here is the geo file used to generate the mesh (Netgen):</p>
<div class="highlight-python"><pre>&lt;pre&gt;
algebraic3d

# cubes
solid cube1 = orthobrick (    0, 0, 0;  20.0, 20.0, 20.0) -maxh = 2;
solid cube2 = orthobrick ( 30.0, 0, 0;  50.0, 20.0, 20.0) -maxh = 2;
solid cube3 = orthobrick ( 60.0, 0, 0;  80.0, 20.0, 20.0) -maxh = 2;
solid cube4 = orthobrick ( 90.0, 0, 0; 110.0, 20.0, 20.0) -maxh = 2;
solid cube5 = orthobrick (120.0, 0, 0; 140.0, 20.0, 20.0) -maxh = 2;

tlo cube1;
tlo cube2;
tlo cube3;
tlo cube4;
tlo cube5;</pre>
</div>
<p>And here is the full listing of the example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">nmag.common</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c"># Define magnetic material (data from OOMMF materials file)</span>
<span class="n">mat_Co</span> <span class="o">=</span> <span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Co&quot;</span><span class="p">,</span>
                     <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1400e3</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                     <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">30e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                     <span class="n">anisotropy</span><span class="o">=</span><span class="n">uniaxial_anisotropy</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                                    <span class="n">K1</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">520e3</span><span class="p">,</span> <span class="s">&quot;J/m^3&quot;</span><span class="p">)))</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">()</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;cubes.nmesh.h5&quot;</span><span class="p">,</span>
              <span class="p">[(</span><span class="s">&#39;cube1&#39;</span><span class="p">,</span> <span class="n">mat_Co</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;cube2&#39;</span><span class="p">,</span> <span class="n">mat_Co</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;cube3&#39;</span><span class="p">,</span> <span class="n">mat_Co</span><span class="p">),</span>
               <span class="p">(</span><span class="s">&#39;cube4&#39;</span><span class="p">,</span> <span class="n">mat_Co</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;cube5&#39;</span><span class="p">,</span> <span class="n">mat_Co</span><span class="p">)],</span>
              <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&#39;m&#39;</span><span class="p">))</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>

<span class="n">t0</span> <span class="o">=</span> <span class="p">[</span><span class="n">sim</span><span class="o">.</span><span class="n">time</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">set_H</span><span class="p">(</span><span class="n">sim</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">float</span><span class="p">((</span><span class="n">sim</span><span class="o">.</span><span class="n">time</span> <span class="o">-</span> <span class="n">t0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">))</span>  <span class="c"># get time in ns</span>
    <span class="n">width</span> <span class="o">=</span> <span class="mf">10.0</span>                                 <span class="c"># nm</span>
    <span class="n">v</span> <span class="o">=</span> <span class="mf">25.0</span>                                     <span class="c"># nm/ns = m/s</span>
    <span class="n">H_amplitude</span> <span class="o">=</span> <span class="mf">4.0e6</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>      <span class="c"># A/m</span>
    <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;CENTER IN&quot;</span><span class="p">,</span> <span class="n">center</span>
    <span class="k">def</span> <span class="nf">H</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">ri</span><span class="o">/</span><span class="mf">1e-9</span> <span class="o">-</span> <span class="n">ci</span> <span class="k">for</span> <span class="n">ri</span><span class="p">,</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">center</span><span class="p">)]</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">H_amplitude</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">width</span><span class="o">*</span><span class="n">width</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">factor</span><span class="p">]</span>

    <span class="n">sim</span><span class="o">.</span><span class="n">set_H_ext</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="s">&#39;A/m&#39;</span><span class="p">))</span>

<span class="n">set_H</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="n">stopping_dm_dt</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">degrees_per_ns</span><span class="p">)</span>

<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">200e-12</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">),</span> <span class="n">first</span><span class="o">=</span><span class="n">t0</span><span class="p">[</span><span class="mi">0</span><span class="p">]))],</span>
          <span class="n">do</span><span class="o">=</span><span class="p">[(</span><span class="n">set_H</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">50e-12</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">),</span> <span class="n">first</span><span class="o">=</span><span class="n">t0</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
              <span class="p">(</span><span class="s">&#39;exit&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">6000e-12</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">)))])</span>
</pre></div>
</div>
<p>Here is the magnetisation at the beginning of the simulation, after
the first relax command (whose purpose is just to find the zero field
magnetisation configuration):</p>
<img alt="_images/before.png" class="align-center" src="_images/before.png" style="width: 600px; height: 542px;" />
<p>and here is the magnetisation after the write-head has passed over the
cubes:</p>
<img alt="_images/after.png" class="align-center" src="_images/after.png" style="width: 600px; height: 542px;" />
</div>
</div>
<span id="document-example_two_materials/doc"></span><div class="section" id="example-two-different-magnetic-materials">
<span id="id1"></span><h3>Example: two different magnetic materials<a class="headerlink" href="manual.html#example-two-different-magnetic-materials" title="Permalink to this headline">¶</a></h3>
<p>In this example, we study the dynamics of a simple system consisting
of two 15 nm x 15 nm x 15 nm cubes close to one another (with 2 nm
spacing along the x-axis). We take the right cube to be made of
PermAlloy and the left cube to be made of Cobalt, with the magnetic
anisotropy axis pointing in z-direction. The mesh has been generated
with <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> from the geometry file <a class="reference download internal" href="_downloads/two_cubes.geo"><tt class="xref download docutils literal"><span class="pre">two_cubes.geo</span></tt></a>.</p>
<img alt="_images/cubes.png" class="align-center" src="_images/cubes.png" style="width: 568px; height: 468px;" />
<p>We use the <a class="reference download internal" href="_downloads/two_cubes.py"><tt class="xref download docutils literal"><span class="pre">two_cubes.py</span></tt></a> script to carry out the simulation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">every</span><span class="p">,</span> <span class="n">at</span>

<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>

<span class="c"># define magnetic material Cobalt (data from OOMMF materials file)</span>
<span class="n">Co</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Co&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1400e3</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">30e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                      <span class="n">anisotropy</span><span class="o">=</span><span class="n">nmag</span><span class="o">.</span><span class="n">uniaxial_anisotropy</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">K1</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">520e3</span><span class="p">,</span> <span class="s">&quot;J/m^3&quot;</span><span class="p">)))</span>

<span class="c"># define magnetic material Permalley</span>
<span class="n">Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">860e3</span><span class="p">,</span><span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">))</span>

<span class="c"># load mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;two_cubes.nmesh.h5&quot;</span><span class="p">,</span>
              <span class="p">[(</span><span class="s">&quot;cube1&quot;</span><span class="p">,</span> <span class="n">Py</span><span class="p">),(</span><span class="s">&quot;cube2&quot;</span><span class="p">,</span> <span class="n">Co</span><span class="p">)],</span>
              <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">)</span>
              <span class="p">)</span> 

<span class="c"># set initial magnetisation along the </span>
<span class="c"># positive x axis for both cubes, slightly off in z-direction</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mf">0.999847695156</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.01745240643731</span><span class="p">])</span>

<span class="n">ns</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&quot;s&quot;</span><span class="p">)</span> <span class="c"># corresponds to one nanosecond</span>

<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mf">0.01</span><span class="o">*</span><span class="n">ns</span><span class="p">)),</span>
                  <span class="p">(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">ns</span><span class="p">)</span> <span class="o">|</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>
</pre></div>
</div>
<p>The script is very similar to the one used in <a class="reference internal" href="manual.html#example-2"><em>Example 2: Computing the time development of a system</em></a>. However,
here we have two materials. The related changes are that we define two
magnetic materials, and assign them to objects <tt class="docutils literal"><span class="pre">Co</span></tt> and <tt class="docutils literal"><span class="pre">Py</span></tt>.</p>
<p>When loading the mesh:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;two_cubes.nmesh.h5&quot;</span><span class="p">,</span>
              <span class="p">[(</span><span class="s">&quot;cube1&quot;</span><span class="p">,</span> <span class="n">Py</span><span class="p">),(</span><span class="s">&quot;cube2&quot;</span><span class="p">,</span> <span class="n">Co</span><span class="p">)],</span>
              <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">)</span>
              <span class="p">)</span>
</pre></div>
</div>
<p>we need to assign regions 1 and 2 in the mesh file (which correspond
to the two cubes) to the materials. This is done with this list of tuples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[(</span><span class="s">&quot;cube1&quot;</span><span class="p">,</span> <span class="n">Py</span><span class="p">),(</span><span class="s">&quot;cube2&quot;</span><span class="p">,</span> <span class="n">Co</span><span class="p">)]</span>
</pre></div>
</div>
<p>The first list entry is <tt class="docutils literal"><span class="pre">(&quot;cube1&quot;,</span> <span class="pre">Py)</span></tt> and tells nmag that we would
like to refer to the region 1 as <tt class="docutils literal"><span class="pre">cube1</span></tt>, and that we would like to
assign the material <tt class="docutils literal"><span class="pre">Py</span></tt> to this region. This entry refers to region
1 because it is the <em>first</em> entry in the list.</p>
<p>The second list entry is <tt class="docutils literal"><span class="pre">(&quot;cube2&quot;,</span> <span class="pre">Co)</span></tt> and tells nmag that we
would like to refer to the region 2 as <tt class="docutils literal"><span class="pre">cube2</span></tt>, and that we would
like to assign the material <tt class="docutils literal"><span class="pre">Co</span></tt> to this region.</p>
<p>If there was a region 3 in the mesh file, we would add a third list
entry, for example (&#8220;cylinder&#8221;,Co) for a Co cylinder.</p>
<p>Note that at this stage of nmag, the region name (such as <tt class="docutils literal"><span class="pre">cube1</span></tt>,
<tt class="docutils literal"><span class="pre">cube2</span></tt>, etc) are not used in the simulation, apart from diagnostic
purposes in progress messages.</p>
<p>Physically, what happens in this system is that the magnetisation of
the Cobalt cube aligns rather fast with the anisotropy direction and
then slowly forces the magnetisation of the PermAlloy cube into the
opposite direction (through the action of the stray field) to minimise
total energy of the configuration.</p>
<p>The Initial magnetisation is taken to point in x-direction. As this is an
unstable equilibrium direction for the magnetisation anisotropy of the
Cobalt cube, we slightly distort the initial magnetisation by adding a
tiny component in +z-direction.</p>
<p>It is instructive to compare the <a class="reference internal" href="manual.html#field"><em>Field</em></a>s and <a class="reference internal" href="manual.html#subfield"><em>Subfield</em></a>s for this
particular example with the list of fields and subfields for a
single-material simulation. In effect, all the fields that are related
to the properties of some particular magnetic component carry multiple
subfields. In particular, there is only one <tt class="docutils literal"><span class="pre">H_ext</span></tt> field, as the
externally applied field is experienced in the same way by all
materials, but the <tt class="docutils literal"><span class="pre">M*H</span></tt> energy density associated with <tt class="docutils literal"><span class="pre">H_ext</span></tt>
has a dependency on the magnetic component (through <tt class="docutils literal"><span class="pre">M</span></tt>), so we have
two subfields <tt class="docutils literal"><span class="pre">E_ext_Py</span></tt> and <tt class="docutils literal"><span class="pre">E_ext_Co</span></tt> in the field <tt class="docutils literal"><span class="pre">E_ext</span></tt>.</p>
<p>The situation is virtually identical with <tt class="docutils literal"><span class="pre">H_demag</span></tt>/<tt class="docutils literal"><span class="pre">E_demag</span></tt> and
the related charge density <tt class="docutils literal"><span class="pre">rho</span></tt> and magnetic scalar potential
<tt class="docutils literal"><span class="pre">phi</span></tt>. All the other relevant fields in this example turn out to be
related to a particular magnetic component.</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="28%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Field</th>
<th class="head">Subfield(s)</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>m</td>
<td>m_Py, m_Co</td>
<td>normalised magnetisation</td>
</tr>
<tr><td>M</td>
<td>M_Py, M_Co</td>
<td>magnetisation</td>
</tr>
<tr><td>H_total</td>
<td>H_total_Py, H_total_Co</td>
<td>total effective field</td>
</tr>
<tr><td>H_ext</td>
<td>H_ext</td>
<td>external (applied) field (only one)</td>
</tr>
<tr><td>E_ext</td>
<td>E_ext_Py, E_ext_Co</td>
<td>energy density of Py due to external field</td>
</tr>
<tr><td>H_anis</td>
<td>H_anis_Py, H_anis_Co</td>
<td>crystal anisotropy field</td>
</tr>
<tr><td>E_anis</td>
<td>E_anis_Py, E_anis_Co</td>
<td>crystal anisotropy energy density</td>
</tr>
<tr><td>H_exch</td>
<td>H_exch_Py, H_exch_Co</td>
<td>exchange field</td>
</tr>
<tr><td>E_exch</td>
<td>E_exch_Py, E_exch_Co</td>
<td>exchange energy</td>
</tr>
<tr><td>H_demag</td>
<td>H_demag</td>
<td>demagnetisation field (only one)</td>
</tr>
<tr><td>E_demag</td>
<td>E_demag_Py, E_demag_Co</td>
<td>demagnetisation field energy density</td>
</tr>
<tr><td>phi</td>
<td>phi</td>
<td>scalar potential for H_demag</td>
</tr>
<tr><td>rho</td>
<td>rho</td>
<td>magnetic charge density (div M)</td>
</tr>
<tr><td>H_total</td>
<td>H_total_Py, H_total_Co</td>
<td>total effective field</td>
</tr>
</tbody>
</table>
<p>The issue of multiple magnetic components becomes much more
interesting when we study multi-component alloys, i.e. if we associate
more than one type of magnetisation to a single region in the
mesh. Usually, we will then also have to introduce some &#8220;generalized
anisotropy energy&#8221; term of the form <tt class="docutils literal"><span class="pre">E=c*M_a*M_b</span></tt> that depends on
more than a single magnetisation subfield (see <a class="reference internal" href="manual.html#more-than-one-magnetic-material-exchange-coupled"><em>More than one magnetic material, exchange coupled</em></a>).</p>
<p>Once we have run the simulation using:</p>
<div class="highlight-python"><pre>nsim two_cubes.py</pre>
</div>
<p>we can analyse the results. For example, we can plot the magnetisation
of the two materials against time:</p>
<img alt="_images/results.png" class="align-center" src="_images/results.png" style="width: 696px; height: 470px;" />
<p>The blue lines represent the (soft) permalloy and the black lines show
the (hard) cobalt. Each thick line denotes the z-component of the corresponding material.</p>
<p>This plot has been created with the following command:</p>
<div class="highlight-python"><pre>ncol two_cubes 0 m_Co_0 m_Co_1 m_Co_2 m_Py_0 m_Py_1 m_Py_2 | xmgrace -nxy -</pre>
</div>
<p>We can further convert the field data into vtk files:</p>
<div class="highlight-python"><pre>nmagpp --vtk=two_cubes.vtk two_cubes_dat.h5</pre>
</div>
<p>and visualise their content. We start with the initial configuration
(Permalloy in blue on the left, Cobalt in black on the right, only 10
percent of the actual magnetisation vectors on the mesh nodes are
shown to improve the readability of the plots):</p>
<p>Time T=0 ps:</p>
<img alt="_images/vis1.png" class="align-center" src="_images/vis1.png" style="width: 756px; height: 669px;" />
<p>Time T=1e-10s=0.1ns: Cobalt is already pointing up, i.e. in the
direction of the anisotropy axis, while Permalloy has just started to
rotate.</p>
<img alt="_images/vis2.png" class="align-center" src="_images/vis2.png" style="width: 756px; height: 669px;" />
<p>Time T=0.3ns: Cobalt has reached its final configuration (pointing up)
and Permalloy is still rotating, but already pointing down (to
minimise the interaction energy between the cubes to the
demagnetisation stray fields).</p>
<img alt="_images/vis3.png" class="align-center" src="_images/vis3.png" style="width: 756px; height: 669px;" />
<p>Time T=1 ns: The final configuration has been reached.</p>
<img alt="_images/vis4.png" class="align-center" src="_images/vis4.png" style="width: 756px; height: 669px;" />
</div>
<span id="document-example_larmor/doc"></span><div class="section" id="example-larmor-precession">
<h3>Example: Larmor precession<a class="headerlink" href="manual.html#example-larmor-precession" title="Permalink to this headline">¶</a></h3>
<p>This example shows how to derive the period of the Larmor precession
for the magnetisation and compare the result from simulation to the
analytical solution. It is inspired by an example from the <a class="reference external" href="http://www.magpar.net/">magpar</a>
documentation
(<a class="reference external" href="http://magnet.atp.tuwien.ac.at/scholz/magpar/doc/html/examples.html#sphere_larmor">http://magnet.atp.tuwien.ac.at/scholz/magpar/doc/html/examples.html#sphere_larmor</a>).</p>
<p>We us the <a class="reference download internal" href="_downloads/larmor.py"><tt class="xref download docutils literal"><span class="pre">larmor.py</span></tt></a> script:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">every</span><span class="p">,</span> <span class="n">at</span><span class="p">,</span> <span class="n">si</span>


<span class="c">#create simulation object and switch off</span>
<span class="c">#the computation of the demagnetising field</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">do_demag</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>

<span class="c"># define magnetic material so that Js = mu0*Ms = 1 T</span>
<span class="n">Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="n">si</span><span class="o">.</span><span class="n">Tesla</span><span class="o">/</span><span class="n">si</span><span class="o">.</span><span class="n">mu0</span><span class="p">,</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                      <span class="n">llg_damping</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
                      <span class="p">)</span>
<span class="c"># load mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;sphere1.nmesh.h5&quot;</span><span class="p">,</span>
              <span class="p">[(</span><span class="s">&quot;sphere&quot;</span><span class="p">,</span> <span class="n">Py</span><span class="p">)],</span>
              <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">)</span>
             <span class="p">)</span>

<span class="c"># set initial magnetisation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

<span class="c"># set external field</span>
<span class="n">Hs</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">vector_set</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],</span>
                     <span class="n">norm_list</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">],</span>
                     <span class="n">units</span><span class="o">=</span><span class="mf">1e6</span><span class="o">*</span><span class="n">SI</span><span class="p">(</span><span class="s">&#39;A/m&#39;</span><span class="p">)</span>
                    <span class="p">)</span>

<span class="n">ps</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-12</span><span class="p">,</span> <span class="s">&quot;s&quot;</span><span class="p">)</span>  <span class="c"># ps corresponds to one picosecond</span>

<span class="c"># let the magnetisation precess around the direction of the applied field</span>
<span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span>
               <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">ps</span><span class="p">))],</span>
               <span class="n">do</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;exit&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mi">300</span><span class="o">*</span><span class="n">ps</span><span class="p">))])</span>
</pre></div>
</div>
</div></blockquote>
<p>We turn off computation of the demagnetising field:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">do_demag</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>and set the damping term in the LLG equation to zero:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">llg_damping</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>We set saturation magnetisation to Js = 1 T (see <a class="reference internal" href="manual.html#library-of-useful-si-constants"><em>Library of useful si constants</em></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Ms</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="n">si</span><span class="o">.</span><span class="n">Tesla</span><span class="o">/</span><span class="n">si</span><span class="o">.</span><span class="n">mu0</span>
</pre></div>
</div>
<p>We use a sphere as the magnetic object and, starting from a uniform
magnetic configuration along the [1,1,1] direction:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>To compute the time development in the presence of a static field pointing in the z-direction, we &#8216;&#8217;abuse&#8217;&#8217; the hysteresis command (because this way we can conveniently save the data at equidistant time intervals). To do this, we need to find the sequence of applied fields (here it is only one, of course):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Hs</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">vector_set</span><span class="p">(</span> <span class="n">direction</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],</span>
                      <span class="n">norm_list</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">],</span>
                      <span class="n">units</span><span class="o">=</span><span class="mf">1e6</span><span class="o">*</span><span class="n">SI</span><span class="p">(</span><span class="s">&#39;A/m&#39;</span><span class="p">)</span>
                     <span class="p">)</span>
</pre></div>
</div>
<p>and then use the hysteresis command:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span>
               <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">ps</span><span class="p">))],</span>
               <span class="n">do</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;exit&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mi">300</span><span class="o">*</span><span class="n">ps</span><span class="p">))])</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="manual.html#hysteresis"><em>hysteresis</em></a> command will save the averages (which is what we need
to for the fit below) every 0.1 pico seconds. Once we reach the time
of 300 pico seconds, the method will exit.</p>
<p>The dynamics of the magnetisation is driven only by the
Zeeman effect, with a torque:</p>
<div class="math">
<p><img src="_images/math/1fc433fd895d1c064d3e076c668c3cc189d463dd.png" alt="{\mathbf T} = \mu_0 {\mathbf m} \times {\mathbf H}_{\rm ext}" /></p>
</div><p>acting on the magnetisation m which is orthogonal to both m and H;
thus causing the magnetisation to precess around the applied field
direction. The frequency of the precession, called f_Larmor, is given
by:</p>
<div class="math">
<p><img src="_images/math/6dc55b60c0614b76d334cde802c6d49f3c735ba4.png" alt="f_{\rm Larmor} = \frac{\gamma}{2\pi} \cdot \mu_0 \left|{\mathbf H}_{\rm ext}\right|" /></p>
</div><p>where the parameter gamma, called gyromagnetic ratio, is taken to
have the following value (see <a class="footnote-reference" href="manual.html#llggamma" id="id1">[1]</a> ):</p>
<div class="math">
<p><img src="_images/math/78434a947f21707feaafbb858f7d173048b02fa8.png" alt="\gamma = \frac{g \cdot e}{2m_e} \approx 1.7588 \times10^{11}\,{\rm T}^{-1}{\rm s}^{-1}" /></p>
</div><p>so that f_Larmor = 35.176 GHz and the period T = 1/f_Larmor =
0.0284284 ns.</p>
<p>We save the average magnetisation every 0.1 ps in order to have a
sufficient number of points to compute the period T.</p>
<p>We execute the script as usual:</p>
<div class="highlight-python"><pre>$ nsim larmor.py</pre>
</div>
<p>and extract the (spatially averaged) magnetisation data for all save time steps:</p>
<div class="highlight-python"><pre>$ ncol larmor time m_Py_0 m_Py_1 m_Py_2 &gt; data.txt</pre>
</div>
<p>Using <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a>, we extract the value of the Larmor period T from the x-component of the magnetisation:</p>
<div class="highlight-python"><pre>$ gnuplot</pre>
</div>
<p>and the following command plots the x component of the magnetisation
as a function of the simulation time, together with a fit for a
function <tt class="docutils literal"><span class="pre">f(x)</span></tt> (where <tt class="docutils literal"><span class="pre">x</span></tt> represents time):</p>
<div class="highlight-python"><pre>gnuplot&gt; f(x) = A*sin(2*pi*x/B + C) + D
gnuplot&gt; B = 30
gnuplot&gt; fit f(x) "data.txt" u  ($1/1e-12):2 via A,B,C,D
gnuplot&gt; plot "data.txt" u ($1/1e-12):2, f(x)</pre>
</div>
<p>The result is the following image:</p>
<img alt="_images/larmor_plot.png" class="align-center" src="_images/larmor_plot.png" style="width: 800px; height: 600px;" />
<p>The values for B in the fit, which corresponds to the unknown period
T, is initially set to 30 in order to help <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> fit the curve.
Such fit on T gives the value 28.4293; this value
corresponds to 0.0284293 ns when rescaled by the 10e12 factor used for
the plotting, and shows a difference starting from the 5th digit when
compared to the analytical solution of 0.0284284 ns.</p>
<table class="docutils footnote" frame="void" id="llggamma" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id1">[1]</a></td><td>See the OOMMF manual, and in Werner Scholz thesis, after (3.7), llg_gamma_G = 2.210173e5 m/(As).</td></tr>
</tbody>
</table>
</div>
<span id="document-example_1Dperiodicity/doc"></span><div class="section" id="example-1d-periodicity">
<h3>Example: 1D periodicity<a class="headerlink" href="manual.html#example-1d-periodicity" title="Permalink to this headline">¶</a></h3>
<div class="section" id="introduction-periodic-boundary-conditions-macro-geometry">
<span id="id1"></span><h4>Introduction periodic boundary conditions (&#8220;macro geometry&#8221;)<a class="headerlink" href="manual.html#introduction-periodic-boundary-conditions-macro-geometry" title="Permalink to this headline">¶</a></h4>
<p>Concerning the simulation of periodic magnetic structures, there are a
few somewhat subtle issues to be taken into account, both with respect
to the demagnetising and the exchange field.</p>
<p>The issue with the exchange field is that we may encounter situations
where the magnetic material crosses the boundary of an elementary
cell: a periodic array of non-touching spheres in a cubic lattice is
fundamentally different from its complement, a cubic lattice made of
spherical holes, insofar as that in the latter case, it is impossible
to do a simulation using periodic boundary conditions without
identifying degrees of freedom that live on boundaries of the
simulation cell. Nmag can deal with this automatically, provided the
mesh file contains periodicity information, i.e. data on how to
identify nodes on exterior faces.</p>
<p>As for the demagnetising field, the most important problem is that one
cannot ignore the effect of the faraway boundaries of the system: a
100 nm x 100 nm x 100 nm cell made of magnetic material in the center
of a large (three-dimensional) periodic array will experience very different demagnetising
fields depending on the shape of the outer boundaries of this array.
Assuming spatially constant magnetisation, if these cells form a
&#8220;macroscopic&#8221; (tree-dimensional) sphere, H_demag will be -1/3 M, while for a flat box,
H_demag may be very close to -M. Nmag takes these &#8220;macro-geometry&#8221;
effects into account by allowing the user to provide a geometrical
layout for a finite number (say, 100-1000) of cells that approximates
the shape of the faraway outer boundary of the system.</p>
<p>The macro geometry approach is described in <a class="footnote-reference" href="manual.html#fangohretal" id="id2">[1]</a> which may serve as a
more detailed instruction to the concept.</p>
<table class="docutils footnote" frame="void" id="fangohretal" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id2">[1]</a></td><td>Hans Fangohr, Giuliano Bordignon, Matteo Franchin, Andreas Knittel, Peter A. J. de Groot, Thomas Fischbacher. <em>A new approach to (quasi) periodic boundary conditions in micromagnetics: the macro geometry</em>, Journal of Applied Physics <strong>105</strong>, 07D529 (2009), Online at <a class="reference external" href="http://link.aip.org/link/?JAP/105/07D529">http://link.aip.org/link/?JAP/105/07D529</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="d-example">
<span id="id3"></span><h4>1d example<a class="headerlink" href="manual.html#d-example" title="Permalink to this headline">¶</a></h4>
<p>In this example, we simulate a single cell in the middle of a long
one-dimensional periodic array where for the purpose of computing the
demagnetising field, we take three extra copies of this cell to the
left and three copies to the right along the x axis. (For real
applications, one would use more copies. The only effect of additional
copies are to increase the setup time needed to compute an internal
boundary/boundary interaction matrix.)</p>
<p>The next <a class="reference internal" href="manual.html#example-2d-periodicity"><em>Example: 2D periodicity</em></a> demonstrates the macro geometry
concept for a thin film. This is followed by the <a class="reference internal" href="manual.html#spin-waves-example"><em>Spin-waves example</em></a>
which includes exchange coupling between periodic copies (and is of
more practical value).</p>
<p>The mesh of the central simulation cell used is described in <a class="reference download internal" href="_downloads/cube.geo"><tt class="xref download docutils literal"><span class="pre">cube.geo</span></tt></a> which reads:</p>
<div class="highlight-python"><pre>algebraic3d

# prism
solid prism = orthobrick (-7.50, -7.50, -7.50; 7.50, 7.50, 7.50) -maxh = 1.8000;
tlo prism;

</pre>
</div>
<p>Note that the mesh is centered around the origin. This is recommended for periodic simulations. (We need to document this better.) The resulting mesh is this (the periodic copies are not shown):</p>
<div class="figure align-center">
<img alt="_images/mesh.png" src="_images/mesh.png" />
</div>
<p>The script <a class="reference download internal" href="_downloads/periodic1.py"><tt class="xref download docutils literal"><span class="pre">periodic1.py</span></tt></a> reads:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span>

<span class="c"># define magnetic material</span>
<span class="n">Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e6</span><span class="p">,</span><span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">)</span>
                      <span class="p">)</span>

<span class="c"># size of simulation cell, plus extra spacing</span>
<span class="c"># to avoid exchange interaction across interfaces</span>
<span class="c"># between repeated copies of the simulation cell.</span>
<span class="n">x_lattice</span> <span class="o">=</span> <span class="mf">15.01</span>  <span class="c"># the spacing is 0.01</span>
<span class="n">y_lattice</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">z_lattice</span> <span class="o">=</span> <span class="mf">0.0</span>


<span class="c"># list to store the lattice points where the periodic</span>
<span class="c"># copies will be placed </span>
<span class="n">lattice_points</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">lattice_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xi</span><span class="o">*</span><span class="n">x_lattice</span><span class="p">,</span><span class="mf">0.0</span><span class="o">*</span><span class="n">y_lattice</span><span class="p">,</span><span class="mf">0.0</span><span class="o">*</span><span class="n">z_lattice</span><span class="p">])</span>

<span class="c">#  create data structure pbc for this macro geometry</span>
<span class="n">pbc</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">SetLatticePoints</span><span class="p">(</span><span class="n">vectorlist</span><span class="o">=</span><span class="n">lattice_points</span><span class="p">,</span> <span class="n">scalefactor</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">))</span>

<span class="c">#create simulation object,  passing macro geometry data structure</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">periodic_bc</span><span class="o">=</span><span class="n">pbc</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>

<span class="c"># load mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;cube1.nmesh.h5&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;repeated-cube-1D&quot;</span><span class="p">,</span> <span class="n">Py</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">)</span> <span class="p">)</span>

<span class="c"># set initial magnetisation along the periodic axis</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="c"># compute the demagnetising field</span>
<span class="n">sim</span><span class="o">.</span><span class="n">advance_time</span><span class="p">(</span><span class="n">SI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;s&quot;</span><span class="p">))</span>

<span class="c"># probe demag field at the centre of the cube, function</span>
<span class="c"># returns an SI-Value (&#39;siv&#39;)</span>
<span class="n">H_demag</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">probe_subfield_siv</span><span class="p">(</span><span class="s">&#39;H_demag&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="k">print</span> <span class="s">&quot;H_demag_x at centre of cube = &quot;</span><span class="p">,</span> <span class="n">H_demag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">print</span> <span class="s">&quot;H_demag_y at centre of cube = &quot;</span><span class="p">,</span> <span class="n">H_demag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="k">print</span> <span class="s">&quot;H_demag_z at centre of cube = &quot;</span><span class="p">,</span> <span class="n">H_demag</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Setup can be splitted into three steps. In the first step we set the
x_lattice parameter to be slightly larger than the dimension of the
unit cell (in order not to have any overlap between the cells) and set
the y_lattice and z_lattice parameters to zero to indicate no
periodidicity along these directions</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x_lattice</span> <span class="o">=</span> <span class="mf">15.01</span> <span class="c"># the spacing is 0.01</span>
<span class="n">y_lattice</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">z_lattice</span> <span class="o">=</span> <span class="mf">0.0</span>
</pre></div>
</div>
<p>In the second step we define the lattice points where we want
the periodic copies to be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">lattice_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xi</span><span class="o">*</span><span class="n">x_lattice</span><span class="p">,</span><span class="mf">0.0</span><span class="o">*</span><span class="n">y_lattice</span><span class="p">,</span><span class="mf">0.0</span><span class="o">*</span><span class="n">z_lattice</span><span class="p">])</span>
</pre></div>
</div>
<p>and in the third step we define the object whose structure attribute
will be used as the parameter in the definition of the simulation
object</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">pbc</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">SetLatticePoints</span><span class="p">(</span><span class="n">vectorlist</span><span class="o">=</span><span class="n">lattice_points</span><span class="p">,</span> <span class="n">scalefactor</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">))</span>

<span class="c">#create simulation object</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">periodic_bc</span><span class="o">=</span><span class="n">pbc</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
</pre></div>
</div>
<p>The remaining part of the script computes the demagnetisation field at
the center of the cube. This calculation can be carried out for a
varying number of copies of the simulation cell. The next figures show
components of demagnetising field in the center of the cube as a
function of the number of periodic copies. As in the code above, we
impose an uniform magnetisation along the periodic x-axis. The first
figure shows the demagnetisation field along the x-axis, and the
second figure along the y-axis. In both figures, we have added green
crosses that have been obtained by computing the demagfield using
OOMMF (where in OOMMF we have actually made the simulation cell larger
and larger to represent the growing number of periodic copies).</p>
<img alt="_images/periodic1_in_axis.png" class="align-center" src="_images/periodic1_in_axis.png" style="width: 726px; height: 513px;" />
<p>Demagnetising field as a function of the number of periodic
copies with the magnetisation aligned along the periodic axis.</p>
<img alt="_images/periodic1_out_of_axis.png" class="align-center" src="_images/periodic1_out_of_axis.png" style="width: 726px; height: 513px;" />
<p>Demagnetising field as a function of the number of periodic
copies with the magnetisation aligned along an axis orthogonal
to the periodic one.</p>
</div>
</div>
<span id="document-example_2Dperiodicity/doc"></span><div class="section" id="example-2d-periodicity">
<span id="id1"></span><h3>Example: 2D periodicity<a class="headerlink" href="manual.html#example-2d-periodicity" title="Permalink to this headline">¶</a></h3>
<p>This example is another application of the macro-geometry feature,
where we now deal with a 2D &#8220;thin film&#8221; system. The unit cell is a
<tt class="docutils literal"><span class="pre">30x10x10</span> <span class="pre">nm^3</span></tt> prism</p>
<img alt="_images/mesh1.png" class="align-center" src="_images/mesh1.png" style="width: 559px; height: 290px;" />
<p>where we take 10 copies in x- and 40 copies in y-direction to create
the macro geometry.</p>
<p>The script <a class="reference download internal" href="_downloads/no_periodic.py"><tt class="xref download docutils literal"><span class="pre">no_periodic.py</span></tt></a> simulates behaviour of
just the unit cell of size 30x10x10 nm^3 (without any periodic
copies):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">every</span><span class="p">,</span> <span class="n">at</span>

<span class="c"># define magnetic material</span>
<span class="n">Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e6</span><span class="p">,</span><span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">)</span>
                      <span class="p">)</span>

<span class="c">#create simulation object</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>

<span class="c"># load mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;prism.nmesh.h5&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;no-periodic&quot;</span><span class="p">,</span> <span class="n">Py</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">)</span> <span class="p">)</span>

<span class="c"># set initial magnetisation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span>

<span class="c"># loop over the applied field</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;s&quot;</span><span class="p">)</span>

<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="mf">5e-12</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="o">|</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>
</pre></div>
</div>
<p>and the relaxation curves are obtained via:</p>
<div class="highlight-python"><pre>set term postscript enhanced color
set out 'no_periodic.ps'
set xlabel 'time (s)'
set ylabel 'M / Ms'
plot 'plot_no_periodic.dat' u 1:2 ti 'Mx' w lp, \
     'plot_no_periodic.dat' u 1:3 ti 'My' w lp, \
     'plot_no_periodic.dat' u 1:4 ti $
</pre>
</div>
<p>which creates the following plot:</p>
<img alt="_images/no_periodic.png" class="align-center" src="_images/no_periodic.png" style="width: 750px; height: 525px;" />
<p>From this plot we can see that with using only the unit cell the
magnetisation aligns along the x-axis at equilibrium.</p>
<p>We now move to the macro geometry of a thin film with dimensions 400x300x10nm^3 which is realised in <a class="reference download internal" href="_downloads/periodic2.py"><tt class="xref download docutils literal"><span class="pre">periodic2.py</span></tt></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">every</span><span class="p">,</span> <span class="n">at</span>

<span class="c"># define magnetic material</span>
<span class="n">Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e6</span><span class="p">,</span><span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">)</span>
                      <span class="p">)</span>

<span class="c"># size of the simulation cell, plus extra spacing </span>
<span class="n">x_lattice</span> <span class="o">=</span> <span class="mf">30.01</span>  <span class="c"># the spacing is 0.01 to avoid exchange coupling</span>
<span class="n">y_lattice</span> <span class="o">=</span> <span class="mf">10.01</span>  <span class="c"># between repeated copies of the simualtion cell</span>
<span class="n">z_lattice</span> <span class="o">=</span> <span class="mf">0.0</span>


<span class="c"># list to store the lattice points where the periodic</span>
<span class="c"># copies of the simulation cell will be placed </span>
<span class="n">lattice_points</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="mi">21</span><span class="p">):</span>
        <span class="n">lattice_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xi</span><span class="o">*</span><span class="n">x_lattice</span><span class="p">,</span><span class="n">yi</span><span class="o">*</span><span class="n">y_lattice</span><span class="p">,</span><span class="mf">0.0</span><span class="o">*</span><span class="n">z_lattice</span><span class="p">])</span>

<span class="c"># create data structure pbc for this macro geometry</span>
<span class="n">pbc</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">SetLatticePoints</span><span class="p">(</span><span class="n">vectorlist</span><span class="o">=</span><span class="n">lattice_points</span><span class="p">,</span> <span class="n">scalefactor</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">))</span>

<span class="c">#create simulation object, passing macro geometry data structure</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">periodic_bc</span><span class="o">=</span><span class="n">pbc</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>


<span class="c"># load mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;prism.nmesh.h5&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;repeated-prism-2D&quot;</span><span class="p">,</span> <span class="n">Py</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">)</span> <span class="p">)</span>

<span class="c"># set initial magnetisation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span>

<span class="c"># loop over the applied field</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;s&quot;</span><span class="p">)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span><span class="mf">5e-12</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="o">|</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>
</pre></div>
</div>
<p>As in the previous example, we first define the three unit vectors of
the lattice, again slightly larger than the dimension of the unit cell
to avoid overlapping (and thus to eleminate any exchange coupling
across the interfaces for this demonstration of the demagnetisation effects):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x_lattice</span> <span class="o">=</span> <span class="mf">30.01</span>  <span class="c"># the spacing is 0.01</span>
<span class="n">y_lattice</span> <span class="o">=</span> <span class="mf">10.01</span>  <span class="c"># the spacing is 0.01</span>
<span class="n">z_lattice</span> <span class="o">=</span> <span class="mf">0.0</span>
</pre></div>
</div>
<p>Then we define where the copies will be placed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="mi">21</span><span class="p">):</span>
        <span class="n">lattice_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xi</span><span class="o">*</span><span class="n">x_lattice</span><span class="p">,</span><span class="n">yi</span><span class="o">*</span><span class="n">y_lattice</span><span class="p">,</span><span class="mf">0.0</span><span class="o">*</span><span class="n">z_lattice</span><span class="p">])</span>

<span class="c"># copies of the system along the x-axis</span>
<span class="n">pbc</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">SetLatticePoints</span><span class="p">(</span><span class="n">vectorlist</span><span class="o">=</span><span class="n">lattice_points</span><span class="p">,</span> <span class="n">scalefactor</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>The simulation cell is (always) the one at the (0,0,0) lattice
point. The for loops therefore place 4 copies of the simulation cell
in the negative x direction [i.e. (-4,0,0), (-3,0,0), (-2,0,0), and
(-1,0,0)] and 5 in the positive the x direction [i.e. (1,0,0),
(2,0,0), (3,0,0), (4,0,0), (5,0,0)]. The translation vector (0,0,0)
corresponds to the actual simulation cell.</p>
<p>Similarly, the inner for loop places 20 copies along the positive
y-axis and 19 along the negative one.</p>
<p>We set the same initial configuration as before, with a uniform
magnetisation along [1,1,1], and let the system evolve towards the
equilibrium.</p>
<p>The outcome is shown in the following figure:</p>
<img alt="_images/periodic2.png" class="align-center" src="_images/periodic2.png" style="width: 750px; height: 525px;" />
<p>where we notice that the final configuration is now with the
magnetisation aligned along the (negative) y axis, and not along the x
axis as before. The alignment along the y-direction is expected, as
now the macro geometry has a total size of 300.09 nm times 400.39 nm
(30 nm x 10 copies plus spacings along the x direction times 10 nm x
40 copies plus spacings along the y direction) times 10nm (no periodic
copies along the z direction), so the longest side now is along the y
direction. The demagnetisation energy of the macro geometry drives the
alignment of the magnetisation with the y-direction.</p>
<p>Other usage examples include this study <a class="footnote-reference" href="manual.html#bordignonetal" id="id2">[1]</a> of an array of interacting triangular rings.</p>
<table class="docutils footnote" frame="void" id="bordignonetal" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id2">[1]</a></td><td>Giuliano Bordignon, Thomas Fischbacher, Matteo Franchin, Jurgen P. Zimmermann, Peter A. J. de Groot, Hans Fangohr, <em>Numerical studies of demagnetizing effects in triangular ring arrays</em>, Journal of Applied Physics <strong>103</strong> 07D932 (2008), online at <a class="reference external" href="http://eprints.soton.ac.uk/50995/">http://eprints.soton.ac.uk/50995/</a></td></tr>
</tbody>
</table>
</div>
<span id="document-example_periodic_spinwaves/doc"></span><div class="section" id="example-spin-waves-in-periodic-system">
<span id="spin-waves-example"></span><h3>Example: Spin-waves in periodic system<a class="headerlink" href="manual.html#example-spin-waves-in-periodic-system" title="Permalink to this headline">¶</a></h3>
<p>Starting from a magnetisation out of equilibrium, we study the time
development of the magnetisation, and track -visually- the spin waves.</p>
<p>The geometry is a thin film with dimensions 30 nm x 9 nm x 0.2 nm along
the x,y and z axes, respectively. The mesh is centered at (0,0,0)
and periodic along the x direction, so that the nodes with coordinates
(15.0,y,z) will be considered as equivalent to the nodes with coordinates (-15.0,y,z).</p>
<img alt="_images/periodic_mesh.png" class="align-center" src="_images/periodic_mesh.png" style="width: 629px; height: 376px;" />
<p>The mesh is contained in <a class="reference download internal" href="_downloads/periodic.nmesh"><tt class="xref download docutils literal"><span class="pre">periodic.nmesh</span></tt></a> and
has been produced using <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> (from  <a class="reference download internal" href="_downloads/periodic.geo"><tt class="xref download docutils literal"><span class="pre">periodic.geo</span></tt></a>) and the <a class="reference internal" href="manual.html#nmeshmirror"><em>nmeshmirror</em></a> command to create required periodic structure</p>
<div class="highlight-python"><pre>$ nmeshmirror netgen.nmesh 1e-6 1e-6 -1,0,0 periodic.nmesh</pre>
</div>
<div class="section" id="relaxation-script">
<span id="id1"></span><h4>Relaxation script<a class="headerlink" href="manual.html#relaxation-script" title="Permalink to this headline">¶</a></h4>
<p>To see how the system relaxes, we use the following
script (<a class="reference download internal" href="_downloads/spinwaves.py"><tt class="xref download docutils literal"><span class="pre">spinwaves.py</span></tt></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c"># define magnetic material</span>
<span class="n">Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e6</span><span class="p">,</span><span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                      <span class="n">llg_damping</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">0.02</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)</span>
                      <span class="p">)</span>

<span class="c"># lattice spacings along the main axes; </span>
<span class="c"># the value must be zero for no periodic copies,</span>
<span class="c"># equal to the mesh dimension along the </span>
<span class="c"># given axis otherwise</span>
<span class="n">x_lattice</span> <span class="o">=</span> <span class="mf">30.0</span>
<span class="n">y_lattice</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">z_lattice</span> <span class="o">=</span> <span class="mf">0.0</span>


<span class="c"># list to store the lattice points where the periodic</span>
<span class="c"># copies will be placed </span>
<span class="n">lattice_points</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">lattice_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xi</span><span class="o">*</span><span class="n">x_lattice</span><span class="p">,</span><span class="mf">0.0</span><span class="o">*</span><span class="n">y_lattice</span><span class="p">,</span><span class="mf">0.0</span><span class="o">*</span><span class="n">z_lattice</span><span class="p">])</span>

<span class="c"># copies of the system along the x-axis</span>
<span class="n">pbc</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">SetLatticePoints</span><span class="p">(</span><span class="n">vectorlist</span><span class="o">=</span><span class="n">lattice_points</span><span class="p">,</span> <span class="n">scalefactor</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">))</span>

<span class="c">#create simulation object</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">periodic_bc</span><span class="o">=</span><span class="n">pbc</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>

<span class="c"># load mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;periodic.nmesh&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;periodic-film&quot;</span><span class="p">,</span> <span class="n">Py</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">)</span> <span class="p">)</span>

<span class="k">print</span> <span class="n">ocaml</span><span class="o">.</span><span class="n">mesh_plotinfo_periodic_points_indices</span><span class="p">(</span> <span class="n">sim</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">raw_mesh</span> <span class="p">)</span>

<span class="c"># function to set the magnetisation </span>
<span class="k">def</span> <span class="nf">perturbed_magnetisation</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="n">newx</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="mf">1e9</span>
    <span class="n">newy</span> <span class="o">=</span> <span class="n">y</span><span class="o">*</span><span class="mf">1e9</span>
    <span class="k">if</span> <span class="mi">8</span><span class="o">&lt;</span><span class="n">newx</span><span class="o">&lt;</span><span class="mi">14</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">3</span><span class="o">&lt;</span><span class="n">newy</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>
        <span class="c"># the magnetisation is twisted a bit </span>
        <span class="k">return</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.</span><span class="o">*</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">((</span><span class="n">newx</span><span class="o">-</span><span class="mi">11</span><span class="p">)</span><span class="o">/</span><span class="mf">6.</span><span class="p">)))</span><span class="o">**</span><span class="mi">3</span> <span class="o">*</span>\
                        <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">newy</span><span class="o">/</span><span class="mf">6.</span><span class="p">)))</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>


<span class="c"># set initial magnetisation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">(</span><span class="n">perturbed_magnetisation</span><span class="p">)</span>

<span class="c"># let the system relax generating spin waves</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">nsim.when</span> <span class="kn">import</span> <span class="n">every</span><span class="p">,</span> <span class="n">at</span>
<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mf">0.05e-12</span><span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="o">|</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))],</span>
          <span class="n">do</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;exit&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mf">10e-12</span><span class="o">*</span><span class="n">s</span><span class="p">))])</span>
</pre></div>
</div>
<p>To execute this script, we call the <a class="reference internal" href="manual.html#nsim"><em>nsim</em></a> executable, for example (on linux):</p>
<div class="highlight-python"><pre>$ nsim spinwaves.py</pre>
</div>
<p>As in the previous examples, we first need to import the modules
necessary for the simulation, define the material of the magnetic
object, load the mesh and set the initial configuration of the
magnetisation. Here, we start from a spatially non-homogeneous
configuration in order to excite spin waves. Nmag allows us to provide a
function to be sampled on the mesh that defines a particular
magnetisation configuration.</p>
<img alt="_images/initial_magn.png" class="align-center" src="_images/initial_magn.png" style="width: 552px; height: 389px;" />
<p>In our case, we use the function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">perturbed_magnetisation</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="n">newx</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="mf">1e9</span>
    <span class="n">newy</span> <span class="o">=</span> <span class="n">y</span><span class="o">*</span><span class="mf">1e9</span>
    <span class="k">if</span> <span class="mi">8</span><span class="o">&lt;</span><span class="n">newx</span><span class="o">&lt;</span><span class="mi">14</span> <span class="ow">and</span> <span class="o">-</span><span class="mi">3</span><span class="o">&lt;</span><span class="n">newy</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>
        <span class="c"># the magnetisation is twisted a bit</span>
        <span class="k">return</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.</span><span class="o">*</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">((</span><span class="n">newx</span><span class="o">-</span><span class="mi">11</span><span class="p">)</span><span class="o">/</span><span class="mf">6.</span><span class="p">)))</span><span class="o">**</span><span class="mi">3</span> <span class="o">*</span>\
                        <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">newy</span><span class="o">/</span><span class="mf">6.</span><span class="p">)))</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
</pre></div>
</div>
<p>which is then passed on to <a class="reference internal" href="manual.html#set-m"><em>set_m</em></a></p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># set initial magnetisation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">(</span><span class="n">perturbed_magnetisation</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="visualising-the-magnetisation-evolution">
<span id="id2"></span><h4>Visualising the magnetisation evolution<a class="headerlink" href="manual.html#visualising-the-magnetisation-evolution" title="Permalink to this headline">¶</a></h4>
<p>Once the calculation has finished, we can see how the system relaxed
by means of snapshots of the magnetisation evolution.</p>
<p>The <a class="reference internal" href="manual.html#nmagpp"><em>nmagpp</em></a> command allows us to create vtk files
from the data saved with the <tt class="docutils literal"><span class="pre">save</span></tt> option in the <tt class="docutils literal"><span class="pre">relax</span></tt> method:</p>
<div class="highlight-python"><pre>nmagpp --vtk=fields spinwaves</pre>
</div>
<p>The first few frames that show the evolution of the magnetic
configuration are shown below.</p>
<div class="figure align-center">
<img alt="evolution-1" src="_images/evolution-1.png" />
<p class="caption">Initial magnetisation configuration.</p>
</div>
<div class="figure align-center">
<img alt="evolution-2" src="_images/evolution-2.png" />
<p class="caption">Magnetisation configuration after 0.15 ps. It is clearly visible
that the spin waves travel from the center of the disturbance to the
right and penetrate the system immediately from the left (due to the
periodic boundary conditions in the x-direction).</p>
</div>
<div class="figure align-center">
<img alt="evolution-3" src="_images/evolution-3.png" />
<p class="caption">Magnetisation configuration after 0.25 ps.</p>
</div>
</div>
</div>
<span id="document-example2/doc2"></span><div class="section" id="example-post-processing-of-saved-field-data">
<span id="id1"></span><h3>Example: post processing of saved field data<a class="headerlink" href="manual.html#example-post-processing-of-saved-field-data" title="Permalink to this headline">¶</a></h3>
<p>Suppose we have saved spatially resolved fields (as, for example, in
<a class="reference internal" href="manual.html#example-2"><em>Example 2: Computing the time development of a system</em></a>), and we would like to read those from the data file to
process the data further.</p>
<p>We can use the <a class="reference internal" href="manual.html#nmagpp"><em>nmagpp</em></a> tool if it provides the required functionality.</p>
<p>Alternatively, we can write a Python script that:</p>
<ol class="arabic simple">
<li>reads the data from the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> file</li>
<li>carries out the required post processing and/or saves the data in
(another) format.</li>
</ol>
<p>The program <a class="reference download internal" href="_downloads/read_h5.py"><tt class="xref download docutils literal"><span class="pre">read_h5.py</span></tt></a>
demonstrates how to read the saved configuration with id=0 of the <tt class="docutils literal"><span class="pre">m_Py</span></tt>
subfield, and to print this to the screen.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>

<span class="c">#read data, positions, and sites from h5 file</span>
<span class="n">m</span><span class="o">=</span><span class="n">nmag</span><span class="o">.</span><span class="n">get_subfield_from_h5file</span><span class="p">(</span><span class="s">&#39;bar_dat.h5&#39;</span><span class="p">,</span><span class="s">&#39;m_Py&#39;</span><span class="p">,</span><span class="nb">id</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">pos</span><span class="o">=</span><span class="n">nmag</span><span class="o">.</span><span class="n">get_subfield_positions_from_h5file</span><span class="p">(</span><span class="s">&#39;bar_dat.h5&#39;</span><span class="p">,</span><span class="s">&#39;m_Py&#39;</span><span class="p">)</span>
<span class="n">site</span><span class="o">=</span><span class="n">nmag</span><span class="o">.</span><span class="n">get_subfield_sites_from_h5file</span><span class="p">(</span><span class="s">&#39;bar_dat.h5&#39;</span><span class="p">,</span><span class="s">&#39;m_Py&#39;</span><span class="p">)</span>

<span class="c">#can carry out some sanity checks (but is not necessary)</span>
<span class="k">assert</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">pos</span><span class="o">.</span><span class="n">shape</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>

<span class="c">#print the data</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)):</span>
    <span class="k">print</span> <span class="n">site</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>The functions <a class="reference internal" href="manual.html#get-subfield-from-h5file"><em>get_subfield_from_h5file</em></a>,
<a class="reference internal" href="manual.html#get-subfield-positions-from-h5file"><em>get_subfield_positions_from_h5file</em></a> and
<a class="reference internal" href="manual.html#get-subfield-sites-from-h5file"><em>get_subfield_sites_from_h5file</em></a> allow in principle to retrieve all the
field data from the h5 files and stores this in the variables <tt class="docutils literal"><span class="pre">m</span></tt>,
<tt class="docutils literal"><span class="pre">pos</span></tt>, and <tt class="docutils literal"><span class="pre">site</span></tt>, respectively.</p>
<p>The program, when run like this:</p>
<div class="highlight-python"><pre>$ nsim read_h5.py</pre>
</div>
<p>in the <a class="reference internal" href="manual.html#example-2"><em>Example 2: Computing the time development of a system</em></a> directory, produces output starting as follows (assuming the <tt class="docutils literal"><span class="pre">bar_dat.h5</span></tt> file exists):</p>
<div class="highlight-python"><pre>[0] [ 0.  0.  0.] [ 0.70710677  0.          0.70710677]
[1] [  3.00000000e-09   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[2] [  6.00000000e-09   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[3] [  9.00000000e-09   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[4] [  1.20000000e-08   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[5] [  1.50000000e-08   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[6] [  1.80000000e-08   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[7] [  2.10000000e-08   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[8] [  2.40000000e-08   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[9] [  2.70000000e-08   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[10] [  3.00000000e-08   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[11] [  3.00000000e-08   3.00000000e-08   1.00000000e-07] [ 0.70710677  0.          0.70710677]
[12] [  3.00000000e-08   2.70000000e-08   1.00000000e-07] [ 0.70710677  0.          0.70710677]</pre>
</div>
<p>We can see that the <a class="reference internal" href="manual.html#site"><em>Site</em></a> index is (here) just an integer, the position
(in nanometre) is shown as a triplet of three scalars, and the normalised
magnetisation is also a vector with three components.</p>
<p>The data (in the arrays <tt class="docutils literal"><span class="pre">m</span></tt>, <tt class="docutils literal"><span class="pre">site</span></tt> and <tt class="docutils literal"><span class="pre">position</span></tt> in this
example) can be manipulated as explained in the <a class="reference internal" href="manual.html#numpy"><em>NumPy</em></a> documentation,
because it is of type <tt class="docutils literal"><span class="pre">numpy</span> <span class="pre">array</span></tt>. Numpy provides a powerful matrix
processing environment.</p>
</div>
<span id="document-example_zhangli1/doc"></span><div class="section" id="example-spin-transfer-torque-zhang-li-model">
<h3>Example: Spin transfer torque (Zhang-Li model)<a class="headerlink" href="manual.html#example-spin-transfer-torque-zhang-li-model" title="Permalink to this headline">¶</a></h3>
<p>Nmag provides support for the Zhang-Li extension to the
Landau-Lifshitz-Gilbert (LLG) equation <a class="footnote-reference" href="manual.html#zhangli" id="id1">[1]</a>, in order to model the interaction
between a uniform electric current density and a spatially varying
magnetisation. The extened LLG equation reads</p>
<div class="math">
<p><img src="_images/math/38e6b38f7ffaaf40d78e76cd46aca2b723fe328a.png" alt="\frac{\partial \vec{M}}{\partial t} =
  -\gamma \, \vec{M} \times \vec{H}
  +\frac{\alpha}{M_{\mathrm{sat}}} \, \vec{M} \times \frac{\partial \vec{M}}{\partial t}
  -\frac{v}{M_{\mathrm{sat}}^2} \, \vec{M} \times
   \left(\vec{M} \times \hat{j} \cdot \nabla \vec{M} \right)
  -\frac{\xi v}{M_{\mathrm{sat}}} \, \vec{M} \times \hat{j} \cdot \nabla \vec{M}" /></p>
</div><p>where the first two terms on the right-hand side are the normal LLG equation, and the extra terms come from the Zhang-Li model, and</p>
<img alt="_images/eq_zhangli_llg_d.png" class="align-center" src="_images/eq_zhangli_llg_d.png" style="width: 668px; height: 196px;" />
<p>The central column shows the method which can be used to set
the field (<tt class="docutils literal"><span class="pre">Simulation.set_m</span></tt> or <tt class="docutils literal"><span class="pre">Simulation.set_H_ext</span></tt>) or
the name of the corresponding parameter in the material definition
(for example, <tt class="docutils literal"><span class="pre">mat</span> <span class="pre">=</span> <span class="pre">MagMaterial(Ms=SI(0.8e6,</span> <span class="pre">&quot;A/m&quot;),</span> <span class="pre">...)</span></tt>).
The current density appears only throughout the quantity <tt class="docutils literal"><span class="pre">v</span></tt>, which
we define as:</p>
<div class="math">
<p><img src="_images/math/e6d2300f0caf912cdcb2158a0c552b3a3828a4a8.png" alt="v = \frac{P \; j \; \mu_B}{e \; M_{\mathrm{sat}} \; (1 + \xi^2)}" /></p>
</div><p>with:</p>
<img alt="_images/eq_v_d.png" class="align-center" src="_images/eq_v_d.png" style="width: 755px; height: 169px;" />
<p>In this and in the next examples we show how to set up a micromagnetic
simulation including such spin transfer torque effects.
We show how the current density can be specified and how the required
parameters can be included in the material definitions.</p>
<p>As a first example, we consider a thin Permalloy film which develops
a vortex in the center. We compute the dynamics of the vortex
as a response to the application of a current.</p>
<table class="docutils footnote" frame="void" id="zhangli" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id1">[1]</a></td><td>S. Zhang and Z. Li, <em>Roles of Nonequilibrium Conduction Electrons
on the Magnetization Dynamics of Ferromagnets</em>, Physical Review
Letters <strong>93</strong>, 127204 (2004), online at
<a class="reference external" href="http://link.aps.org/doi/10.1103/PhysRevLett.93.127204">http://link.aps.org/doi/10.1103/PhysRevLett.93.127204</a></td></tr>
</tbody>
</table>
<div class="section" id="current-driven-motion-of-a-vortex-in-a-thin-film">
<span id="id2"></span><h4>Current-driven motion of a vortex in a thin film<a class="headerlink" href="manual.html#current-driven-motion-of-a-vortex-in-a-thin-film" title="Permalink to this headline">¶</a></h4>
<p>The system under investigation is a 100 x 100 x 10 nm Permalloy film.
The mesh is stored in the file
<a class="reference download internal" href="_downloads/pyfilm.nmesh.h5"><tt class="xref download docutils literal"><span class="pre">pyfilm.nmesh.h5</span></tt></a>.</p>
<p>The simulation is subdivided in two parts:</p>
<ul class="simple">
<li>In part I, the system is
relaxed to obtain the initial magnetisation configuration when the
current <strong>is not</strong> applied, which is just a vortex in the center of
the film.</li>
<li>In part II, the vortex magnetisation obtained in part I is
loaded and used as the initial magnetisation configuration. A current
is applied and the magnetisation dynamics is analysed by
saving periodically the data (the magnetisation, the other fields and
their averages).</li>
</ul>
<p>Here we use two separate simulation scripts to carry out part I and
part II subsequentely. This is the approach that is easiest to
understand. Once the basic ideas have become clear, it is often a good
idea to write only one simulation script that carries out both part I
and part II. (Indeed many of the parameters, such as the saturation
magnetisation or the exchange coupling need to be specified in each of
the two scripts leading to possible errors: for example if one decides
to investigate a different material and changes the parameters just in
one file and forgets the other, etc.). In the next section
(<a class="reference internal" href="manual.html#example-current-driven-magnetisation-precession-in-nanopillars"><em>Example: Current-driven magnetisation precession in nanopillars</em></a>), we present
a more robust approach, where both part I and part II are executed by
just one script.</p>
</div>
<div class="section" id="part-i-relaxation">
<h4>Part I: Relaxation<a class="headerlink" href="manual.html#part-i-relaxation" title="Permalink to this headline">¶</a></h4>
<p>The first script carries out a normal micromagnetic simulation
(i.e. no spin transfer torque), and determines the relaxed
magnetisation configuration for a given geometry, material and initial
configuration. It saves the final magnetisation to disk. Here is the
full listing of <a class="reference download internal" href="_downloads/relaxation1.py"><tt class="xref download docutils literal"><span class="pre">relaxation.py</span></tt></a>
:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># We model a bar 100 nm x 100 nm x 10 nm where a vortex sits in the center.</span>
<span class="c"># This is part I: we just do a relaxation to obtain the shape of the vortex.</span>
<span class="kn">import</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">at</span>
<span class="kn">from</span> <span class="nn">nsim.si_units.si</span> <span class="kn">import</span> <span class="n">degrees_per_ns</span>

<span class="c"># Define the material</span>
<span class="n">mat_Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                          <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.8e6</span><span class="p">,</span><span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                          <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                          <span class="n">llg_gamma_G</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.2211e6</span><span class="p">,</span> <span class="s">&quot;m/A s&quot;</span><span class="p">),</span>
                          <span class="n">llg_damping</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

<span class="c"># Define the simulation object and load the mesh</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;pyfilm.nmesh.h5&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;Py&quot;</span><span class="p">,</span> <span class="n">mat_Py</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">))</span>

<span class="c"># Set a initial magnetisation which will relax into a vortex</span>
<span class="k">def</span> <span class="nf">initial_m</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">p</span>
  <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="mf">50.0e-9</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">50.0e-9</span><span class="p">),</span> <span class="mf">40.0e-9</span><span class="p">]</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">(</span><span class="n">initial_m</span><span class="p">)</span>

<span class="c"># Set convergence parameters and run the simulation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="n">stopping_dm_dt</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="n">degrees_per_ns</span><span class="p">)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;stage_end&#39;</span><span class="p">))])</span>

<span class="c"># Write the final magnetisation to file &quot;vortex_m.h5&quot;</span>
<span class="n">sim</span><span class="o">.</span><span class="n">save_restart_file</span><span class="p">(</span><span class="s">&quot;vortex_m.h5&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>After importing the usual Nmag module and helper objects, we define
the material, create the simulation object and load the mesh,
(similar to what is shown in previous examples):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Define the material</span>
<span class="n">mat_Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                          <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.8e6</span><span class="p">,</span><span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                          <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                          <span class="n">llg_gamma_G</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.2211e6</span><span class="p">,</span> <span class="s">&quot;m/A s&quot;</span><span class="p">),</span>
                          <span class="n">llg_damping</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

<span class="c"># Define the simulation object and load the mesh</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;pyfilm.nmesh.h5&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;Py&quot;</span><span class="p">,</span> <span class="n">mat_Py</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>Notice that the damping parameter <tt class="docutils literal"><span class="pre">llg_damping</span></tt> is set to a high value,
to allow for quick relaxation of the magnetisation.
We write a function <tt class="docutils literal"><span class="pre">initial_m</span></tt> that is being given the position of each
site in the mesh as a vector <tt class="docutils literal"><span class="pre">p</span></tt> with three components, and which returns
an initial magnetisation vector. This vector is chosen such that the initial
magnetisation that is described by this function is likely to relax into a
vortex configuration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">initial_m</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">p</span>
  <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="mf">50.0e-9</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mf">50.0e-9</span><span class="p">),</span> <span class="mf">40.0e-9</span><span class="p">]</span>
</pre></div>
</div>
<p>The magnetisation at point <tt class="docutils literal"><span class="pre">p</span></tt> is obtained from a 90 degree rotation
of the vector which connects <tt class="docutils literal"><span class="pre">p</span></tt> to the center of the film.
This vector doesn&#8217;t have to be normalised: Nmag will take care of
normalising it for us.</p>
<p>We need to instruct the simulation object <tt class="docutils literal"><span class="pre">sim</span></tt> to use this function
to set the magnetisation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">(</span><span class="n">initial_m</span><span class="p">)</span>
</pre></div>
</div>
<p>We set the criterion to be used to decide when the magnetisation has
relaxed. The value used here in <a class="reference internal" href="manual.html#set-params"><em>set_params</em></a> (i.e. one degree per
nanosecond) is the default value (so we could omit this, but we change
the value in the second part of this example):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="n">stopping_dm_dt</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="n">degrees_per_ns</span><span class="p">)</span>
</pre></div>
</div>
<p>We finally run the simulation using the <a class="reference internal" href="manual.html#relax"><em>relax</em></a> command until the
convergence criterion dm/dt &lt; 1 degree per nanosecond is
fullfilled. In the process, we save spatially resolved data for all
fields at step 0, and the same data at the end of the stage
(i.e. when an equilibrium has been reached, just before the <a class="reference internal" href="manual.html#relax"><em>relax</em></a>
function returns):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;stage_end&#39;</span><span class="p">))])</span>
</pre></div>
</div>
<p>We finally save the relaxed magnetisation to a file using the function
<a class="reference internal" href="manual.html#save-restart-file"><em>save_restart_file</em></a>, so that we can use this in part 2 as the initial
configuration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">save_restart_file</span><span class="p">(</span><span class="s">&quot;vortex_m.h5&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We can launch the script with the command:</p>
<div class="highlight-python"><pre>$ nsim relaxation.py</pre>
</div>
<p>The output files for this simulation will have the prefix <tt class="docutils literal"><span class="pre">relaxation</span></tt> in
their names. The script saves the magnetisation at the beginning
(before relaxation) and at the end (after relaxation). The magnetisations
can be extracted and saved into vtk files using the command
<tt class="docutils literal"><span class="pre">nmagpp</span> <span class="pre">relaxation</span> <span class="pre">--vtk=m.vtk</span></tt>, as usual. MayaVi can then be used
to show the initial magnetisation (as described by the <tt class="docutils literal"><span class="pre">initial_m</span></tt> function):</p>
<div class="figure align-center">
<img alt="zhangli-1" src="_images/m-begin.png" />
</div>
<p>The magnetisation at the end of the relaxation process:</p>
<div class="figure align-center">
<img alt="zhangli-2" src="_images/m-end.png" />
</div>
<p>The relaxed vortex is much smaller than the initial one.  The
important thing to notice is that such a magnetisation configuration
has now been saved into the file <tt class="docutils literal"><span class="pre">vortex_m.h5</span></tt> which will be used as
the initial magnetisation for part II of this simulation, where we
study the current driven dynamics of the vortex.</p>
</div>
<div class="section" id="part-ii-current-driven-dynamics">
<h4>Part II: Current driven dynamics<a class="headerlink" href="manual.html#part-ii-current-driven-dynamics" title="Permalink to this headline">¶</a></h4>
<p>For part II we need to use a slightly modified version of the script
used for part I. Here is the full listing of
<a class="reference download internal" href="_downloads/stt.py"><tt class="xref download docutils literal"><span class="pre">stt.py</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># We model a bar 100 nm x 100 nm x 10 nm where a vortex sits in the center.</span>
<span class="c"># This is part II: we load the vortex from file and apply a spin-polarised current</span>

<span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">every</span><span class="p">,</span> <span class="n">at</span>

<span class="c"># Define the material</span>
<span class="n">mat_Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                          <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.8e6</span><span class="p">,</span><span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                          <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                          <span class="n">llg_gamma_G</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.2211e6</span><span class="p">,</span> <span class="s">&quot;m/A s&quot;</span><span class="p">),</span>
                          <span class="n">llg_polarisation</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                          <span class="n">llg_xi</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                          <span class="n">llg_damping</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c"># Define the simulation object and load the mesh</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;pyfilm.nmesh.h5&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;Py&quot;</span><span class="p">,</span> <span class="n">mat_Py</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">))</span>

<span class="c"># Set the initial magnetisation: part II uses the one saved by part I</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_m_from_h5file</span><span class="p">(</span><span class="s">&quot;vortex_m.h5&quot;</span><span class="p">)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_current_density</span><span class="p">([</span><span class="mf">1e12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="s">&quot;A/m^2&quot;</span><span class="p">))</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="n">stopping_dm_dt</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span> <span class="c"># * WE * decide when the simulation should stop!</span>

<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1.0e-9</span><span class="p">,</span> <span class="s">&quot;s&quot;</span><span class="p">))),</span>
                <span class="p">(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">0.05e-9</span><span class="p">,</span> <span class="s">&quot;s&quot;</span><span class="p">))</span> <span class="o">|</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;stage_end&#39;</span><span class="p">))],</span>
          <span class="n">do</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;exit&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">10e-9</span><span class="p">,</span> <span class="s">&quot;s&quot;</span><span class="p">)))])</span>
</pre></div>
</div>
<p>We now discuss the script with particular emphasis on the differences
with the first one. One difference lies in the material definition:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Define the material</span>
<span class="n">mat_Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                          <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.8e6</span><span class="p">,</span><span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                          <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                          <span class="n">llg_gamma_G</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.2211e6</span><span class="p">,</span> <span class="s">&quot;m/A s&quot;</span><span class="p">),</span>
                          <span class="n">llg_polarisation</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                          <span class="n">llg_xi</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                          <span class="n">llg_damping</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we use two new arguments for the <a class="reference internal" href="manual.html#magmaterial"><em>MagMaterial</em></a> class.
The first is <tt class="docutils literal"><span class="pre">llg_polarisation</span></tt> which is used to specify the spin polarisation
of the conduction electrons inside the given material.
The second, <tt class="docutils literal"><span class="pre">llg_xi</span></tt>, is used to specify the degree of non-adiabaticity.
Note that for the damping parameter, <tt class="docutils literal"><span class="pre">llg_damping</span></tt>, we are now using
a smaller value, 0.1 (these values are not realistic for Permalloy).</p>
<p>The script then continues by creating the simulation object
and loading the mesh (which is identical to the relaxation script shown in part I). The initial magnetisation is read from the <tt class="docutils literal"><span class="pre">vortex_m.h5</span></tt> file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Set the initial magnetisation: part II uses the one saved by part I</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_m_from_h5file</span><span class="p">(</span><span class="s">&quot;vortex_m.h5&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we use the function <a class="reference internal" href="manual.html#load-m-from-h5file"><em>load_m_from_h5file</em></a> to load the magnetisation
from the file <tt class="docutils literal"><span class="pre">vortex_m.h5</span></tt>, which was created in part I by using
the function <a class="reference internal" href="manual.html#save-restart-file"><em>save_restart_file</em></a>.
We set the current density:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">set_current_density</span><span class="p">([</span><span class="mf">1e12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="s">&quot;A/m^2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>The current density has norm <tt class="docutils literal"><span class="pre">10^12</span> <span class="pre">A/m^2</span></tt> and is aligned in the <tt class="docutils literal"><span class="pre">x</span></tt>
direction. We then disable the convergence check:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="n">stopping_dm_dt</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span> <span class="c"># * WE * decide when the simulation should stop!</span>
</pre></div>
</div>
<p>Here we decide that convergence should be reached when the magnetisation moves
less than 0.0 degrees per nanosecond. This cannot happen and hence convergence
is never reached: we&#8217;ll tell the <tt class="docutils literal"><span class="pre">relax</span></tt> method to exit after a fixed amount
of time has been simulated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1.0e-9</span><span class="p">,</span> <span class="s">&quot;s&quot;</span><span class="p">))),</span>
                <span class="p">(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">0.05e-9</span><span class="p">,</span> <span class="s">&quot;s&quot;</span><span class="p">))</span> <span class="o">|</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;stage_end&#39;</span><span class="p">))],</span>
          <span class="n">do</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;exit&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">10e-9</span><span class="p">,</span> <span class="s">&quot;s&quot;</span><span class="p">)))])</span>
</pre></div>
</div>
<p>We run the simulation for just 10 nanoseconds by forcing an exit with
<tt class="docutils literal"><span class="pre">('exit',</span> <span class="pre">at('time',</span> <span class="pre">SI(10e-9,</span> <span class="pre">&quot;s&quot;)))</span></tt>.  We also save the fields
every nanosecond and save the averages more often, every 50
picoseconds. The relax method will simulate a vortex &#8220;hit&#8221; by a spin
polarised current and will save the averages so that we can see how
the magnetisation changes in time.</p>
<p>To run the script (which takes of the order of half an hour) we use as usual:</p>
<blockquote>
<div>$ nsim stt.py</div></blockquote>
<p>The output files for this simulation will start with the prefix <tt class="docutils literal"><span class="pre">stt</span></tt>.
The script saves the average magnetisation periodically in time.
We can therefore plot it using the following gnuplot script:</p>
<div class="highlight-python"><pre>set term postscript color eps enhanced
set out "m_of_t.eps"

set xlabel "time (ns)"
set ylabel "average magnetisation (10^6 A/m)"
plot [0:10] \
  "m_of_t.dat" u ($1*1e9):($2/1e6) t "&lt;M_x&gt;" w lp, \
  "" u ($1*1e9):($3/1e6) t "&lt;M_y&gt;" w lp, \
  "" u ($1*1e9):($4/1e6) t "&lt;M_z&gt;" w lp
</pre>
</div>
<p>to obtain the following graph:</p>
<div class="figure align-center">
<img alt="zhangli-3" src="_images/m_of_t.png" />
</div>
</div>
<div class="section" id="standard-problem">
<span id="id3"></span><h4>Standard problem<a class="headerlink" href="manual.html#standard-problem" title="Permalink to this headline">¶</a></h4>
<p>The simulation carried out here is a (coarse) version of the recently
proposed standard problem for spin transfer torque micromagnetic
studies <a class="footnote-reference" href="manual.html#najafietal" id="id4">[2]</a>.</p>
<table class="docutils footnote" frame="void" id="najafietal" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id4">[2]</a></td><td>Massoud Najafi, Benjamin Kruger, Stellan Bohlens, Matteo Franchin, Hans Fangohr, Antoine Vanhaverbeke, Rolf Allenspach, Markus Bolte, Ulrich Merkt, Daniela Pfannkuche, Dietmar P. F. Moller, and Guido Meier, <em>Proposal for a Standard Problem for Micromagnetic Simulations Including Spin-Transfer Torque</em>, Journal of Applied Physics, in print (2009), preprint available at <a class="reference external" href="http://www.soton.ac.uk/~fangohr/publications/preprint/Najafi_etal_2009.pdf">http://www.soton.ac.uk/~fangohr/publications/preprint/Najafi_etal_2009.pdf</a></td></tr>
</tbody>
</table>
</div>
</div>
<span id="document-example_zhangli2/doc"></span><div class="section" id="example-current-driven-magnetisation-precession-in-nanopillars">
<span id="id1"></span><h3>Example: Current-driven magnetisation precession in nanopillars<a class="headerlink" href="manual.html#example-current-driven-magnetisation-precession-in-nanopillars" title="Permalink to this headline">¶</a></h3>
<p>This is the second example we provide in order to illustrate the usage
of the Zhang-Li extension to model spin-transfer-torque in Nmag.
While in the <a class="reference internal" href="manual.html#current-driven-motion-of-a-vortex-in-a-thin-film"><em>Current-driven motion of a vortex in a thin film</em></a> example we tried to present two scripts (one for initial relaxation, and one for the spin torque transfer simulation),
sacrificing usability for the sake of clarity, here we&#8217;ll try to present
a real-life script, using the power of the Python programming language
as much as it is needed to achieve our goal.</p>
<div class="figure align-center">
<img alt="_images/nanopillar.png" src="_images/nanopillar.png" />
</div>
<p>We consider a ferromagnetic nanopillar in the shape of a cylinder.
We assume that the magnetisation in the nanopillar is pinned in the two
faces of the cylinder along opposite directions: on the right face
the magnetisation points to the right, while on the left face it points
to the left. The magnetisation is then forced to develop a domain wall.
We then study how such an &#8220;artificial&#8221; domain wall interacts with a current
flowing throughout the cylinder, along its axis.</p>
<p>By &#8220;artificial&#8221; we mean that the domain wall is developed as a
consequence of the pinning, which we artificially impose.  In real
systems, the pinning can be provided through interface exchange
coupling or may have a geometrical origin, in combination with
suitable material parameters. The situation we consider here is
described and studied in more detail in publications <a class="footnote-reference" href="manual.html#franchin2008a" id="id2">[1]</a> and <a class="footnote-reference" href="manual.html#franchin2008b" id="id3">[2]</a>.</p>
<table class="docutils footnote" frame="void" id="franchin2008a" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="manual.html#id2">1</a>, <a class="fn-backref" href="manual.html#id5">2</a>)</em> Matteo Franchin, Thomas Fischbacher, Giuliano Bordignon, Peter de Groot, Hans Fangohr, <em>Current-driven dynamics of domain walls constrained in ferromagnetic nanopillars</em>, Physical Review B <strong>78</strong>, 054447 (2008), online at <a class="reference external" href="http://eprints.soton.ac.uk/59253">http://eprints.soton.ac.uk/59253</a>,</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="franchin2008b" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="manual.html#id3">1</a>, <a class="fn-backref" href="manual.html#id6">2</a>)</em> Matteo Franchin, Giuliano Bordignon, Peter A. J. de Groot, Thomas Fischbacher, Jurgen P. Zimmermann, Guido Meier, Hans Fangohr, <em>Spin-polarized currents in exchange spring systems</em>, Journal of Applied Physics <strong>103</strong>, 07A504 (2008), online at <a class="reference external" href="http://link.aip.org/link/?JAPIAU/103/07A504/1">http://link.aip.org/link/?JAPIAU/103/07A504/1</a></td></tr>
</tbody>
</table>
<div class="section" id="two-simulations-in-one-single-script">
<span id="id4"></span><h4>Two simulations in one single script<a class="headerlink" href="manual.html#two-simulations-in-one-single-script" title="Permalink to this headline">¶</a></h4>
<p>The nanopillar is made of Permalloy and has the shape of a cylinder with
radius of 10 nm and length 30 nm. The mesh is loaded from the file
<a class="reference download internal" href="_downloads/l030.nmesh.h5"><tt class="xref download docutils literal"><span class="pre">l030.nmesh.h5</span></tt></a>
which was created using <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> from the file
<a class="reference download internal" href="_downloads/l030.geo"><tt class="xref download docutils literal"><span class="pre">l030.geo</span></tt></a>.</p>
<img alt="_images/mesh3.png" class="align-center" src="_images/mesh3.png" style="width: 590px; height: 308px;" />
<p>The simulation is subdivided into two parts, similarly to the previous
example:</p>
<ul class="simple">
<li>In part I, the system is relaxed to obtain the initial magnetisation
configuration when the current is not applied.</li>
<li>In part II the current is applied to the artificial domain wall
whose shape was calculated in part I.</li>
</ul>
<p>This time, however, we use just one single script to execute both
parts of the simulation in one go.  In particular, we define a
function which takes some input parameters such as the current
density, the damping, etc and uses them to carry out a simulation. We
then call this function twice: once for part I and once for part
II.</p>
<p>The full listing of the script <a class="reference download internal" href="_downloads/stt_nanopillar.py"><tt class="xref download docutils literal"><span class="pre">stt_nanopillar.py</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span><span class="p">,</span> <span class="n">every</span><span class="p">,</span> <span class="n">at</span>
<span class="kn">from</span> <span class="nn">nsim.si_units.si</span> <span class="kn">import</span> <span class="n">degrees_per_ns</span>

<span class="n">l</span> <span class="o">=</span> <span class="mf">30.0</span>                        <span class="c"># The nanopillar thickness is 30 nm</span>
<span class="n">hl</span> <span class="o">=</span> <span class="n">l</span><span class="o">/</span><span class="mi">2</span>                        <span class="c"># hl is half the nanopillar thickness</span>
<span class="n">relaxed_m_file</span> <span class="o">=</span> <span class="s">&quot;relaxed_m.h5&quot;</span> <span class="c"># File containing the relaxed magnetisation</span>
<span class="n">mesh_name</span> <span class="o">=</span> <span class="s">&quot;l030.nmesh.h5&quot;</span>     <span class="c"># Mesh name</span>
<span class="n">mesh_unit</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">)</span>       <span class="c"># Unit length for space used by the mesh</span>

<span class="k">def</span> <span class="nf">run_simulation</span><span class="p">(</span><span class="n">sim_name</span><span class="p">,</span> <span class="n">initial_m</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">stopping_dm_dt</span><span class="p">,</span>
                   <span class="n">j</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="p">[],</span> <span class="n">do</span><span class="o">=</span><span class="p">[],</span> <span class="n">do_demag</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
  <span class="c"># Define the material</span>
  <span class="n">mat</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span>
          <span class="n">name</span><span class="o">=</span><span class="s">&quot;mat&quot;</span><span class="p">,</span>
          <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.8e6</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
          <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
          <span class="n">llg_damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>
          <span class="n">llg_xi</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.01</span><span class="p">),</span>
          <span class="n">llg_polarisation</span><span class="o">=</span><span class="n">P</span><span class="p">)</span>

  <span class="c"># Create the simulation object and load the mesh</span>
  <span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">sim_name</span><span class="p">,</span> <span class="n">do_demag</span><span class="o">=</span><span class="n">do_demag</span><span class="p">)</span>
  <span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="n">mesh_name</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;np&quot;</span><span class="p">,</span> <span class="n">mat</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">mesh_unit</span><span class="p">)</span>

  <span class="c"># Set the pinning at the top and at the bottom of the nanopillar</span>
  <span class="k">def</span> <span class="nf">pinning</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">p</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">SI</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mesh_unit</span><span class="o">*</span><span class="n">hl</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.999</span><span class="p">:</span>
      <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="mf">1.0</span>
  <span class="n">sim</span><span class="o">.</span><span class="n">set_pinning</span><span class="p">(</span><span class="n">pinning</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">initial_m</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>            <span class="c"># Set the initial magnetisation</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">load_m_from_h5file</span><span class="p">(</span><span class="n">initial_m</span><span class="p">)</span>   <span class="c"># a) from file if a string is provided</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">(</span><span class="n">initial_m</span><span class="p">)</span>                <span class="c"># b) from function/vector, otherwise</span>

  <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>                          <span class="c"># Set the current, if needed</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">set_current_density</span><span class="p">([</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="s">&quot;A/m^2&quot;</span><span class="p">))</span>

  <span class="c"># Set additional parameters for the time-integration and run the simulation</span>
  <span class="n">sim</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="n">stopping_dm_dt</span><span class="o">=</span><span class="n">stopping_dm_dt</span><span class="p">,</span>
                 <span class="n">ts_rel_tol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span> <span class="n">ts_abs_tol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">)</span>
  <span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">,</span> <span class="n">do</span><span class="o">=</span><span class="n">do</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">sim</span>

<span class="c"># If the initial magnetisation has not been calculated and saved into</span>
<span class="c"># the file relaxed_m_file, then do it now!</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">relaxed_m_file</span><span class="p">):</span>
  <span class="c"># Initial direction for the magnetisation</span>
  <span class="k">def</span> <span class="nf">m0</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
      <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">p</span>
      <span class="n">tmp</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">SI</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mesh_unit</span><span class="o">*</span><span class="n">hl</span><span class="p">))))</span>
      <span class="n">angle</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">tmp</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">]</span>

  <span class="n">save</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;stage_end&#39;</span><span class="p">)),</span>
          <span class="p">(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">5e-12</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">)))]</span>

  <span class="n">sim</span> <span class="o">=</span> <span class="n">run_simulation</span><span class="p">(</span><span class="n">sim_name</span><span class="o">=</span><span class="s">&quot;relaxation&quot;</span><span class="p">,</span> <span class="n">initial_m</span><span class="o">=</span><span class="n">m0</span><span class="p">,</span>
                       <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">,</span>
                       <span class="n">stopping_dm_dt</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="n">degrees_per_ns</span><span class="p">)</span>
  <span class="n">sim</span><span class="o">.</span><span class="n">save_restart_file</span><span class="p">(</span><span class="n">relaxed_m_file</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">sim</span>

<span class="c"># Now we simulate the magnetisation dynamics</span>
<span class="n">save</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">9e-12</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">)))]</span>
<span class="n">do</span>   <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;exit&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">6e-9</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">)))]</span>
<span class="n">run_simulation</span><span class="p">(</span><span class="n">sim_name</span><span class="o">=</span><span class="s">&quot;dynamics&quot;</span><span class="p">,</span> <span class="n">initial_m</span><span class="o">=</span><span class="n">relaxed_m_file</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span>
               <span class="n">j</span><span class="o">=</span><span class="mf">0.1e12</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">,</span> <span class="n">do</span><span class="o">=</span><span class="n">do</span><span class="p">,</span> <span class="n">stopping_dm_dt</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>After importing the required modules, we define some variables such as
the length of the cylinder, <tt class="docutils literal"><span class="pre">l</span></tt>; the name of the file where to put
the relaxed magnetisation, <tt class="docutils literal"><span class="pre">relaxed_m_file</span></tt>; the name of the mesh,
<tt class="docutils literal"><span class="pre">mesh_name</span></tt>; its unit length, <tt class="docutils literal"><span class="pre">mesh_unit</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">l</span> <span class="o">=</span> <span class="mf">30.0</span>                        <span class="c"># The nanopillar thickness is 30 nm</span>
<span class="n">hl</span> <span class="o">=</span> <span class="n">l</span><span class="o">/</span><span class="mi">2</span>                        <span class="c"># hl is half the nanopillar thickness</span>
<span class="n">relaxed_m_file</span> <span class="o">=</span> <span class="s">&quot;relaxed_m.h5&quot;</span> <span class="c"># File containing the relaxed magnetisation</span>
<span class="n">mesh_name</span> <span class="o">=</span> <span class="s">&quot;l030.nmesh.h5&quot;</span>     <span class="c"># Mesh name</span>
<span class="n">mesh_unit</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">)</span>       <span class="c"># Unit length for space used by the mesh</span>
</pre></div>
</div>
<p>These quantities are used later in the script. For example, knowing
the length of the nanopillar is necessary in order to set a proper
initial magnetisation for the relaxation. By making this a parameter
at the top of the program, we can change it there (if we wan to study
the same system for a different l), and just run the script again.</p>
<p>We define the function <tt class="docutils literal"><span class="pre">run_simulation</span></tt>: we teach Python how to run
a simulation given some parameters, such as the initial magnetisation,
the damping, the current density, etc.  The function is defined
starting with the line:</p>
<div class="highlight-python"><pre>def run_simulation(sim_name, initial_m, damping, stopping_dm_dt,
                   j, P=0.0, save=[], do=[], do_demag=True):</pre>
</div>
<p>The arguments of the function (the names inside the parenthesis) are
those parameters which must be choosen differently in part I and part II.
For example, we decided to make the current density <tt class="docutils literal"><span class="pre">j</span></tt> an argument
for the function <tt class="docutils literal"><span class="pre">run_simulation</span></tt>, because in part I <tt class="docutils literal"><span class="pre">j</span></tt> must be set
to zero, while in part II it must be set to some value greater than zero.
On the other hand, the saturation magnetisation does not appear
in the argument list of the function, since it has the same value
both in part I and part II.</p>
<p>A remark about the Python syntax: arguments such as <tt class="docutils literal"><span class="pre">sim_name</span></tt>
must be specified explicitly when using the function <tt class="docutils literal"><span class="pre">run_simulation</span></tt>,
while arguments such as <tt class="docutils literal"><span class="pre">P=0</span></tt> have a default value (0.0 in this case)
and the user may omit them, meaning that Python will then use
the default values.</p>
<p>We skip the explanation of the body of the function and focus on the code which
follows it. We&#8217;ll return later on the implementation of <tt class="docutils literal"><span class="pre">run_simulation</span></tt>.
For now, the user should keep in mind that <tt class="docutils literal"><span class="pre">run_simulation</span></tt> just runs
one distinct micromagnetic simulation every time it is called (and what simulation this is will depend on the parameters given to the function). The function returns
the simulation object which it created.</p>
<p>We now comment the code which follows the function <tt class="docutils literal"><span class="pre">run_simulation</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># If the initial magnetisation has not been calculated and saved into</span>
<span class="c"># the file relaxed_m_file, then do it now!</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">relaxed_m_file</span><span class="p">):</span>
  <span class="c"># Initial direction for the magnetisation</span>
  <span class="k">def</span> <span class="nf">m0</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
      <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">pos</span>
      <span class="n">tmp</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">SI</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mesh_unit</span><span class="o">*</span><span class="n">hl</span><span class="p">))))</span>
      <span class="n">angle</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">tmp</span>
      <span class="k">return</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">]</span>

  <span class="n">save</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;stage_end&#39;</span><span class="p">)),</span>
          <span class="p">(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">5e-12</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">)))]</span>

  <span class="n">sim</span> <span class="o">=</span> <span class="n">run_simulation</span><span class="p">(</span><span class="n">sim_name</span><span class="o">=</span><span class="s">&quot;relaxation&quot;</span><span class="p">,</span> <span class="n">initial_m</span><span class="o">=</span><span class="n">m0</span><span class="p">,</span>
                       <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">,</span>
                       <span class="n">stopping_dm_dt</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="n">degrees_per_ns</span><span class="p">)</span>
  <span class="n">sim</span><span class="o">.</span><span class="n">save_restart_file</span><span class="p">(</span><span class="n">relaxed_m_file</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">sim</span>
</pre></div>
</div>
<p>This piece of code carries out part I of the simulation: it relaxes
the system starting from a sensible initial guess for the
magnetisation and saves the relaxed magnetisation configuration so
that it can be used in part II.</p>
<p>In more detail, it starts by checking (using the function
<tt class="docutils literal"><span class="pre">os.path.exists</span></tt>) if a file containing the initial magnetisation
exists. If this is not the case, then the following indented block
will be executed, which computes and saves this initial
magnetisation. If the file exists, the whole indented block is
skipped, and we go straight to part II of the calculation.</p>
<p>In order to compute the relaxed configuration, an initial guess <tt class="docutils literal"><span class="pre">m0</span></tt>
for the magnetisation is defined.  Such magnetisation linearly rotates
from left to right as the position changes from the left face to the
right face of the cylinder.  Here <tt class="docutils literal"><span class="pre">x</span></tt> is the x coordinate of the
position vector <tt class="docutils literal"><span class="pre">p</span></tt> and <tt class="docutils literal"><span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">min(1.0,</span> <span class="pre">max(-1.0,</span> <span class="pre">float(SI(x,</span>
<span class="pre">&quot;m&quot;)/(mesh_unit*hl))))</span></tt> is a continuous function which changes
linearly from -1 to 1 when going from the left to the right face,
keeping constant outside the cylinder.</p>
<p>In the code above we also define the variable <tt class="docutils literal"><span class="pre">save</span></tt> which is used
to specify when and what should be saved to disk. Here we save the
fields before and after the relaxation and save the averages every 5
picoseconds.</p>
<p>We then call the <tt class="docutils literal"><span class="pre">run_simulation</span></tt> function we defined above to relax
the magnetisation. This function returns the simulation object
<tt class="docutils literal"><span class="pre">sim</span></tt>, which we use to save the magnetisation using the
<a class="reference internal" href="manual.html#save-restart-file"><em>save_restart_file</em></a> function.</p>
<p>Once this is done, we delete the simulation object, releasing resources
(memory) we have used for the simulation of part I.  Note that for
the relaxation, we use <tt class="docutils literal"><span class="pre">j=0.0</span></tt> (zero current density), <tt class="docutils literal"><span class="pre">damping=0.5</span></tt>
(fast damping, to reach convergence quickly) and
<tt class="docutils literal"><span class="pre">stopping_dm_dt=1.0*degrees_per_ns</span></tt> (this means that the simulation
should end when the magnetisation moves slower than 1 degree per
nanosecond).</p>
<p>The following part of the script deals with part II, the computation
of the current-driven dynamics:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Now we simulate the magnetisation dynamics</span>
<span class="n">save</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">9e-12</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">)))]</span>
<span class="n">do</span>   <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;exit&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">6e-9</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">)))]</span>

<span class="n">run_simulation</span><span class="p">(</span><span class="n">sim_name</span><span class="o">=</span><span class="s">&quot;dynamics&quot;</span><span class="p">,</span>
               <span class="n">initial_m</span><span class="o">=</span><span class="n">relaxed_m_file</span><span class="p">,</span>
               <span class="n">damping</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span>
               <span class="n">j</span><span class="o">=</span><span class="mf">0.1e12</span><span class="p">,</span>
               <span class="n">P</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
               <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">,</span>
               <span class="n">do</span><span class="o">=</span><span class="n">do</span><span class="p">,</span>
               <span class="n">stopping_dm_dt</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we decide to save the averages every 9 picoseconds and exit the
simulation after 6 nanoseconds. We use <tt class="docutils literal"><span class="pre">stopping_dm_dt=0.0</span></tt> to
disable the convergence check (here we just want to simulate for a
fixed amount of time). We also use full spin polarisation, <tt class="docutils literal"><span class="pre">P=1.0</span></tt>,
we apply a current density of <tt class="docutils literal"><span class="pre">j=0.1e12</span> <span class="pre">A/m^2</span></tt> and use a realistic
damping parameter for Permalloy, <tt class="docutils literal"><span class="pre">damping=0.02</span></tt>. For the initial
magnetisation we pass the name of the file where the relaxed
magnetisation was saved in part I and we specify a simulation name
<tt class="docutils literal"><span class="pre">sim_name=&quot;dynamics&quot;</span></tt> which is different from the one used for the
relaxation (which was <tt class="docutils literal"><span class="pre">sim_name=&quot;relaxation&quot;</span></tt>). The simulation name
will decide the prefix of any filenames that are being created when
saving data. (If the simulation name is not specified, the name of the
script file is used.)</p>
<p>We now return to discuss the function <tt class="docutils literal"><span class="pre">run_simulation</span></tt> and see how
it carries out the actual simulations. First, the function defines the
material:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Define the material</span>
<span class="n">mat</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s">&quot;mat&quot;</span><span class="p">,</span>
        <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.8e6</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
        <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
        <span class="n">llg_damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>
        <span class="n">llg_xi</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.01</span><span class="p">),</span>
        <span class="n">llg_polarisation</span><span class="o">=</span><span class="n">P</span><span class="p">)</span>
</pre></div>
</div>
<p>It uses the variable <tt class="docutils literal"><span class="pre">P</span></tt> which is passed as an argument to the function.
Then the simulation object is created and the mesh is loaded:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Create the simulation object and load the mesh</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">sim_name</span><span class="p">,</span> <span class="n">do_demag</span><span class="o">=</span><span class="n">do_demag</span><span class="p">)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="n">mesh_name</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;np&quot;</span><span class="p">,</span> <span class="n">mat</span><span class="p">)],</span> <span class="n">unit_length</span><span class="o">=</span><span class="n">mesh_unit</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">sim_name</span></tt> is passed to the Simulation object,
allowing the user to use different prefixes for the output files
of the simulation. For example, if <tt class="docutils literal"><span class="pre">sim_name</span> <span class="pre">=</span> <span class="pre">&quot;relaxation&quot;</span></tt>,
then the output files produced when saving the fields or their averages
to disk will have names starting with the prefix <tt class="docutils literal"><span class="pre">relaxation_</span></tt>.
On the other hand, if <tt class="docutils literal"><span class="pre">sim_name</span> <span class="pre">=</span> <span class="pre">&quot;dynamics&quot;</span></tt>, the names of these files
will all start with the prefix <tt class="docutils literal"><span class="pre">dynamics_</span></tt>.</p>
<p>Using different simulation names allows us to save the data of part I
and part II in different independent files.  The function continues
with the code above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Set the pinning at the left and right face of the nanopillar</span>
<span class="k">def</span> <span class="nf">pinning</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
  <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">p</span>
  <span class="n">tmp</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">SI</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mesh_unit</span><span class="o">*</span><span class="n">hl</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.999</span><span class="p">:</span>
    <span class="k">return</span> <span class="mf">0.0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="mf">1.0</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_pinning</span><span class="p">(</span><span class="n">pinning</span><span class="p">)</span>
</pre></div>
</div>
<p>which is used to pin the magnetisation at the left and right faces of
the cylinder.  Note here that <tt class="docutils literal"><span class="pre">x</span></tt> is the x component of the position
of the mesh site and that:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tmp</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">SI</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;m&quot;</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mesh_unit</span><span class="o">*</span><span class="n">hl</span><span class="p">))</span>
</pre></div>
</div>
<p>is equal to -1 at the right face, and to +1 at the left face.
We then set the magnetisation. If <tt class="docutils literal"><span class="pre">initial_m</span></tt> is a string,
then we assume it is the name of the file and load the magnetisation
with the method <tt class="docutils literal"><span class="pre">load_m_from_h5file</span></tt>, otherwise we assume it is just
a function and set the magnetisation in the usual way, using the method
<tt class="docutils literal"><span class="pre">set_m</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">initial_m</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>            <span class="c"># Set the initial magnetisation</span>
  <span class="n">sim</span><span class="o">.</span><span class="n">load_m_from_h5file</span><span class="p">(</span><span class="n">initial_m</span><span class="p">)</span>   <span class="c"># a) from file if a string is provided</span>
<span class="k">else</span><span class="p">:</span>
  <span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">(</span><span class="n">initial_m</span><span class="p">)</span>                <span class="c"># b) from function/vector, otherwise</span>
</pre></div>
</div>
<p>We then set the current density along the x direction
(only if <tt class="docutils literal"><span class="pre">j</span></tt> is not zero):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>                          <span class="c"># Set the current, if needed</span>
  <span class="n">sim</span><span class="o">.</span><span class="n">set_current_density</span><span class="p">([</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="s">&quot;A/m^2&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>Finally, we set tolerances, the stopping criterion and launch the simulation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Set additional parameters for the time-integration and run the simulation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="n">stopping_dm_dt</span><span class="o">=</span><span class="n">stopping_dm_dt</span><span class="p">,</span>
               <span class="n">ts_rel_tol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span> <span class="n">ts_abs_tol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">([</span><span class="bp">None</span><span class="p">],</span> <span class="n">save</span><span class="o">=</span><span class="n">save</span><span class="p">,</span> <span class="n">do</span><span class="o">=</span><span class="n">do</span><span class="p">)</span>
<span class="k">return</span> <span class="n">sim</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="manual.html#relax"><em>relax</em></a> function carries out the simulation, taking into account the stopping criterion and <tt class="docutils literal"><span class="pre">save</span></tt> and <tt class="docutils literal"><span class="pre">do</span></tt> actions. Finally, the function returns the simulation object which it created.</p>
</div>
<div class="section" id="results-precession-of-the-magnetisation">
<h4>Results: precession of the magnetisation<a class="headerlink" href="manual.html#results-precession-of-the-magnetisation" title="Permalink to this headline">¶</a></h4>
<p>We launch the script with:</p>
<div class="highlight-python"><pre>$ nsim stt_nanopillar.py</pre>
</div>
<p>The script runs both part I (output files starting with <tt class="docutils literal"><span class="pre">relaxation_</span></tt>)
and part II (output files starting with <tt class="docutils literal"><span class="pre">dynamics_</span></tt>).
The relaxed magnetisation can be extracted and saved into a vtk file using
the command <tt class="docutils literal"><span class="pre">nmagpp</span> <span class="pre">relaxation</span> <span class="pre">--vtk=m.vtk</span></tt>. MayaVi can then be used
to obtain the following picture:</p>
<div class="figure align-center">
<img alt="zhangli2-1" src="_images/m-end1.png" />
</div>
<p>We can now take a look at the results obtained for the dynamics.
The average magnetisation as a function of time can be extracted
using:</p>
<div class="highlight-python"><pre>ncol dynamics time M_mat_0 M_mat_1 M_mat_2 &gt; m_of_t.dat</pre>
</div>
<p>We can use the following gnuplot script:</p>
<div class="highlight-python"><pre>set term postscript color eps enhanced solid
set out "m_of_t.eps"

set xlabel "time (ns)"
set ylabel "average magnetisation (10^6 A/m)"
plot [0:6] \
  "m_of_t.dat" u ($1*1e9):($2/1e6) t "&lt;M_x&gt;" w l, \
  "" u ($1*1e9):($3/1e6) t "&lt;M_y&gt;" w l, \
  "" u ($1*1e9):($4/1e6) t "&lt;M_z&gt;" w l

</pre>
</div>
<p>and obtain the following graph:</p>
<div class="figure align-center">
<img alt="zhangli2-2" src="_images/m_of_t1.png" />
</div>
<p>The sinusoidal dependence of the y and z magnetisation components suggests
that the magnetisation rotates around the nanopillar axis with a frequency
which increases to approach its maximum value.</p>
<p>A more detailed discussion of results and interpretation is provided
in the publications <a class="footnote-reference" href="manual.html#franchin2008a" id="id5">[1]</a> and <a class="footnote-reference" href="manual.html#franchin2008b" id="id6">[2]</a> mentioned in section <a class="reference internal" href="manual.html#example-current-driven-magnetisation-precession-in-nanopillars"><em>Example: Current-driven magnetisation precession in nanopillars</em></a>.</p>
</div>
</div>
<span id="document-mesh_distortion/doc"></span><div class="section" id="mesh-distortion-for-edge-roughness-simulation">
<span id="id1"></span><h3>Mesh distortion for edge roughness simulation<a class="headerlink" href="manual.html#mesh-distortion-for-edge-roughness-simulation" title="Permalink to this headline">¶</a></h3>
<p>The meshes used in micromagnetic simulations usually represent
idealized geometries (for example, a nanowire might be modeled using a
completely smooth cuboid mesh).  Real-world materials, on the other
hand, possess imperfections on various scales caused by fabrication
processes (e.g., electron beam lithography or sputter
deposition). This can potentially have a significant impact on the
magnetization dynamics.  The advantage of finite element-based
simulations is that such effects can be simulated (at least
qualitatively) by distorting the mesh in a suitable way. <a class="reference internal" href="manual.html#nmeshpp"><em>nmeshpp</em></a>
provides a means of distorting a given mesh in order to imitate
roughness so that the resulting effects on simulations can be
explored. Note that at the moment only edge roughness is supported.
We first present an example in the following section and then go into
the details of the command line interface and how the distortion
process works.</p>
<p>The appropriate reference for this mesh distortion is Albert <em>et al</em> <a class="footnote-reference" href="manual.html#albert2012" id="id2">[2]</a>,
where the method is described and used to study domain walll motion in
the presence of edge roughness.</p>
<div class="section" id="example">
<span id="id3"></span><h4>Example<a class="headerlink" href="manual.html#example" title="Permalink to this headline">¶</a></h4>
<p>Consider a nanowire with dimensions 800nm x 20nm x 5nm (for
convenience we provide the corresponding mesh in the file
<a class="reference download internal" href="_downloads/nanowire_800x20x55.nmesh"><tt class="xref download docutils literal"><span class="pre">nanowire_800x20x5.nmesh</span></tt></a>). <a class="footnote-reference" href="manual.html#examesh" id="id4">[1]</a></p>
<p>We distort this mesh using the following command:</p>
<div class="highlight-python"><pre>nmeshpp --distort 0.4 --correlation-length 2.0 --seed 23 nanowire_800x20x5.nmesh \
          nanowire_800x20x5_distorted.nmesh</pre>
</div>
<p>Intuitively, what this command does is to randomly displace the
&#8220;front&#8221; and &#8220;rear&#8221; nodes of the mesh and to stretch/shrink the middle
bits accordingly. The details of this process, as well as meaning of
all the command line switches, are explained in the next section. The
original and distorted mesh look like this (only part of each mesh
is shown):</p>
<img alt="_images/smooth_wire_3D_view5.png" class="align-center" src="_images/smooth_wire_3D_view5.png" style="width: 500px; height: 200px;" />
<img alt="_images/rough_wire_3D_view5.png" class="align-center" src="_images/rough_wire_3D_view5.png" style="width: 500px; height: 200px;" />
<p>This figure shows a smooth nanowire (top), and then the same mesh after having been distorted using the nmesh command shown above. The figure is taken from <a class="footnote-reference" href="manual.html#albert2012" id="id5">[2]</a>.</p>
<table class="docutils footnote" frame="void" id="examesh" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id4">[1]</a></td><td>The mesh file for the nanowire was produced using the <tt class="docutils literal"><span class="pre">examesh</span></tt> tool, which is included in the nmag distribution in the directory <tt class="docutils literal"><span class="pre">utils/cubicmesh/</span></tt> (note that it needs to be compiled before it can be used - just <tt class="docutils literal"><span class="pre">cd</span></tt> into this directory and type <tt class="docutils literal"><span class="pre">make</span></tt>). The exact command used to produce the mesh file was <tt class="docutils literal"><span class="pre">examesh</span> <span class="pre">nanowire_800x20x5.nmesh,800:450,20:15,5:3</span></tt>.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="details-and-command-line-options">
<span id="id6"></span><h4>Details and command line options<a class="headerlink" href="manual.html#details-and-command-line-options" title="Permalink to this headline">¶</a></h4>
<p>Preliminary remark: As mentioned above, <tt class="docutils literal"><span class="pre">nmeshpp</span></tt> can only produce
edge roughness at the moment. There is a slight chance that the user
interface might change in the future when more functionality (such as
surface roughness) is added.</p>
<p>In this section we go into the details of the distortion process and
explain the relevant command line options. The general usage is:</p>
<div class="highlight-python"><pre>nmeshpp --front-rear-axis [X|Y|Z] --distort-along-axis [X|Y|Z] --distort D \
        --correlation-length C --seed S mesh_orig.nmesh mesh_distorted.nmesh</pre>
</div>
<p>Only <tt class="docutils literal"><span class="pre">--distort</span></tt>, <tt class="docutils literal"><span class="pre">--correlation-length</span></tt> and the name of the input
mesh are required arguments.</p>
<p>The overall distortion process works as follows. First, the surface
nodes of the mesh are divided into &#8220;front&#8221; and &#8220;rear&#8221;, depending on
which side of the mesh they lie on. By default, this distinction is
based on their y-coordinate (as in the example in the previous
section), but this can be changed using the option
<tt class="docutils literal"><span class="pre">--front-rear-axis</span></tt>. Next, a univariate &#8220;distortion function&#8221;
<tt class="docutils literal"><span class="pre">f(x)</span></tt> is constructed based on the given command line parameters
(the details of this process will be explained in a moment). This
function specifies the amount by which each <em>front</em> node is displaced in
y-direction (as a function of the x-coordinate of the
node). Analogously, the <em>rear</em> nodes are displaced using a second,
independently constructed distortion function <tt class="docutils literal"><span class="pre">g(x)</span></tt> (so that both
sides of the mesh are distorted differently). The intermediate parts
of the mesh are stretched to fit nicely between the new distorted
sides.</p>
<p>The whole procedure is illustrated in the following picture (see
<a class="footnote-reference" href="manual.html#albert2012" id="id7">[2]</a>). It shows a top view (i.e., along the z-axis) of the
rear part of the nanowire from the previous section. The left hand
side shows the original mesh, the right hand side shows the mesh after
distortion with the function <tt class="docutils literal"><span class="pre">g</span></tt>, which is depicted in the
middle. Note that the contour of the distorted mesh follows the
outline of <tt class="docutils literal"><span class="pre">g</span></tt>.</p>
<img alt="_images/steps_illustrated5.png" class="align-center" src="_images/steps_illustrated5.png" style="width: 1194px; height: 149px;" />
<p>The distortion functions <tt class="docutils literal"><span class="pre">f</span></tt> and <tt class="docutils literal"><span class="pre">g</span></tt> are constructed as
follows. First we pick equidistant nodes <tt class="docutils literal"><span class="pre">x_i</span></tt> along the x-axis
(note that these are just auxiliary entities and completely
independent from the nodes of the mesh). Then random values <tt class="docutils literal"><span class="pre">f(x_i)</span></tt>
and <tt class="docutils literal"><span class="pre">g(x_i)</span></tt> are assigned to each such node, chosen from a normal
distribution with mean 0 and a certain standard deviation that
determines the &#8220;amplitude&#8221; of the roughness. Finally, these random
values are interpolated smoothly to obtain the continuous distortion
functions <tt class="docutils literal"><span class="pre">f(x)</span></tt> and <tt class="docutils literal"><span class="pre">g(x)</span></tt>. In order to make the randomization
reproducible, it is possible to specify a seed for the internal random
number generator (by passing any integer value as an argument to
<tt class="docutils literal"><span class="pre">--seed</span></tt>). Otherwise the output mesh is different each time because
the random number generator is seeded using the system time or
something similar.</p>
<p>The reason why we need these distortion functions at all and can&#8217;t
just randomly displace each mesh node individually is because then the
result would strongly depend on the mesh spacing and the overall
quality of the mesh. However, since we usually want roughness on a
scale independent from the mesh spacing, we need some kind of
correlation between the displacements of adjacent mesh nodes, hence
the need for the distortion functions.</p>
<p>The parameters in the construction of <tt class="docutils literal"><span class="pre">f</span></tt> and <tt class="docutils literal"><span class="pre">g</span></tt> are:</p>
<blockquote>
<div><ul class="simple">
<li>the distance between the nodes <tt class="docutils literal"><span class="pre">x_i</span></tt>, which can be controlled
with the flag <tt class="docutils literal"><span class="pre">--correlation-length</span></tt>,</li>
<li>the standard deviation of the underlying normal distribution,
which must be specified using the command line switch <tt class="docutils literal"><span class="pre">-d</span></tt>, or
<tt class="docutils literal"><span class="pre">--distort</span></tt>.</li>
</ul>
</div></blockquote>
<p>Note that depending on which edges of the mesh the roughness should be
applied to (and on the way the mesh is oriented in the coordinate
system), it may be necessary to apply the distortion in a direction
different from the y-direction and also to consider <tt class="docutils literal"><span class="pre">f</span></tt> and <tt class="docutils literal"><span class="pre">g</span></tt> as
functions of a different input axis (distinct from the x-axis). The
first can again be controlled using the option <tt class="docutils literal"><span class="pre">--front-rear-axis</span></tt>,
which was already mentioned above. The second can be adjusted using
<tt class="docutils literal"><span class="pre">--distort-along-axis</span></tt>. For instance, if the roughness should
displace the nodes in z-direction and if the amount of displacement
should be a function of their y-coordinates, the command line
arguments would be <tt class="docutils literal"><span class="pre">--front-rear-axis</span> <span class="pre">Z</span> <span class="pre">--distort-along-axis</span> <span class="pre">Y</span></tt>.</p>
<table class="docutils footnote" frame="void" id="albert2012" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="manual.html#id2">1</a>, <a class="fn-backref" href="manual.html#id5">2</a>, <a class="fn-backref" href="manual.html#id7">3</a>)</em> Maximilian Albert, Matteo Franchin, Thomas Fischbacher, Guido Meier, and Hans Fangohr, <em>Domain wall motion in perpendicular anisotropy nanowires with edge roughness</em>, <a class="reference external" href="http://iopscience.iop.org/0953-8984/24/2/024219">J. Phys.: Condens. Matter 24 , 024219 (14 pages) (2012)</a> (<a class="reference external" href="http://www.soton.ac.uk/~fangohr/publications/postprint/Albert_etal_JPhysCondMat_2011.pdf">postprint pdf</a>)</td></tr>
</tbody>
</table>
</div>
</div>
<span id="document-example_phi_BEM_hlib/doc"></span><div class="section" id="compression-of-the-boundary-element-matrix-using-hlib">
<span id="id1"></span><h3>Compression of the Boundary Element Matrix using HLib<a class="headerlink" href="manual.html#compression-of-the-boundary-element-matrix-using-hlib" title="Permalink to this headline">¶</a></h3>
<div class="section" id="hierarchical-matrices-in-micromagnetism">
<span id="id2"></span><h4>Hierarchical Matrices in Micromagnetism<a class="headerlink" href="manual.html#hierarchical-matrices-in-micromagnetism" title="Permalink to this headline">¶</a></h4>
<p>Nmag uses the hybrid finite element method/boundary element method
(hybrid FEM/BEM) to compute the demagnetisation field (as does
<a class="reference external" href="http://www.magpar.net/">Magpar</a>). Not using this method, one would have to discretise a large
part of space arround the magnetic structure (ideally all
space). Using the hybrid FEM/BEM method, it is only necessary to
discretise (and solve the equations for the demag field on that
discretisation) those parts of space that are occupied by magnetic
material.</p>
<p>A disadvantage of the hybrid FEM/BEM method is that it involves the
assembly of a dense boundary element matrix <strong>B</strong>, whose number of
elements scales quadratically with the number of surface nodes N of
our finite element mesh, i.e. the matrix <strong>B</strong> has as many rows as there are
surface nodes N in the mesh (and also as many columns).</p>
<p>This is in particular an issue when studying flat structures such as
thin films. For example, imagine we model a thin film of side lengths
100 nm x 100 nm x 2nm. If we decide to double the side lengths to 200
nm x 200 nm x 2nm, then this roughly corresponds to an increase of
surface node numbers N by a factor of 4. The matrix <strong>B</strong> will then
grow in size by a factor 4^2=16 due to the doubling of the two side
lengths by a factor of 2. In practice, the memory requirements of the
matrix <strong>B</strong> often limit the size of a structure that can be modelled.</p>
<p>In order to improve the efficiency of the hybrid FEM/BEM, one can
employ techniques which involve some kind of approximation of <strong>B</strong>,
for example using hierarchical matrices.</p>
<p>The basic <a class="reference external" href="http://www.mis.mpg.de/publications/other-series/ln/lecturenote-2103.html">idea</a>
is to approximate submatrices of <strong>B</strong> by a data-sparse approximation
where possible (within user-provided tolerance margins).  In general
the complexity of the storage requirements and execution time of
simple operations like the matrix-vector product scale as O(N*log(N)),
as compared to the quadratical costs N^2 using the standard matrix
representation. For the use of HLib hierarchical matrices in
micromagnetic simulations we are often mostly interested in the their
reduced <em>memory</em> requirements.</p>
<p>The library <a class="reference external" href="http://www.hlib.org">HLib</a> contains implementations of this hierarchical matrix
methodology, and can be used with Nmag in order to run micromagnetic
simulations in a more memory efficient way (see for example <a class="reference external" href="http://link.aip.org/link/?JAPIAU/105/07D542/1">Knittel
et al 105, 07D542 (2009)</a>, <a class="reference external" href="http://www.soton.ac.uk/~fangohr/publications/postprint/Knittel_etal_JAP_105_07D542_2009.pdf">postprint pdf</a>).
.</p>
</div>
<div class="section" id="installation-of-hlib">
<span id="id3"></span><h4>Installation of HLib<a class="headerlink" href="manual.html#installation-of-hlib" title="Permalink to this headline">¶</a></h4>
<p>In order to be able to use the <a class="reference external" href="http://www.hlib.org">HLib</a> library and to obtain the HLib source
code, you have to apply for an HLib licence as explained on
<a class="reference external" href="http://hlib.org/license.html">http://hlib.org/license.html</a>.</p>
<p>Once the HLib authors grant a licence, they will send their HLib tarball. Nmag will have to be compiled from source (see <a class="reference external" href="../../../0.1/install/install_a.html">install from source</a>) in the presence of this tarball to make use of the HLib matrix compression. (Nmag will compile happily in the absence of this file, and in that case the boundary element matrix is stored &#8216;in the normal way&#8217; as a full matrix.)</p>
<p>We describe the required steps for this in detail.  We assume you
downloaded the HLib tarball and the Nmag tarball in your home
directory <tt class="docutils literal"><span class="pre">~/</span></tt> (but any other subdirectory will work fine). Then, if
you issue a <tt class="docutils literal"><span class="pre">ls</span></tt> command, you get something like:</p>
<div class="highlight-python"><pre>me@mymachine:~/$ ls
HLib-1.3p19.tar.gz  nmag-0.1-all.tar.gz</pre>
</div>
<p>You can now untar the nmag tarball and enter the newly created directory:</p>
<div class="highlight-python"><pre>me@mymachine:~/$ tar xzvf nmag-0.1-all.tar.gz
me@mymachine:~/$ cd nmag-0.1</pre>
</div>
<p>Note that in this particular example we assume the Nmag version to be 0.1.
For later versions, you&#8217;ll have to change the tarball name and the paths
accordingly (e.g. <tt class="docutils literal"><span class="pre">nmag-X.Y.Z</span></tt> for version <tt class="docutils literal"><span class="pre">X.Y.Z</span></tt>).
Inside the directory <tt class="docutils literal"><span class="pre">nmag-0.1</span></tt> there is a directory called
<tt class="docutils literal"><span class="pre">hlib-pkg</span></tt> and we need to copy (or move) the HLib tarball into this directory:</p>
<div class="highlight-python"><pre>me@mymachine:~/nmag-0.1$ cp HLib-1.3p19.tar.gz hlib-pkg/</pre>
</div>
<p>You can now compile Nmag with HLib support in the usual way:</p>
<div class="highlight-python"><pre>me@mymachine:~/nmag-0.1$ make</pre>
</div>
<p>The build system should recognise that the <tt class="docutils literal"><span class="pre">hlib-pkg</span></tt> directory contains
a tarball and should prompt you asking what to do:</p>
<div class="highlight-python"><pre>me@mymachine:~/nmag-0.1$ make
bash ./patches/hlib/hlib-untar.sh ./hlib-pkg HLib-1.3p19.tar.gz &amp;&amp; \
          rm -f .deps_hlib_patch &amp;&amp; make .deps_hlib_install; true
_____________________________________________________
 It seems you want to compile Nmag with HLib support
 I'll need your confirmation in order to proceed...

I found ./hlib-pkg/HLib-1.3p19.tar.gz
Is this the HLib tarball you want to use? (yes/no) yes</pre>
</div>
<p>Type <tt class="docutils literal"><span class="pre">yes</span></tt> and <tt class="docutils literal"><span class="pre">ENTER</span></tt>. The build system should untar the HLib tarball, it
should patch it (HLib needs to be patched in order to be usable by Nmag)
and it should install it in the right location with respect to the Nmag
libraries. If all goes well, you should get an installation of Nmag which is
capable of using HLib for the compression of the BEM matrix.</p>
<p>As you see, the only additional step which is required with respect to the
normal procedure for compiling Nmag from source, is to put the HLib tarball
inside the directory <tt class="docutils literal"><span class="pre">nmag-0.1/hlib-pkg</span></tt>.</p>
<p>The current nmag release requires Hlib version 1.3p19, to support HLib
matrix compression.</p>
</div>
<div class="section" id="testing-the-hlib-bem-matrix-compression">
<span id="id4"></span><h4>Testing the HLib BEM Matrix compression<a class="headerlink" href="manual.html#testing-the-hlib-bem-matrix-compression" title="Permalink to this headline">¶</a></h4>
<p>There is a test target <tt class="docutils literal"><span class="pre">make</span> <span class="pre">checkhlib</span></tt> which tests whether a demag
field can be computed using the HLib and compares this with the result
of the same calculation using a full BEM. If the deviations become large,
the test will fail. To run the test, do</p>
<blockquote>
<div><a class="reference external" href="mailto:me&#37;&#52;&#48;mymachine">me<span>&#64;</span>mymachine</a>:~/nmag-0.1$ make checkhlib</div></blockquote>
<p>The test should take less than 5 minutes. If it passes, then it
appears that the hlib is used, and produces quantitatively appropriate
approximations of the true solution.</p>
</div>
<div class="section" id="using-hlib-example-1-demagnetisation-field-of-a-sphere">
<h4>Using HLib example 1: Demagnetisation Field of a Sphere<a class="headerlink" href="manual.html#using-hlib-example-1-demagnetisation-field-of-a-sphere" title="Permalink to this headline">¶</a></h4>
<p>The properties of a hierarchical matrix depend much on the settings of
different parameters and on the particular algorithm used to create
the low-rank approximations.  In Nmag, we only use the HCA II
algorithm, which seems to be the most reliable amongst the commonly
used algorithms, being still very efficient (see for example <a class="reference external" href="http://link.aip.org/link/?JAPIAU/105/07D542/1">Knittel et al 105,
07D542 (2009)</a>,
<a class="reference external" href="http://www.soton.ac.uk/~fangohr/publications/postprint/Knittel_etal_JAP_105_07D542_2009.pdf">postprint pdf</a>).</p>
<p>The performance and accuracy of the HCA II algorithm can be tuned by providing
a number of parameters, which are collected inside a <a class="reference internal" href="manual.html#hmatrixsetup"><em>HMatrixSetup</em></a> object.
A default <tt class="docutils literal"><span class="pre">HMatrixSetup</span></tt> object is provided, where a reasonable choice of
these parameters is made. The default parameters can be overriden by users.</p>
<p>We point the reader to the documentation of the <a class="reference internal" href="manual.html#hmatrixsetup"><em>HMatrixSetup</em></a> class
for a list and description of all avaliable parameters. The next
example shows how to use HLib with the default values for the setup of
the BEM matrix.</p>
<div class="section" id="using-hlib-with-default-parameters">
<span id="id5"></span><h5>Using HLib with default parameters<a class="headerlink" href="manual.html#using-hlib-with-default-parameters" title="Permalink to this headline">¶</a></h5>
<p>The Nmag script <a class="reference download internal" href="_downloads/sphere_hlib.py"><tt class="xref download docutils literal"><span class="pre">sphere_hlib.py</span></tt></a> shows how Nmag can be used in order to compute
the demagnetisation field within a sphere with a radius of 50 nm.</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span>

<span class="c"># When creating the simulation object, specify that the BEM hmatrix should be</span>
<span class="c"># set up by using the default parameters.</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">phi_BEM</span><span class="o">=</span><span class="n">nmag</span><span class="o">.</span><span class="n">default_hmatrix_setup</span><span class="p">)</span>

<span class="c"># Specify magnetic material, parameters chosen as in example 1</span>
<span class="n">Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                      <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e6</span><span class="p">,</span> <span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                      <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">))</span>

<span class="c"># Load the mesh</span>
<span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&#39;sphere.nmesh.h5&#39;</span><span class="p">,</span>
              <span class="p">[(</span><span class="s">&#39;sphere&#39;</span><span class="p">,</span> <span class="n">Py</span><span class="p">)],</span>
              <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&#39;m&#39;</span><span class="p">))</span>

<span class="c"># Set the initial magnetisation</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="c"># Save the demagnetisation field</span>
<span class="n">sim</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;H_demag&#39;</span><span class="p">])</span>

<span class="c"># Probe the demagnetisation field at ten points within the sphere</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="mf">1e-9</span>
    <span class="n">Hdemag</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">probe_subfield_siv</span><span class="p">(</span><span class="s">&#39;H_demag&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">print</span> <span class="s">&quot;x=&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s">&quot;: H_demag = &quot;</span><span class="p">,</span> <span class="n">Hdemag</span>
</pre></div>
</div>
</div></blockquote>
<p>In this first example, we use default parameters for setting up the BEM
matrix by passing the object <tt class="docutils literal"><span class="pre">nmag.default_hmatrix_setup</span></tt> to the
<tt class="docutils literal"><span class="pre">Simulation</span></tt> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">phi_BEM</span><span class="o">=</span><span class="n">nmag</span><span class="o">.</span><span class="n">default_hmatrix_setup</span><span class="p">)</span>
</pre></div>
</div>
<p>This command specifies that the BEM matrix should be set up using the default
parameters in <tt class="docutils literal"><span class="pre">nmag.default_hmatrix_setup</span></tt>.
(The actual values of the parameters can be visualised on the screen by simply
printing the object with <tt class="docutils literal"><span class="pre">import</span> <span class="pre">nmag;</span> <span class="pre">print</span> <span class="pre">nmag.default_hmatrix_setup</span></tt>.)</p>
<p>When running the simulation <a class="reference download internal" href="_downloads/sphere_hlib.py"><tt class="xref download docutils literal"><span class="pre">sphere_hlib.py</span></tt></a> using the usual command:</p>
<div class="highlight-python"><pre>nsim sphere_hlib.py --clean,</pre>
</div>
<p>it should print out the demagnetisation field at ten points along the line
(x,0,0):</p>
<div class="highlight-python"><pre>x= -5e-09 : H_demag =  [-333060.61988567741, -16.426569556599606, -63.649046900628299]
x= -4e-09 : H_demag =  [-333061.67213255615, -17.81158234138228, -65.112039406898973]
x= -3e-09 : H_demag =  [-333062.69422596297, -19.401486521725044, -66.015626464953897]
x= -2e-09 : H_demag =  [-333062.72991753434, -20.940683675745074, -66.988296036794026]
x= -1e-09 : H_demag =  [-333061.60282647074, -22.420106762492924, -68.042400926888646]
x= 0.0 : H_demag =  [-333060.29023012909, -23.736721821840622, -68.984395930340639]
x= 1e-09 : H_demag =  [-333058.66039082204, -24.758745874347209, -69.6797361890888]
x= 2e-09 : H_demag =  [-333055.87727687479, -24.635979967196079, -70.705429412122513]
x= 3e-09 : H_demag =  [-333054.17167091055, -24.9868363963913, -73.501799477569747]
x= 4e-09 : H_demag =  [-333052.78687652596, -25.388604442091431, -76.097088958697071]
x= 5e-09 : H_demag =  [-333051.43416558538, -25.507782471847442, -77.792885797356391]</pre>
</div>
<p>As in <a class="reference internal" href="manual.html#example-1"><em>Example: Demag field in uniformly magnetised sphere</em></a> of our guided tour, we should obtain a constant
magnetic induction of about [333333,0,0] [A/m]. Deviations from that value
can be mainly ascribed to the discretisation errors of the finite
element method (rather than the error due to the approximation with
hierarchical matrices). To see this, we use <a class="reference download internal" href="_downloads/sphere_fullBEM.py"><tt class="xref download docutils literal"><span class="pre">sphere_fullBEM.py</span></tt></a> which carries out the same
calculation but uses the normal full BEM. It reports:</p>
<div class="highlight-python"><pre>x= -5e-09 : H_demag =  [-333065.71403658605, -5.2685406972238447, -55.70105442854085]
x= -4e-09 : H_demag =  [-333067.37484881631, -4.2116117445407726, -57.778611300679266]
x= -3e-09 : H_demag =  [-333068.83107133937, -3.7372238611028603, -59.825445387210245]
x= -2e-09 : H_demag =  [-333069.28217968839, -2.9635031726006642, -62.513814422201456]
x= -1e-09 : H_demag =  [-333067.6639511605, -1.5730916838594211, -66.546659227740889]
x= 0.0 : H_demag =  [-333066.04572263273, -0.18268019511817793, -70.579504033280344]
x= 1e-09 : H_demag =  [-333064.22835497675, 0.79797869001455679, -74.851480234723581]
x= 2e-09 : H_demag =  [-333060.20872696047, 2.9088218728650852, -77.0823444044496]
x= 3e-09 : H_demag =  [-333056.59267071093, 5.064110260421554, -80.187548021318634]
x= 4e-09 : H_demag =  [-333052.97641355224, 7.2199889195136837, -83.294534914159939]
x= 5e-09 : H_demag =  [-333051.27043353132, 9.4396856537516776, -85.662174893158024]</pre>
</div>
<p>This shows that the error introduced by the HLib is of the order of 10
in 333333 (in this example). Note that the y and z component
theoretically should be zero (for both calculations: with and without
HLib), and that the error we see there (of the order of 60/333333 in
the z-component) is coming from approximating the spherical shape with
tetrahedra, and approximating the magnetisation with a piecewise
linear function (not primarily from using the HLib approximation of the BEM).</p>
</div>
<div class="section" id="hlib-memory-usage">
<span id="id6"></span><h5>HLib Memory usage<a class="headerlink" href="manual.html#hlib-memory-usage" title="Permalink to this headline">¶</a></h5>
<p>Nmag will also provide information on the memory requirements for the
hierarchical matrix. First it will print to stdout (and here
exceptionally not write to the log file) the following lines to the
screen, which are each preceded by <tt class="docutils literal"><span class="pre">HLib</span></tt>:</p>
<div class="highlight-python"><pre>HLib: Memory footprint of hierarchical matrix: 10.523720 MB.
HLib: Equivalent full matrix would require: 98.273628 MB.
HLib: The compression rate is 10.71%</pre>
</div>
<p>The first line states the amount of memory required for the storage of the
hierarchical matrix, the second one states the equivalent memory requirements
when using the full boundary element matrix, and the last line gives the
corresponding compression rate. Furthermore Nmag creates the file
<cite>memory_info.dat</cite>, which in our example looks like:</p>
<div class="highlight-python"><pre>Number of surface nodes:                3589
Size of hierarchical matrix:        10.52 MB
Total size of inadmissible leaves:   1.40 MB
Total size of admissible leaves:     8.96 MB</pre>
</div>
<p>While the first two lines should be relatively self-explanatory, the third
line states the total amount of memory needed to store the matrix blocks
which cannot be approximated, while the fourth line gives the equivalent
number for the approximated matrix blocks. Additionally, one can obtain
the memory used for the hierarchical tree structure itself, by computing
the difference between the size of the hierarchical matrix and
the sum of the total sizes of the admissible and inadmissible leaves.</p>
</div>
<div class="section" id="changing-the-parameters-of-hlib">
<span id="id7"></span><h5>Changing the Parameters of HLib<a class="headerlink" href="manual.html#changing-the-parameters-of-hlib" title="Permalink to this headline">¶</a></h5>
<p>Let us assume we want to run the simulation of the last section again, but this
time we would like to reduce the time needed to assemble our hierarchical
matrix. To achieve this, we coarsen the hierarchical tree by increasing the
parameter <tt class="docutils literal"><span class="pre">nmin</span></tt> to 50, reassign the parameter <tt class="docutils literal"><span class="pre">eps_aca</span></tt> to 1e-5 in order to
decrease the accuracy of the HCA II algorithm, and reduce the accuracy of
the numerical integration by setting the parameter <tt class="docutils literal"><span class="pre">quadorder</span></tt> to 2.</p>
<p>To use non-default settings in a new script <a class="reference download internal" href="_downloads/sphere_hlib2.py"><tt class="xref download docutils literal"><span class="pre">sphere_hlib2.py</span></tt></a> we  add one line to create an <tt class="docutils literal"><span class="pre">HMatrixSetup</span></tt> object</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#create an HLib object</span>
<span class="n">hms</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">HMatrixSetup</span><span class="p">(</span><span class="n">nmin</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">eps_aca</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">quadorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>This object is then passed to the <tt class="docutils literal"><span class="pre">Simulation</span></tt> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">phi_BEM</span><span class="o">=</span><span class="n">hms</span><span class="p">)</span>
</pre></div>
</div>
<p>In order to make the time measurement you can just run the nsim command
with a preceding &#8216;time&#8217;, i.e.</p>
<div class="highlight-python"><pre>time nsim sphere_hlib2.py --clean</pre>
</div>
<p>do the same with the sphere_hlib.py script, and compare the execution times. Alternatively,
search for the string like &#8220;Populating BEM took 25.094362 seconds&#8221; in the log file/output.
The execution time of the second script should be smaller (see also <a class="reference internal" href="manual.html#using-hlib-example-2-thin-films"><em>Using HLib Example 2: Thin Films</em></a>).</p>
<p>For completeness: the Hdemag values computed with this script are:</p>
<div class="highlight-python"><pre>x= -5e-09 : H_demag =  [-333060.73884748813, -5.7471691393211453, -56.164777361260889]
x= -4e-09 : H_demag =  [-333062.34355895646, -4.6973695734449556, -58.19523338342605]
x= -3e-09 : H_demag =  [-333063.7357911733, -4.2543955018989577, -60.199068292632305]
x= -2e-09 : H_demag =  [-333064.14913635491, -3.5107100192801424, -62.841949236542568]
x= -1e-09 : H_demag =  [-333062.54691465426, -2.1473409122582736, -66.824386136704007]
x= 0.0 : H_demag =  [-333060.94469295366, -0.78397180523640564, -70.806823036865438]
x= 1e-09 : H_demag =  [-333059.14023403701, 0.15188988623380831, -75.030255790251871]
x= 2e-09 : H_demag =  [-333055.17692864774, 2.2289146769013355, -77.213961296827563]
x= 3e-09 : H_demag =  [-333051.63216875959, 4.3434799953307275, -80.273150211395659]
x= 4e-09 : H_demag =  [-333048.08718075219, 6.4586908275326955, -83.334113807086638]
x= 5e-09 : H_demag =  [-333046.47566667694, 8.6375699926922742, -85.648195356633963]</pre>
</div>
</div>
</div>
<div class="section" id="using-hlib-example-2-thin-films">
<span id="id8"></span><h4>Using HLib Example 2: Thin Films<a class="headerlink" href="manual.html#using-hlib-example-2-thin-films" title="Permalink to this headline">¶</a></h4>
<p>In this example we consider square thin films with a thickness of 10
nm (in z-direction), and a varying edge length (in x and y directions)
between 20 and 130 nm . The magnetisation within those films is
initially homogeneously aligned and points out-of-plane. We then use
Nmag&#8217;s <a class="reference internal" href="manual.html#relax"><em>relax</em></a> routine in order to evolve the magnetisation field to an
energetically (meta-)stable state.</p>
<p>In order to estimate the efficiency benefits of hierarchical matrices,
the simulations are executed twice: (i) with and (ii) without
hierarchical matrices. Optimal damping is ensured by setting the
damping constant of the LLG equation to 1. To increase the efficiency
of the relaxation the tolerance of the time-stepper has been increased
to 1e-5 (see <a class="reference internal" href="manual.html#example-tolerances"><em>Example: Timestepper tolerances</em></a>).</p>
<p>For our estimation of the efficiency we measure the time needed for
the setup of our simulation (basically the time for populating the
finite element and boundary element matrices), the time for relaxing
the system, and the memory consumption at the end of the simulation,
which should be roughly equal to the maximal value throughout the
simulation.</p>
<p>For each film size and either use of the full BEM or the approximation through hierarchical matrices, a separate nsim script file
(<a class="reference download internal" href="_downloads/thinfilm20_full.py"><tt class="xref download docutils literal"><span class="pre">thinfilm20_full.py</span></tt></a>,
<a class="reference download internal" href="_downloads/thinfilm40_full.py"><tt class="xref download docutils literal"><span class="pre">thinfilm40_full.py</span></tt></a>,
<a class="reference download internal" href="_downloads/thinfilm60_full.py"><tt class="xref download docutils literal"><span class="pre">thinfilm60_full.py</span></tt></a>, ...,
<a class="reference download internal" href="_downloads/thinfilm20_hlib.py"><tt class="xref download docutils literal"><span class="pre">thinfilm20_hlib.py</span></tt></a>, etc.)
has been written. It is important to start every simulation as a
single process (by calling <tt class="docutils literal"><span class="pre">nsim</span> <span class="pre">thinfilm20_full.py</span> <span class="pre">--clean</span></tt> etc.),
so that there are no overlaps in the memory access of different
simulations. From every script a routine <tt class="docutils literal"><span class="pre">run_simulation</span></tt> which is
imported from a local nsim module <a class="reference download internal" href="_downloads/simtools.py"><tt class="xref download docutils literal"><span class="pre">simtools.py</span></tt></a>, starts a simulation specified by
its arguments (name of the simulation, name of the mesh file, name of
hlib object in case hierarchical matrices are used, and the tolerance
for the time integrator) and returns the number of nodes of the mesh,
the simulation&#8217;s memory consumption and the setup- and relaxation
times. These values are then written to a file <tt class="docutils literal"><span class="pre">timings_hlib.dat</span></tt> or
<tt class="docutils literal"><span class="pre">timings_full.dat</span></tt>, respectively.</p>
<p>Beside extracting the information on the performance, it is also important to
check, whether simulations using the full boundary element matrix and a
hierarchical matrix approximation actually do the same, and that the simulated
behaviour is physically correct.</p>
<p>Looking at the spatially averaged magnetisation we find a very good agreement
between both simulation types (example given for the film with an edge length of
100nm):</p>
<img alt="_images/relaxation_m.png" class="align-center" src="_images/relaxation_m.png" style="width: 740px; height: 510px;" />
<p>The magnetisation field moves from its out-of-plane configuration into the plane
and relaxes into a high remanent state, which is aligned along the diagonal of the
square base. The plot below shows a 3d visualisation of the relaxed magnetisation
field (obtained with Mayavi2) for a thin film with an edge length of 130 nm.</p>
<img alt="_images/thinfilm130.png" class="align-center" src="_images/thinfilm130.png" style="width: 678px; height: 678px;" />
<p>We have run the simulations on a machine with an
<cite>AMD Athlon(tm) 64 X2 Dual Core Processor 3800+</cite>, using only one core. The
graphs below show the results of our efficiency test of hierarchical matrices.
It can be seen that the memory requirements are reduced considerably. While the
consumed memory increases (almost) linearly with the number of surface nodes <cite>N</cite>
for the calculation with hierarchical matrices, the increase is of a higher
order (O(<cite>N</cite><sup>4/3</sup>)), when using the accurate boundary element matrix
<strong>B</strong>. The enhanced scaling behaviour allows for simulation of larger
ferromagnetic structures. The graph
on the memory consumption should enable users to estimate, whether they can
simulate a certain structure with Nmag+HLib and the available hardware.</p>
<img alt="_images/performance.png" class="align-center" src="_images/performance.png" style="width: 725px; height: 375px;" />
<p>Besides the savings in memory, hierarchical matrices also reduce the time needed
for the simulation setup considerably (see the bottom graph).</p>
</div>
<div class="section" id="hlib-and-mpi">
<span id="id9"></span><h4>HLib and MPI<a class="headerlink" href="manual.html#hlib-and-mpi" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference external" href="http://www.hlib.org">HLib</a> library that is available for academic use does not support
parallel execution. It is thus stored on the master node, and cannot
be distributed over several nodes. Simulations using the Hlib library
can use MPI (for all other calculations).</p>
</div>
</div>
<span id="document-example_nmagprobe/doc"></span><div class="section" id="example-calculation-of-dispersion-curves">
<h3>Example: Calculation of dispersion curves<a class="headerlink" href="manual.html#example-calculation-of-dispersion-curves" title="Permalink to this headline">¶</a></h3>
<p>Nmag can be used to study the propagation of spin waves and to calculate
dispersion curves. Here we consider a simulation script which shows how
to do that. In particular, we study a long cylindrical wire made of Permalloy.
We assume the magnetisation in the wire is relaxed along one axial direction
(i.e. there are no domain walls inside the wire). One side of the wire is &#8220;perturbed&#8221; at time t=0 by a pulsed magnetic field. The spin waves generated
on this side propagate towards the other. We want to study the propagation
of spin waves and obtain the dispersion relation, i.e. a relation between the
wave vector and the frequency of the spin-waves which propagate in the
considered media.
To calculate the dispersion relation we use the method developed
by V. Kruglyak, M. Dvornik and O. Dmytriiev</p>
<p>In order to carry out such a numerical experiment, we first need to calculate
the relaxed equilibrium magnetisation, i.e. the one which we perturb with
the application of a pulsed field. Consequently, the simulation is split into
two parts:</p>
<ul class="simple">
<li>In <strong>part I</strong>, the system is relaxed to obtain the initial magnetisation
configuration for zero applied field. Such a state is then saved into a file
to be used in part II;</li>
<li>In <strong>part II</strong>, the magnetisation obtained in part I is loaded and used as
the initial magnetisation configuration. A pulsed external magnetic field
localised on one side of the wire is applied. The Landau-Lifshitz-Gilbert
equation is integrated in time to compute the dynamical reaction to the
applied stimulus. The configuration of the magnetisation is saved frequently
to file, so that it can be studied and processed later.</li>
</ul>
<p>The two parts are two simulations of the same system under different
conditions.
If we then decide to write two separate files for the two parts we end up
duplicating the fragment of code which defines the materials and load
the mesh. For this reason we split the simulation in three files:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">&quot;thesystem.py&quot;</span></tt>: defines the material which composes the nanowire and
loads the mesh;</li>
<li><tt class="docutils literal"><span class="pre">&quot;relaxation.py&quot;</span></tt>: uses &#8220;thesystem.py&#8221; to setup the system and performs a
relaxation with zero applied field. It saves the final magnetisation
configuration to a file &#8220;m0.h5&#8221;;</li>
<li><tt class="docutils literal"><span class="pre">&quot;dynamics.py&quot;</span></tt>: uses &#8220;thesystem.py&#8221; to setup the system, loads the initial
magnetisation configuration from the file &#8220;m0.h5&#8221; (produced by
&#8220;relaxation.py&#8221;). It then applies a localised pulse of the applied magnetic
field on one side of the wire and compute the dynamical response of the system
saving the result to files.</li>
</ul>
<p>Consequently, in order to run the full simulation the user will have to type
two commands on the shell, one for each part of the simulation:</p>
<div class="highlight-python"><pre>$ nsim relaxation.py
$ nsim dynamics.py</pre>
</div>
<p>(there is no need to type <tt class="docutils literal"><span class="pre">nsim</span> <span class="pre">thesystem.py</span></tt> as this file is implicitly
&#8220;included&#8221; by the other two). In the next sections we will go through the
three files which make up the numerical experiment.</p>
<div class="section" id="the-system-thesystem-py">
<h4>The system: <tt class="docutils literal"><span class="pre">thesystem.py</span></tt><a class="headerlink" href="manual.html#the-system-thesystem-py" title="Permalink to this headline">¶</a></h4>
<p>The system under investigation is a cylindrical nanopillar of radius r=3 nm
and length l=600 nm. The mesh file <tt class="docutils literal"><span class="pre">cylinder.nmesh.h5</span></tt> is obtained (using
<a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a>). (The figure shows a cylinder that is 100nm long.)</p>
<div class="figure align-center">
<img alt="magnonics-1" src="_images/cylinder.png" />
</div>
<p>The geometry file given to <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a>
<a class="reference download internal" href="_downloads/cylinder.geo"><tt class="xref download docutils literal"><span class="pre">cylinder.geo</span></tt></a>
is shown below:</p>
<div class="highlight-python"><pre>    algebraic3d
    solid nanopillar = cylinder (-300.0, 0, 0; 300.0, 0, 0; 3.0)
                       and plane (-300.0, 0, 0; -1, 0, 0)
                       and plane ( 300.0, 0, 0;  1, 0, 0)
                       -maxh=1.0;
    tlo nanopillar;
</pre>
</div>
<p>The cylinder is made of Permalloy and as specified in the file
<a class="reference download internal" href="_downloads/thesystem.py"><tt class="xref download docutils literal"><span class="pre">thesystem.py</span></tt></a> shown below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># In this file we define the material parameters and geometry of the system</span>
<span class="c"># so that we can use it in two simulations: first during the relaxation,</span>
<span class="c"># then during the dynamics</span>

<span class="kn">from</span> <span class="nn">nmag.common</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">nm</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&#39;m&#39;</span><span class="p">)</span>    <span class="c"># define nm as &quot;nanometre&quot;</span>
<span class="n">ps</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-12</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">)</span>   <span class="c"># define ps as &quot;picosecond&quot;</span>

<span class="n">m0_filename</span> <span class="o">=</span> <span class="s">&quot;m0.h5&quot;</span> <span class="c"># the file containing the equilibrium magnetisation</span>

<span class="c"># A function which sets up the simulation with given name and damping</span>
<span class="k">def</span> <span class="nf">simulate_nanowire</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
  <span class="n">permalloy</span> <span class="o">=</span> <span class="n">MagMaterial</span><span class="p">(</span><span class="s">&#39;Py&#39;</span><span class="p">,</span>
                          <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.86e6</span><span class="p">,</span> <span class="s">&#39;A/m&#39;</span><span class="p">),</span>
                          <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13e-12</span><span class="p">,</span> <span class="s">&#39;J/m&#39;</span><span class="p">),</span>
                          <span class="n">llg_damping</span><span class="o">=</span><span class="n">damping</span><span class="p">)</span>

  <span class="n">s</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
  <span class="n">s</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;cylinder.nmesh.h5&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&#39;nanopillar&#39;</span><span class="p">,</span> <span class="n">permalloy</span><span class="p">)],</span>
              <span class="n">unit_length</span><span class="o">=</span><span class="n">nm</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>The file defines a few entities which are used in both the two parts of the
simulations: <tt class="docutils literal"><span class="pre">nm</span></tt> is just an abbreviation for nanometer and similarly
<tt class="docutils literal"><span class="pre">ps</span></tt> is an abbreviation for picosecond. <tt class="docutils literal"><span class="pre">m0_filename</span></tt> is the name of the
file where the relaxed magnetisation will be saved (in part I) and loaded
(in part II). Finally, the function <tt class="docutils literal"><span class="pre">simulate_nanowire</span></tt> deals with the
portion of the setup which is common to both part I and part II.
In particular, it defines a new material <tt class="docutils literal"><span class="pre">permalloy</span></tt>, creates a new
simulation object <tt class="docutils literal"><span class="pre">s</span></tt>, load the mesh and associates to it the material
<tt class="docutils literal"><span class="pre">permalloy</span></tt>. Such setup procedure is very similar to what has been
encountered so far in the manual, the only element of novelty is that here
we do it inside a function and return the created simulation object
as a result of the function. The file defined here is not supposed
to be run by itself, but rather to be used in part I and II.</p>
</div>
<div class="section" id="part-i-relaxation-py">
<h4>Part I: <tt class="docutils literal"><span class="pre">relaxation.py</span></tt><a class="headerlink" href="manual.html#part-i-relaxation-py" title="Permalink to this headline">¶</a></h4>
<p>The source for the file
<a class="reference download internal" href="_downloads/relaxation.py"><tt class="xref download docutils literal"><span class="pre">relaxation.py</span></tt></a>
is shown below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># This script is used to compute the equilibrium configuration for the</span>
<span class="c"># magnetisation, which is then used in the second part of the simulation,</span>
<span class="c"># where the dynamics is actually studied.</span>

<span class="kn">from</span> <span class="nn">thesystem</span> <span class="kn">import</span> <span class="n">simulate_nanowire</span><span class="p">,</span> <span class="n">m0_filename</span><span class="p">,</span> <span class="n">ps</span>
<span class="kn">from</span> <span class="nn">nmag.common</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">simulate_nanowire</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;relaxation&#39;</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span> <span class="c"># NOTE the high damping!</span>
<span class="n">s</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">s</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="o">*</span><span class="n">ps</span><span class="p">)</span> <span class="o">|</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>
<span class="n">s</span><span class="o">.</span><span class="n">save_restart_file</span><span class="p">(</span><span class="n">m0_filename</span><span class="p">)</span>
</pre></div>
</div>
<p>The first two lines are used to import entities defined elsewhere.
In particular, the first line in:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">thesystem</span> <span class="kn">import</span> <span class="n">simulate_nanowire</span><span class="p">,</span> <span class="n">m0_filename</span><span class="p">,</span> <span class="n">ps</span>
<span class="kn">from</span> <span class="nn">nmag.common</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>tells to Python to load the file <tt class="docutils literal"><span class="pre">thesystem.py</span></tt> and &#8220;extract&#8221; from it the
entities <tt class="docutils literal"><span class="pre">simulate_nanowire</span></tt>, <tt class="docutils literal"><span class="pre">m0_filename</span></tt>, <tt class="docutils literal"><span class="pre">ps</span></tt>. The second line
does a similar thing and extracts all the quantities defined in the Nmag
module <tt class="docutils literal"><span class="pre">nmag.common</span></tt>. This module defines some entities which are commonly
used in simulations (such as <tt class="docutils literal"><span class="pre">every</span></tt>, <tt class="docutils literal"><span class="pre">at</span></tt>, <tt class="docutils literal"><span class="pre">SI</span></tt>, etc).
The simulation is then set up using:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">s</span> <span class="o">=</span> <span class="n">simulate_nanowire</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;relaxation&#39;</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span> <span class="c"># NOTE the high damping!</span>
</pre></div>
</div>
<p>This line invokes the function <tt class="docutils literal"><span class="pre">simulate_nanowire</span></tt>, which does load the mesh
and associate the material to it. The function returns the simulation object
which is stored inside the variable <tt class="docutils literal"><span class="pre">s</span></tt> and is used in the following lines:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">s</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">s</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="o">*</span><span class="n">ps</span><span class="p">)</span> <span class="o">|</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>
<span class="n">s</span><span class="o">.</span><span class="n">save_restart_file</span><span class="p">(</span><span class="n">m0_filename</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we set the magnetisation along the axis of the nanopillar,
we then relax the system to find the equilibrium magnetisation.
We finally save such a configuration in the file <tt class="docutils literal"><span class="pre">m0_filename</span></tt>, i.e. with
the name specified in <tt class="docutils literal"><span class="pre">thesystem.py</span></tt>.</p>
</div>
<div class="section" id="part-ii-dynamics-py">
<h4>Part II: <tt class="docutils literal"><span class="pre">dynamics.py</span></tt><a class="headerlink" href="manual.html#part-ii-dynamics-py" title="Permalink to this headline">¶</a></h4>
<p>The source for the file <a class="reference download internal" href="_downloads/dynamics.py"><tt class="xref download docutils literal"><span class="pre">dynamics.py</span></tt></a>
is shown below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">thesystem</span> <span class="kn">import</span> <span class="n">simulate_nanowire</span><span class="p">,</span> <span class="n">m0_filename</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="n">nm</span>
<span class="kn">from</span> <span class="nn">nmag.common</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># Details about the pulse</span>
<span class="n">pulse_boundary</span> <span class="o">=</span> <span class="o">-</span><span class="mf">300.0e-9</span> <span class="o">+</span> <span class="mf">0.5e-9</span> <span class="c"># float in nm</span>
<span class="n">pulse_direction</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">pulse_amplitude</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e5</span><span class="p">,</span> <span class="s">&#39;A/m&#39;</span><span class="p">)</span>
<span class="n">pulse_duration</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">ps</span>

<span class="c"># Function which sets the magnetisation to zero</span>
<span class="k">def</span> <span class="nf">switch_off_pulse</span><span class="p">(</span><span class="n">sim</span><span class="p">):</span>
  <span class="n">sim</span><span class="o">.</span><span class="n">set_H_ext</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="n">pulse_amplitude</span><span class="p">)</span>

<span class="c"># Function which sets the pulse as a function of time/space</span>
<span class="k">def</span> <span class="nf">switch_on_pulse</span><span class="p">(</span><span class="n">sim</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">H_ext</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pulse_boundary</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">pulse_direction</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

  <span class="n">sim</span><span class="o">.</span><span class="n">set_H_ext</span><span class="p">(</span><span class="n">H_ext</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">pulse_amplitude</span><span class="p">)</span>

<span class="c"># Here we run the simulation: do=[....] is used to set the pulse</span>
<span class="c">#   save=[...] is used to save the data.</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">simulate_nanowire</span><span class="p">(</span><span class="s">&#39;dynamics&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">load_m_from_h5file</span><span class="p">(</span><span class="n">m0_filename</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">ps</span><span class="p">))],</span>
        <span class="n">do</span><span class="o">=</span><span class="p">[(</span><span class="n">switch_on_pulse</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="o">*</span><span class="n">ps</span><span class="p">)),</span>
            <span class="p">(</span><span class="n">switch_off_pulse</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">pulse_duration</span><span class="p">)),</span>
            <span class="p">(</span><span class="s">&#39;exit&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mi">200</span><span class="o">*</span><span class="n">ps</span><span class="p">))])</span>
</pre></div>
</div>
<p>The simulation starts again importing a few entities from the file
<tt class="docutils literal"><span class="pre">thesystem.py</span></tt>. In particular, the function <tt class="docutils literal"><span class="pre">simulate_nanowire</span></tt> is used
to setup the system similarly to what was done for the relaxation.
The next few lines define some variables which are used to define the
geometry and duration of the magnetic field pulse:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Details about the pulse</span>
<span class="n">pulse_boundary</span> <span class="o">=</span> <span class="o">-</span><span class="mf">300.0e-9</span> <span class="o">+</span> <span class="mf">0.5e-9</span> <span class="c"># float in nm</span>
<span class="n">pulse_direction</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">pulse_amplitude</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e5</span><span class="p">,</span> <span class="s">&#39;A/m&#39;</span><span class="p">)</span>
<span class="n">pulse_duration</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">ps</span>
</pre></div>
</div>
<p>In this example the pulse is obtained by switching on the applied field
(from (0, 0, 0) to (0, <tt class="docutils literal"><span class="pre">pulse_amplitude</span></tt>, 0)) in the region of the wire
where x &lt; <tt class="docutils literal"><span class="pre">pulse_boundary</span></tt>, which corresponds in this case to a layer
of 0.5 nm thickness on one side of the cylinder.
The pulse is switched on at t=0 and switched off at <tt class="docutils literal"><span class="pre">pulse_duration</span></tt>.
We now examine the code and explain how all this is coded in the script.
We start explaining the last few lines:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Here we run the simulation: do=[....] is used to set the pulse</span>
<span class="c">#   save=[...] is used to save the data.</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">simulate_nanowire</span><span class="p">(</span><span class="s">&#39;dynamics&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">load_m_from_h5file</span><span class="p">(</span><span class="n">m0_filename</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">ps</span><span class="p">))],</span>
        <span class="n">do</span><span class="o">=</span><span class="p">[(</span><span class="n">set_pulse</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="o">*</span><span class="n">ps</span><span class="p">)),</span>
            <span class="p">(</span><span class="n">set_to_zero</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">pulse_duration</span><span class="p">)),</span>
            <span class="p">(</span><span class="s">&#39;exit&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mi">200</span><span class="o">*</span><span class="n">ps</span><span class="p">))])</span>
</pre></div>
</div>
<p>Here we use the <tt class="docutils literal"><span class="pre">simulate_nanowire</span></tt> function which we defined in the file
<tt class="docutils literal"><span class="pre">thesystem.py</span></tt> to setup the system and the materials.
We then set the initial magnetisation configuration from the file saved
in part I and carry out the time integration by calling the <tt class="docutils literal"><span class="pre">relax</span></tt> method
of the simulation object <tt class="docutils literal"><span class="pre">s</span></tt>. The pulse is switched on and switched off
by the instruction passed in the <tt class="docutils literal"><span class="pre">do=[...]</span></tt> argument. In particular,
the argument <tt class="docutils literal"><span class="pre">do</span></tt> accepts a list of pairs
(things to be done, at a given time). The code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">do</span><span class="o">=</span><span class="p">[(</span><span class="n">switch_on_pulse</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="o">*</span><span class="n">ps</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">switch_off_pulse</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">pulse_duration</span><span class="p">)),</span>
    <span class="p">(</span><span class="s">&#39;exit&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="mi">200</span><span class="o">*</span><span class="n">ps</span><span class="p">))]</span>
</pre></div>
</div>
<p>specifies that:</p>
<ul class="simple">
<li>the function <tt class="docutils literal"><span class="pre">switch_on_pulse</span></tt> should be executed at time t=0 ps;</li>
<li>the function <tt class="docutils literal"><span class="pre">switch_off_pulse</span></tt> should be executed at time
t= <tt class="docutils literal"><span class="pre">pulse_duration</span></tt>;</li>
<li>the simulation should terminate at time t=200 ps.</li>
</ul>
<p>At the same time the argument <tt class="docutils literal"><span class="pre">save=[('fields',</span> <span class="pre">every('time',</span> <span class="pre">0.5*ps))]</span></tt>
of the relax method saves the field every 0.5 ps.</p>
<p>Let&#8217;s now see how the pulse is actually switched on and off.
To switch off the pulse we provide the function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Function which sets the magnetisation to zero</span>
<span class="k">def</span> <span class="nf">switch_off_pulse</span><span class="p">(</span><span class="n">sim</span><span class="p">):</span>
  <span class="n">sim</span><span class="o">.</span><span class="n">set_H_ext</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="n">pulse_amplitude</span><span class="p">)</span>
</pre></div>
</div>
<p>The function gets the simulation object, <tt class="docutils literal"><span class="pre">sim</span></tt>, as an argument
and uses it together with the method <tt class="docutils literal"><span class="pre">set_H_ext</span></tt> to set the applied
magnetic field to zero everywhere.
The function to set up the simulation is a little bit more complicated:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Function which sets the pulse as a function of time/space</span>
<span class="k">def</span> <span class="nf">switch_on_pulse</span><span class="p">(</span><span class="n">sim</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">H_ext</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pulse_boundary</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">pulse_direction</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

  <span class="n">sim</span><span class="o">.</span><span class="n">set_H_ext</span><span class="p">(</span><span class="n">H_ext</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">pulse_amplitude</span><span class="p">)</span>
</pre></div>
</div>
<p>Indeed, being the pulse localised (and hence non-uniform) in space,
we need to define a function to be given to <tt class="docutils literal"><span class="pre">set_H_ext</span></tt>.
The function checks whether the x component in the given point is lower
than <tt class="docutils literal"><span class="pre">pulse_amplitude</span></tt> and sets the applied field to a value differt
from zero only if that is really the case.</p>
</div>
<div class="section" id="postprocessing-the-data">
<span id="id1"></span><h4>Postprocessing the data<a class="headerlink" href="manual.html#postprocessing-the-data" title="Permalink to this headline">¶</a></h4>
<p>Once the simulations are finished, the data (i.e. the values of the
magnetisation saved every 0.5 ps) can be extracted from the file
<tt class="docutils literal"><span class="pre">dynamics_dat.h5</span></tt> and postprocessed.
We use the <tt class="docutils literal"><span class="pre">nmagprobe</span></tt> command for this. <tt class="docutils literal"><span class="pre">nmagprobe</span></tt> can perform
several postprocessing tasks (detailed documentation can be obtained
by typing <tt class="docutils literal"><span class="pre">nmagprobe</span> <span class="pre">--help</span></tt>).
In this context it is used to probe the magnetisation along the axis
of the cylinder at regular intervals of time.
The values extracted are then Fourier transformed.
The command we use is the following:</p>
<div class="highlight-python"><pre>nmagprobe --verbose dynamics_dat.h5 --field=m_Py \
  --time=0,100e-12,101 --space=-300,300,201/0/0 --ref-time=0.0 \
  --scalar-mode=component,1 --out=real-space.dat \
  --ft-axes=0,1 --ft-out=norm --ft-out=rec-space.dat</pre>
</div>
<p>Here we extract data for the magnetisation (option <tt class="docutils literal"><span class="pre">--field=m_Py</span></tt>)
from the file <tt class="docutils literal"><span class="pre">dynamics_dat.h5</span></tt>.</p>
<ul class="simple">
<li>We probe the field over a cubic lattice in space and time.
The lattice is four dimensional and consists of the points
(t, x, y, z) with t=0, 1 ps, 2 ps, ..., 100 ps (101 values),
x=-300 nm, -297 nm, -294 nm, ..., 300 nm (201 values)
and y=z=0.
The lattice is fully determined by the options <tt class="docutils literal"><span class="pre">--time</span></tt> and <tt class="docutils literal"><span class="pre">--space</span></tt>.
In particular, the option <tt class="docutils literal"><span class="pre">--time=0,100e-12,101</span></tt> states that the lattice
consists of 101 equispaced values going from 0 to 100e-12 s.
The option <tt class="docutils literal"><span class="pre">--space</span></tt> accepts a similar expressions for each spatial
coordinate separated by <tt class="docutils literal"><span class="pre">/</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">--ref-time=0.0</span></tt> tells to <tt class="docutils literal"><span class="pre">nmagprobe</span></tt> that after extracting
the values for the field, m(t, x, y, z), it should compute the difference
with respect to the given time,
i.e. dm(t, x, y, z) = m(t, x, y, z) - m(0, x, y, z).
We add this option to <tt class="docutils literal"><span class="pre">nmagprobe</span></tt> because we are interested in the variation
of the magnetisation with respect to the equilibrium configuration (t=0)
rather than on its &#8220;absolute&#8221; value;</li>
<li><tt class="docutils literal"><span class="pre">--scalar-mode=component,1</span></tt> induces <tt class="docutils literal"><span class="pre">nmagprobe</span></tt> to extract the y
component of dm and to use it as a scalar when writing the output
and when doing the fourier transform (to extract the x component one
should use <tt class="docutils literal"><span class="pre">--scalar-mode=component,0</span></tt>); We could also write
<tt class="docutils literal"><span class="pre">--scalar-mode=component,y</span></tt> and <tt class="docutils literal"><span class="pre">--scalar-mode=component,x</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">--out=real-space.dat</span></tt> induces <tt class="docutils literal"><span class="pre">nmagprobe</span></tt> to save to file the data
selected by the options discussed so far. In particular, the file
<tt class="docutils literal"><span class="pre">real-space.dat</span></tt> will be filled with the values of the y-component
of dm(t, x, y, z) along the selected lattice. That will be a text file
which can be inspected with a text editor and used within plotting programs
such as <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a>;</li>
<li><tt class="docutils literal"><span class="pre">--ft-axes=0,1</span></tt> specifies that the selected data should be Fourier
transformed along the axis 0 (time) and 1 (x-space). This can also
be written as <tt class="docutils literal"><span class="pre">--ft-axes=t,x</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">--ft-out=norm</span></tt> induces <tt class="docutils literal"><span class="pre">nmagprobe</span></tt> to compute the norm of the complex
numbers coming from the Fourier-transform. These are the values which
are finally saved to file;</li>
<li><tt class="docutils literal"><span class="pre">--ft-out=rec-space.dat</span></tt> specifies the output file for the
Fourier-transformed data.</li>
</ul>
<p>The command creates two files: <tt class="docutils literal"><span class="pre">real-space.dat</span></tt>, containing the y component
of the magnetisation variation as a function of time and space,
and <tt class="docutils literal"><span class="pre">rec-space.dat</span></tt>, containing the Fourier transform of such a quantity.</p>
<p>To plot the data in the two files we use the <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> script
<a class="reference download internal" href="_downloads/plot.gnp"><tt class="xref download docutils literal"><span class="pre">plot.gnp</span></tt></a>:</p>
<div class="highlight-python"><pre>set term png
set pm3d map

set out "real-space.png"
set title "y component of magnetisation variation"
set xlabel "position in axis (nm)"
set ylabel "time (ps)"
splot [] [0:] [-0.001:0.001] 'real-space.dat' u ($2):($1/1e-12):5 t ""

set out "rec-space.png"
set title "Fourier transform"
set xlabel "k (1/nm)"
set ylabel "omega (GHz)"
splot [] [0:] [0:1.7e-8] 'rec-space.dat' u (-$2):($1/(2*pi*1e9)):5 t ""




</pre>
</div>
<p>Here is the result after running the script with Gnuplot.</p>
<div class="figure align-center">
<img alt="magnonics-1" src="_images/real-space.png" />
</div>
<div class="figure align-center">
<img alt="magnonics-2" src="_images/rec-space.png" />
</div>
</div>
</div>
<span id="document-example_tolerances/doc"></span><div class="section" id="example-timestepper-tolerances">
<span id="example-tolerances"></span><h3>Example: Timestepper tolerances<a class="headerlink" href="manual.html#example-timestepper-tolerances" title="Permalink to this headline">¶</a></h3>
<p>The tolerance settings of a simulation can greatly affect the
performance, the accuracy and the usefulness of a simulation. Section
<a class="reference internal" href="manual.html#solvers-and-tolerance-settings"><em>Solvers and tolerance settings</em></a> provides an overview. In this
example, we demonstrate</p>
<ul class="simple">
<li>how the time integrator&#8217;s tolerances can be set and</li>
<li>how these tolerances affect the simulation results and performance.</li>
</ul>
<p>The time integrator we use is the PVODE solver from the <a class="reference external" href="http://www.llnl.gov/CASC/sundials/">SUNDIALS</a>
package. It is optimised to deal with stiff systems of ordinary
differential equations and is therefore very suited for micromagnetic
simulations. It can also execute in parallel (i.e. across several CPUs
at the same time using MPI). The computational challenge of the time
integration lies in the different time scales associated with the
(fast) exchange field and the (slower) demagnetisation field.</p>
<p>Sundials provides two parameters <tt class="docutils literal"><span class="pre">rtol</span></tt> and <tt class="docutils literal"><span class="pre">atol</span></tt> (see <a class="reference external" href="https://computation.llnl.gov/casc/sundials/documentation/cv_guide.pdf">sundials
documentation</a>)
to control the required accuracy of the calculations. Sundials uses
these parameters to determine the number of iterations required to
simulate a given amount of real time (for example one pico
second). Equivalently, these parameters determine the amount of real
time that can be simulated per iteration.</p>
<p>It is common that the amount of time simulated per iteration varies
throughout a simulation as different time step sizes are required to
resolve the physics to the same accuracy level. (The <a class="reference internal" href="manual.html#ndt"><em>Data files (.ndt)</em></a> data file
contains one column <tt class="docutils literal"><span class="pre">last_step_dt</span></tt> which provides the size of the
time step. Use <a class="reference internal" href="manual.html#ncol"><em>ncol</em></a> to extract this data conveniently.)</p>
<p>The sundials tolerance parameters <tt class="docutils literal"><span class="pre">rtol</span></tt> and <tt class="docutils literal"><span class="pre">atol</span></tt> can be set in
nmag using the <tt class="docutils literal"><span class="pre">ts_rel_tol</span></tt> and <tt class="docutils literal"><span class="pre">ts_abs_tol</span></tt> arguments in the
<a class="reference internal" href="manual.html#set-params"><em>set_params</em></a> function. (The letters <tt class="docutils literal"><span class="pre">ts</span></tt> in <tt class="docutils literal"><span class="pre">ts_rel_tol</span></tt> and
<tt class="docutils literal"><span class="pre">ts_abs_tol</span></tt> stand for Time Stepper).</p>
<p>The integration of the Landau Lifshitz and Gilbert equation is carried
out on the <em>normalised</em> magnetisation, and the corresponding field
(see <a class="reference internal" href="manual.html#fields-and-subfields-in-nmag"><em>Fields and Subfields in Nmag</em></a>) is called <tt class="docutils literal"><span class="pre">m</span></tt> (the magnetisation with the saturation magnetisation magnitude is called capital <tt class="docutils literal"><span class="pre">M</span></tt> in nmag). Because this
field is normalised, we set <tt class="docutils literal"><span class="pre">rtol</span></tt> and <tt class="docutils literal"><span class="pre">atol</span></tt> to the same value in
this example, and refer to the value just as <tt class="docutils literal"><span class="pre">tol</span></tt>.</p>
<p>We use the program <a class="reference download internal" href="_downloads/bar_tol.py"><tt class="xref download docutils literal"><span class="pre">bar_tol.py</span></tt></a> that:</p>
<ul class="simple">
<li>re-uses the bar studied in <a class="reference internal" href="manual.html#example-2"><em>Example 2: Computing the time development of a system</em></a> but</li>
<li>carries out the time integration for a number of different tolerance values.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span>

<span class="kn">import</span> <span class="nn">time</span> <span class="c">#python standard modules, used to measure run time</span>

<span class="k">def</span> <span class="nf">run_sim</span><span class="p">(</span><span class="n">tol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function that is called repeatedly with different tolerance values.</span>
<span class="sd">    Each function call is carrying out one simulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mat_Py</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">MagMaterial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Py&quot;</span><span class="p">,</span>
                              <span class="n">Ms</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">0.86e6</span><span class="p">,</span><span class="s">&quot;A/m&quot;</span><span class="p">),</span>
                              <span class="n">exchange_coupling</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">13.0e-12</span><span class="p">,</span> <span class="s">&quot;J/m&quot;</span><span class="p">),</span>
                              <span class="n">llg_damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="c">#compose name of simulation to inlude value of tolerance</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="s">&quot;bar_</span><span class="si">%.6f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">tol</span><span class="p">)</span>

    <span class="n">sim</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="s">&quot;bar30_30_100.nmesh.h5&quot;</span><span class="p">,</span>
                  <span class="p">[(</span><span class="s">&quot;Py&quot;</span><span class="p">,</span> <span class="n">mat_Py</span><span class="p">)],</span>
                  <span class="n">unit_length</span><span class="o">=</span><span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span><span class="s">&quot;m&quot;</span><span class="p">))</span>

    <span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

    <span class="c">#set tolerance (has to be called after set_m())</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="n">ts_abs_tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">ts_rel_tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">2.5e-12</span><span class="p">,</span> <span class="s">&quot;s&quot;</span><span class="p">)</span> 

    <span class="n">timing</span> <span class="o">=</span> <span class="mi">0</span> <span class="c">#initialise variable to measure execution time</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">121</span><span class="p">):</span> 
        <span class="n">timing</span> <span class="o">-=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>    <span class="c">#start measuring time</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">advance_time</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>   <span class="c">#compute time development for 300ps</span>
        <span class="n">timing</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>    <span class="c">#stop measuring time</span>
                                 <span class="c">#we exclude time required to save data</span>
                                 
        <span class="n">sim</span><span class="o">.</span><span class="n">save_data</span><span class="p">()</span>          <span class="c">#save averages every 2.5 ps</span>

    <span class="c">#at end of simulation, write performance data into summary file</span>
    <span class="n">f</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="s">&#39;resultsummary.txt&#39;</span><span class="p">,</span><span class="s">&#39;a&#39;</span><span class="p">)</span> <span class="c">#open file to append </span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%g</span><span class="s"> </span><span class="si">%d</span><span class="s"> </span><span class="si">%g</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tol</span><span class="p">,</span><span class="n">sim</span><span class="o">.</span><span class="n">clock</span><span class="p">[</span><span class="s">&#39;step&#39;</span><span class="p">],</span><span class="n">timing</span><span class="p">))</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="c">#main program</span>
<span class="n">tols</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-1</span><span class="p">,</span><span class="mf">1e-2</span><span class="p">,</span><span class="mf">1e-3</span><span class="p">,</span><span class="mf">1e-4</span><span class="p">,</span><span class="mf">1e-5</span><span class="p">,</span><span class="mf">1e-6</span><span class="p">]</span>

<span class="k">for</span> <span class="n">tol</span> <span class="ow">in</span> <span class="n">tols</span><span class="p">:</span>
    <span class="n">run_sim</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span>
</pre></div>
</div>
<p>From a conceptual point of view, we see something new here: the section of the code that starts with:</p>
<div class="highlight-python"><pre>def run_sim(tol):</pre>
</div>
<p><tt class="docutils literal"><span class="pre">def</span></tt>ines a function with name <tt class="docutils literal"><span class="pre">run_sim</span></tt> which will carry out a
complete simulation every time it is called. It takes one argument:
the parameter <tt class="docutils literal"><span class="pre">tol</span></tt>. The simulation name (which is re-used in the
name of the <a class="reference internal" href="manual.html#ndt"><em>Data files (.ndt)</em></a> data file) contains the value of <tt class="docutils literal"><span class="pre">tol</span></tt>. For
example, if the <tt class="docutils literal"><span class="pre">tol=0.1</span></tt>, then the name of the simulation is
<tt class="docutils literal"><span class="pre">bar_0.100000</span></tt> and the name of the ndt data file is
<tt class="docutils literal"><span class="pre">bar_0.100000_dat.ndt</span></tt>. We can thus call this function repeatedly
for different values of <tt class="docutils literal"><span class="pre">tol</span></tt>, and each time a complete simulation
will be run and new data files created. <a class="footnote-reference" href="manual.html#repeatsimulation" id="id1">[1]</a></p>
<p>The main loop of the script:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#main program</span>
<span class="n">tols</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1e-1</span><span class="p">,</span><span class="mf">1e-2</span><span class="p">,</span><span class="mf">1e-3</span><span class="p">,</span><span class="mf">1e-4</span><span class="p">,</span><span class="mf">1e-5</span><span class="p">,</span><span class="mf">1e-6</span><span class="p">,</span><span class="mf">1.0</span><span class="p">]</span>

<span class="k">for</span> <span class="n">tol</span> <span class="ow">in</span> <span class="n">tols</span><span class="p">:</span>
    <span class="n">run_sim</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span>
</pre></div>
</div>
<p>simply iterates over values <tt class="docutils literal"><span class="pre">0.1,</span> <span class="pre">0.01,</span> <span class="pre">0.001,</span> <span class="pre">0.0001,</span> <span class="pre">0.00001</span></tt> and
<tt class="docutils literal"><span class="pre">0.000001</span></tt> and calls the function <tt class="docutils literal"><span class="pre">run_sim</span></tt> with a different
tolerance value in every iteration of the for-loop.</p>
<p>Once the program has finished, we have data files
<tt class="docutils literal"><span class="pre">bar_0.000001_dat.ndt,</span> <span class="pre">bar_0.000010_dat.ndt,</span> <span class="pre">...</span></tt> and
<tt class="docutils literal"><span class="pre">bar_0.100000_dat.ndt</span></tt> that can be analysed and plotted in the usual
way.</p>
<p>We show a plot of the x, y and z components of the magnetisation
against time (as in <a class="reference internal" href="manual.html#example-2"><em>Example 2: Computing the time development of a system</em></a>) for each of the tolerance
values. The run with <tt class="docutils literal"><span class="pre">tol=1e-6</span></tt> is the most accurate, and the
corresponding black line has been tagged with little <tt class="docutils literal"><span class="pre">+</span></tt> characters.</p>
<img alt="_images/plot1.png" class="align-center" src="_images/plot1.png" style="width: 710px; height: 470px;" />
<p>We can see that curves seem to coincide (at this scale) apart from the
red <tt class="docutils literal"><span class="pre">tol=1e-1</span></tt> curve which deviates somewhat.
We zoom in to region between 1.2e-10 seconds and 2e-10 seconds and
focus on the lowers curves in the main plot:</p>
<img alt="_images/plot2.png" class="align-center" src="_images/plot2.png" style="width: 702px; height: 470px;" />
<p>The better resolution reveals that there is a clear deviation of the
various curves: the red (0.1), indigo (0.01) and yellow (1e-3) curves
approach the black (1e-6) curve in this order. The blue (1e-4) and
green (1e-5) curves appear to coincide with the black reference curve.</p>
<p>Another zoom at the z-component of the magnetisation towards the end
of the simulated time interval (time&gt;1.8e-10 seconds) shows that the
less accurate curves (red, and then indigo and yellow) show a large
amount of jitter (although following the reference curve <em>on
average</em>).</p>
<img alt="_images/plot3.png" class="align-center" src="_images/plot3.png" style="width: 706px; height: 471px;" />
<p>We conclude that we should use a tolerance of at most 1e-3 for this
simulation; better 1e-4 or smaller.</p>
<p>In simulation work, we are of course interested to get the most
accurate simulation results. However, in reality this is conflicting
with the increased run time that is associated with more accurate
simulations. In this example, we have written some performance data
into <a class="reference download internal" href="_downloads/resultsummary.txt"><tt class="xref download docutils literal"><span class="pre">resultssummary.txt</span></tt></a>. Reformatted,
postprocessed and the rows re-ordered, this is the data complete with
table headings:</p>
<div class="highlight-python"><pre>========== ========== ============== =====================
       tol      steps   CPU time (s) CPU time per step (s)
========== ========== ============== =====================
  0.000001        740         120.81                 0.163
  0.000010        356          62.37                 0.175
  0.000100        182          46.10                 0.253
  0.001000        119          66.36                 0.558
  0.010000        114          92.08                 0.808
  0.100000         88          94.69                 1.076
========== ========== ============== =====================
</pre>
</div>
<p>The accuracy of the simulation results decreases from the top of the
table downwards. We know from the graphs above that we should use a
tolerance setting of 1e-4 or smaller to obtain fairly accurate results
(assuming that the 1e-6 curve is used as a reference).</p>
<p>The number of iterations required increases from the tolerance 1e-4 to
tolerance 1e-6 by a factor of 4 while the total CPU time increases by
a factor of 2.6.</p>
<p>Looking at the greater tolerances 1e-3 and 0.01, we see that while the
number of iterations required decreases, the CPU time is
increasing. This is the first indication that at this tolerance level
the system becomes difficult to treat efficiently by sundials (it
basically appears to be noisy and stochastic equations are hard to
integrate).</p>
<p>In summary,</p>
<ul class="simple">
<li>to minimise the simulation time, we need to choose a tolerance value
as large as &#8220;possible&#8221;.</li>
<li>The definition of &#8220;possible&#8221; will depend on the context. A good way
of obtaining a suitable tolerance value is to run the same simulation
repeatedly with decreasing tolerance values. Once the resulting curves
converge (as a function of decreasing tolerance settings), a good tolerance level
has been found. (This would be 1e-4 for the example shown here.)</li>
<li>Choosing the tolerance values to be too large, can be counter
productive (and take much more CPU time than the lower accuracy
level).</li>
<li>The default value for the sundials tolerances is shown in the
documentation of <a class="reference internal" href="manual.html#set-params"><em>set_params</em></a>. A simulation can often be accelerated
significantly by increasing this value.</li>
<li>A change of the tolerances has to be considered together with the
convergence criterion for hysterises loop calculations (see next
section: <a class="reference internal" href="manual.html#hysteris-loop-calculation-not-converging-a-word-of-warning">Hysteris loop calculation not converging? A word of warning ...</a>)</li>
</ul>
<div class="section" id="hysteris-loop-calculation-not-converging-a-word-of-warning">
<span id="id2"></span><h4>Hysteris loop calculation not converging? A word of warning ...<a class="headerlink" href="manual.html#hysteris-loop-calculation-not-converging-a-word-of-warning" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="manual.html#hysteresis"><em>hysteresis</em></a> and the <a class="reference internal" href="manual.html#relax"><em>relax</em></a> command need to have a criterion how to
decide when the simulation has reached a (meta)stable state and when
the relaxation (at a given applied field) should be considered to have
been reached. A common approach (which is used by OOMMF and nmag, for
example) is to monitor the change of the (normalised) magnetisation
with respect to time (i.e. dm/dt). If the absolute value of this drops
below a given threshold, then one considers the system as converged
(the <a class="reference internal" href="manual.html#relax"><em>relax</em></a> command will return at this point, while the <a class="reference internal" href="manual.html#hysteresis"><em>hysteresis</em></a>
command will move to the next field). This threshold can be changed
from its default value with the <a class="reference internal" href="manual.html#set-params"><em>set_params</em></a> simulation method (the
attribute is <cite>stopping_dm_dt</cite>).</p>
<p>The choice of the tolerances (<cite>ts_rel_tol</cite> and <cite>ts_abs_tol</cite>) <em>must</em>
respect the chosen <cite>stopping_dm_dt</cite> value (or conversely
the <cite>stopping_dm_dt</cite> needs to be adapted to work with
the chosen tolerances):
large values for the tolerances correspond to lower accuracy
and to larger random fluctuations of dm/dt,
which consequently may never become lower than <cite>stopping_dm_dt</cite>.
In such a case the simulation never returns from the <a class="reference internal" href="manual.html#relax"><em>relax</em></a> command,
because the convergence criterion is never satisfied.</p>
<p>In all the examples we have studied, we have found that the default
parameters work fine. However, if you find that a simulation never
returns from the <a class="reference internal" href="manual.html#hysteresis"><em>hysteresis</em></a> or <a class="reference internal" href="manual.html#relax"><em>relax</em></a> command, it is worth reducing
the tolerances for the time stepper (on increasing <cite>stopping_dm_dt</cite>)
to see whether this resolves the problem).</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="repeatsimulation" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id1">[1]</a></td><td>We could, in fact, avoid re-creating all the operator matrices
and the BEM, and just repeat the simulation with varying values of the
<tt class="docutils literal"><span class="pre">tol</span></tt> parameter. However, this would mean that the data is written
into the same file (so is slightly less convenient here).  It would
also be a less pedagogical example in this guided tour.</td></tr>
</tbody>
</table>
</div>
</div>
<span id="document-example_mpi1/doc"></span><div class="section" id="example-parallel-execution-mpi">
<span id="id1"></span><h3>Example: Parallel execution (MPI)<a class="headerlink" href="manual.html#example-parallel-execution-mpi" title="Permalink to this headline">¶</a></h3>
<p>Nmag&#8216;s numerical core (which is part of the nsim multi-physics
library) has been designed to carry out numerical computation on
several CPUs simultaneously. The protocol that we are using for this
is the wide spread Message Passing Interface (MPI). There are a number
of MPI implementations; the best known ones are probably MPICH1,
MPICH2 and LAM-MPI. Currently, we support <a class="reference external" href="http://www-unix.mcs.anl.gov/mpi/mpich1/">MPICH1</a> and <a class="reference external" href="http://www.mcs.anl.gov/research/projects/mpich2">MPICH2</a>.</p>
<p>Which mpi version to use? Whether you want to use mpich1 or mpich2
will depend on your installation: currently, the installation from
source provides mpich2 (which is also used in the virtual machines)
whereas the Debian package relies on mpich1 (no Debian package is
provided after release 0.1-6163).</p>
<div class="section" id="using-mpich2">
<span id="id2"></span><h4>Using mpich2<a class="headerlink" href="manual.html#using-mpich2" title="Permalink to this headline">¶</a></h4>
<p>Before
the actual simulation is started, a <cite>multi-purpose daemon</cite> must be
started when using MPICH2.</p>
<hr class="docutils" />
<p><strong>The ``.mpd.conf`` file</strong></p>
<p>MPICH2 will look for a configuration file with name <tt class="docutils literal"><span class="pre">.mpd.conf</span></tt> in
the user&#8217;s home directory. If this is missing, an attempt to start
the multi-purpose daemon, will result in an error message like
this:</p>
<div class="highlight-python"><pre>$&gt; mpd
configuration file /Users/fangohr/.mpd.conf not found
A file named .mpd.conf file must be present in the user's home
directory (/etc/mpd.conf if root) with read and write access
only for the user, and must contain at least a line with:
MPD_SECRETWORD=&lt;secretword&gt;
One way to safely create this file is to do the following:
  cd $HOME
  touch .mpd.conf
  chmod 600 .mpd.conf
and then use an editor to insert a line like
  MPD_SECRETWORD=mr45-j9z
into the file.  (Of course use some other secret word than mr45-j9z.)</pre>
</div>
<p>If you don&#8217;t have this file in your home directory, just follow the
instructions above to create it with some secret word of your choice
(Note that the above example is from a Mac OS X system: on Linux the
home directory is usually under <tt class="docutils literal"><span class="pre">/home/USERNAME</span></tt> rather than
<tt class="docutils literal"><span class="pre">/Users/USERNAME</span></tt> as shown here.)</p>
<hr class="docutils" />
<p>Let&#8217;s assume we have a multi-core machine with more than one
CPU. This makes the mpi setup slightly easier, and is also likely to
be more efficient than running a job across the network between
difference machines.</p>
<p>First, we need to start the multi-purpose daemon:</p>
<div class="highlight-python"><pre>$&gt; mpd &amp;</pre>
</div>
<p>It will look  for the file <tt class="docutils literal"><span class="pre">~/.mpd.conf</span></tt> as described above. If found, it will start silently. Otherwise it will complain.</p>
<div class="section" id="testing-that-nsim-executes-in-parallel">
<span id="id3"></span><h5>Testing that nsim executes in parallel<a class="headerlink" href="manual.html#testing-that-nsim-executes-in-parallel" title="Permalink to this headline">¶</a></h5>
<p>First, let&#8217;s make sure that <tt class="docutils literal"><span class="pre">nsim</span></tt> is in the search path. The command <tt class="docutils literal"><span class="pre">which</span> <span class="pre">nsim</span></tt> will return the location of the executable if it can be found in the search path. For example:</p>
<div class="highlight-python"><pre>$&gt; which nsim
/home/fangohr/new/nmag-0.1/bin/nsim</pre>
</div>
<p>To execute nsim using two processes, we can use the command:</p>
<div class="highlight-python"><pre>$&gt; mpiexec -n 2 nsim</pre>
</div>
<p>There are two useful commands to check whether nsim is aware of the intended MPI setup. The fist one is <tt class="docutils literal"><span class="pre">ocaml.mpi_status()</span></tt> which provides the total number of processes in the MPI set-up:</p>
<div class="highlight-python"><pre>$&gt; mpiexec -n 2 nsim
&gt;&gt;&gt; ocaml.mpi_status()
MPI-status: There are 2 nodes (this is the master, rank=0)
&gt;&gt;&gt;</pre>
</div>
<p>The other command is <tt class="docutils literal"><span class="pre">ocaml.mpi_hello()</span></tt> and prints a short &#8216;hello&#8217; from all processes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ocaml</span><span class="o">.</span><span class="n">mpi_hello</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">Node</span>   <span class="mi">0</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="n">Hello</span> <span class="kn">from</span> <span class="nn">beta.kk.soton.ac.uk</span>
<span class="go">[Node   1/2] Hello from beta.kk.soton.ac.uk</span>
</pre></div>
</div>
<p>For comparison, let&#8217;s look at the output of these commands if we start <tt class="docutils literal"><span class="pre">nsim</span></tt> <em>without</em> MPI, in which case only one MPI node is reported:</p>
<div class="highlight-python"><pre>$&gt; nsim
&gt;&gt;&gt; ocaml.mpi_status()
MPI-status: There are 1 nodes (this is the master, rank=0)
&gt;&gt;&gt; ocaml.mpi_hello()
[Node   0/1] Hello from beta.kk.soton.ac.uk</pre>
</div>
<p>Assuming this all works, we can now start the actual simulation. To
use two CPUs on the local machine to run the <tt class="docutils literal"><span class="pre">bar30_30_100.py</span></tt>
program, we can use:</p>
<div class="highlight-python"><pre>$&gt; mpiexec -n 2 nsim bar30_30_100.py</pre>
</div>
<p>To run the program again, using 4 CPUs on the local machine:</p>
<div class="highlight-python"><pre>$&gt; mpiexec -n 4 nsim bar30_30_100.py</pre>
</div>
<p>Note that mpich2 (and mpich1) will spawn more processes than there are
CPUs if necessary. I.e. if you are working on some Intel Dual Core
processor (with 2 CPUs and one core each) but request to run your
program with 4 (via the <tt class="docutils literal"><span class="pre">-n</span> <span class="pre">4</span></tt> switch given to <tt class="docutils literal"><span class="pre">mpiexec</span></tt>), than
you will have 4 processes running on the 2 CPUs.</p>
<p>If you want to stop the <tt class="docutils literal"><span class="pre">mpd</span></tt> daemon, you can use:</p>
<div class="highlight-python"><pre>$&gt; mpdallexit</pre>
</div>
<p>For diagnostic purposes, the <tt class="docutils literal"><span class="pre">mpdtrace</span></tt> command can be use to track
whether a multipurpose daemon is running (and which machines are part
of the <cite>mpi-ring</cite>).</p>
<p><strong>Advanced usage of mpich2</strong></p>
<p>To run a job across different machines, one needs to start the
multi-purpose daemons on the other machines with the <tt class="docutils literal"><span class="pre">mpdboot</span></tt>
command. This will search for a file (in the current directory) with
name <tt class="docutils literal"><span class="pre">mpd.hosts</span></tt> which should contain a list of hosts to participate
(very similar to the <tt class="docutils literal"><span class="pre">machinefile</span></tt> in MPICH1).</p>
<p>To trace which process is sending what messages to the standard out,
one can add the <tt class="docutils literal"><span class="pre">-l</span></tt> switch to the <tt class="docutils literal"><span class="pre">mpiexec</span></tt> command: then each
line of standard output will be preceded by the rank of the process
who has issued the message.</p>
<p>Please refer to the official <a class="reference external" href="http://www.mcs.anl.gov/research/projects/mpich2">MPICH2</a>  documentation for further details.</p>
</div>
</div>
<div class="section" id="using-mpich1">
<span id="id4"></span><h4>Using mpich1<a class="headerlink" href="manual.html#using-mpich1" title="Permalink to this headline">¶</a></h4>
<p>Note: Most users will use MPICH2 (if they have compiled Nmag from the tar-ball): see <a class="reference internal" href="manual.html#using-mpich2"><em>Using mpich2</em></a></p>
<p>Suppose we would like to run <a class="reference internal" href="manual.html#example-2"><em>Example 2: Computing the time development of a system</em></a> of the manual with 2
processors using MPICH1. We need to know the full path to the <tt class="docutils literal"><span class="pre">nsim</span></tt> executable. In
a <tt class="docutils literal"><span class="pre">bash</span></tt> environment (this is pretty much the standard on Linux and
Mac OS X nowadays), you can find the path using the <tt class="docutils literal"><span class="pre">which</span></tt>
command. On a system where nsim was installed from the Debian package:</p>
<div class="highlight-python"><pre>$&gt; which nsim
/usr/bin/nsim</pre>
</div>
<p>Let&#8217;s assume we have a multi-core machine with more than one
CPU. This makes the mpi setup slightly easier, and is also likely to
be more efficient than running a job across the network between
difference machines. In that case, we can run the example on 2 CPUs using:</p>
<div class="highlight-python"><pre>$&gt; mpirun -np 2 /usr/bin/nsim bar30_30_100.py</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">-np</span></tt> is the command line argument for the Number of Processors.</p>
<p>To check that the code is running on more than one CPU, one of the
first few log messages will display (in addition to the runid of the
simulation) the number of CPUs used:</p>
<div class="highlight-python"><pre>$&gt; mpirun -np 2 `which nsim` bar30_30_100.py

    nmag:2008-05-20 12:50:01,177   setup.py  269    INFO Runid (=name simulation) is 'bar30_30_100', using 2 CPUs</pre>
</div>
<p>To use 4 processors (if we have a quad core machine available), we would use:</p>
<div class="highlight-python"><pre>$&gt; mpirun -np 4 /usr/bin/nsim bar30_30_100.py</pre>
</div>
<p>Assuming that the <tt class="docutils literal"><span class="pre">nsim</span></tt> executable is in the path, and that we are
using a bash-shell, we could shortcut the step of finding the <tt class="docutils literal"><span class="pre">nsim</span></tt>
executable by writing:</p>
<div class="highlight-python"><pre>$&gt; mpirun -np 4 `which nsim` bar30_30_100.py</pre>
</div>
<p>To run the job across the network on different machines
simultaneously, we need to create a file with the names of the hosts
that should be used for the parallel execution of the program. If you
intend to use nmag on a cluster, your cluster administrator should
explain where to find this machine file.</p>
<p>To distribute a job across <tt class="docutils literal"><span class="pre">machine1.mydomain</span></tt>,
<tt class="docutils literal"><span class="pre">machine2.mydomain</span></tt>, and <tt class="docutils literal"><span class="pre">machine3.mydomain</span></tt> we need to create the
file <tt class="docutils literal"><span class="pre">machines.txt</span></tt> with content:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">machine1</span><span class="o">.</span><span class="n">mydomain</span>
<span class="n">machine2</span><span class="o">.</span><span class="n">mydomain</span>
<span class="n">machine3</span><span class="o">.</span><span class="n">mydomain</span>
</pre></div>
</div>
<p>We then need to pass the name of this file to the <tt class="docutils literal"><span class="pre">mpirun</span></tt> command
to run a (mpi-enabled) executable with mpich:</p>
<div class="highlight-python"><pre>mpirun -machinefile machines.txt -np 3 /usr/bin/nsim bar30_30_100.py</pre>
</div>
<p>For further details, please refer to the <a class="reference external" href="http://www-unix.mcs.anl.gov/mpi/mpich1/">MPICH1</a> documentation.</p>
</div>
<div class="section" id="visualising-the-partition-of-the-mesh">
<span id="id5"></span><h4>Visualising the partition of the mesh<a class="headerlink" href="manual.html#visualising-the-partition-of-the-mesh" title="Permalink to this headline">¶</a></h4>
<p>We use Metis to partition the mesh. Partitioning means to allocate
certain mesh nodes to certain CPUs. Generally, it is good if nodes
that are spatially close to each other are assigned to the same CPU.</p>
<p>Here we demonstrate how the chosen partition can be visualised. As an
example, we use the <a class="reference internal" href="manual.html#example-1"><em>Example: demag field in uniformly magnetised
sphere</em></a>. We are <a class="reference internal" href="manual.html#using-mpich2"><em>Using mpich2</em></a>:</p>
<div class="highlight-python"><pre>$&gt; mpd &amp;
$&gt; mpiexec -l -n 3 nsim sphere1.py</pre>
</div>
<p>The program starts, and prints the chose partition to stdout:</p>
<div class="highlight-python"><pre> nfem.ocaml:2008-05-28 15:11:07,757    INFO Calling ParMETIS to partition the me
sh among 3 processors
 nfem.ocaml:2008-05-28 15:11:07,765    INFO Processor 0: 177 nodes
 nfem.ocaml:2008-05-28 15:11:07,765    INFO Processor 1: 185 nodes
 nfem.ocaml:2008-05-28 15:11:07,766    INFO Processor 2: 178 nodes</pre>
</div>
<p>If you can&#8217;t find the information on the screen (=stdout), then have a
look in <tt class="docutils literal"><span class="pre">sphere1_log.log</span></tt> which contains a copy of the log messages
that have been printed to stdout.</p>
<p>If we save any fields spatially resolved (as with the
<tt class="docutils literal"><span class="pre">sim.save_data(fields='all')</span></tt> command), then nmag will create a file
with name (in this case) <tt class="docutils literal"><span class="pre">sphere1_dat.h5</span></tt>. In addition to the field
data that is saved, it also stores the finite element mesh <em>in the
order that was used when the file was created</em>. In this example, this
is the mesh ordered according to the output from the ParMETIS
package. The first 177 nodes of the mesh in this order are assigned to
CPU0, the next 185 are assigned to CPU1, and the next 178 are assigned to
CPU2.</p>
<p>We can visualise this partition using the <a class="reference internal" href="manual.html#nmeshpp"><em>nmeshpp</em></a> command (which we
apply here to the mesh that is saved in the <tt class="docutils literal"><span class="pre">sphere1_dat.h5</span></tt> file):</p>
<div class="highlight-python"><pre>$&gt; nmeshpp --partitioning=[177,185,178] sphere1_dat.h5 partitioning.vtk</pre>
</div>
<p>The new file <tt class="docutils literal"><span class="pre">partitioning.vtk</span></tt> contains only one field on the mesh, and this has assigned to each mesh node the id of the associated CPU. We can visualise this, for example, using:</p>
<div class="highlight-python"><pre>$&gt; mayavi -d partitioning.vtk -m SurfaceMap</pre>
</div>
<img alt="_images/sphere3partitions.png" class="align-center" src="_images/sphere3partitions.png" style="width: 800px; height: 664px;" />
<p>The figure shows that the sphere has been divided into three areas
which carry values 0, 1 and 2 (corresponding to the MPI CPU rank which
goes from 0 to 2 for 3 CPUs). Actually, in this plot we can only see
the surface nodes (but the volume nodes have been partitioned
accordingly).</p>
<p>The process described here is a bit cumbersome to visualise the
partition. This could in principle be streamlined (so that we save the
partition data into the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> data file and can generate the
visualisation without further manual intervention). However, we expect
that this is not a show stopper and will dedicate our time to more
pressing issues. (User feedback and suggestions for improvements are
of course always welcome.)</p>
</div>
<div class="section" id="performance">
<span id="id6"></span><h4>Performance<a class="headerlink" href="manual.html#performance" title="Permalink to this headline">¶</a></h4>
<p>Here is some data we have obtained on an IBM x440 system (with eight
1.9Ghz Intel Xeon processors). We use a test simulation (located in
<tt class="docutils literal"><span class="pre">tests/devtests/nmag/hyst/hyst.par</span></tt>) which computes a hysteresis
loop for a fairly small system (4114 mesh nodes, 1522 surface nodes,
BEM size 18MB). We use overdamped time integration to determine the
meta-stable states.</p>
<p>Both the setup and the time required to write data will not become
significantly faster when run on more than one CPU. We provide:</p>
<blockquote>
<div><p><strong>total time</strong>: this includes setup time, time for the main simulation loop and time for writing data (measured in seconds)</p>
<p><strong>total speedup</strong>: The speed up for the total execution time (i.e. ratio of execution time on one CPU to execution time on n CPUs).</p>
<p><strong>sim time</strong>: this is the time spend in the main simulation loop (and this is where expect a speed up)</p>
<p><strong>sim speedup</strong>: the speedup of the main simulation loop</p>
</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="21%" />
<col width="28%" />
<col width="17%" />
<col width="23%" />
</colgroup>
<tbody valign="top">
<tr><td>CPUs</td>
<td>total time</td>
<td>total speedup</td>
<td>sim time</td>
<td>sim speedup</td>
</tr>
<tr><td>1</td>
<td>4165</td>
<td>1.00</td>
<td>3939</td>
<td>1.00</td>
</tr>
<tr><td>2</td>
<td>2249</td>
<td>1.85</td>
<td>2042</td>
<td>1.93</td>
</tr>
<tr><td>3</td>
<td>1867</td>
<td>2.23</td>
<td>1659</td>
<td>2.37</td>
</tr>
<tr><td>4</td>
<td>1605</td>
<td>2.60</td>
<td>1393</td>
<td>2.83</td>
</tr>
</tbody>
</table>
<p>The numbers shown here have been obtained using mpich2 (and using the
<tt class="docutils literal"><span class="pre">ssm</span></tt> device instead of the default <tt class="docutils literal"><span class="pre">sock</span></tt> device: this is
available on Linux and resulted in a 5% reduction of execution time).</p>
<p>Generally, the (network) communication that is required between the
nodes will slow down the communication. The smaller the system, the
more communication has to happen between the nodes (relative to the
amount of time spent on actual calculation). Thus, one expects a
better speed up for larger systems. The performance of the network is
also crucial: generally, we expect the best speed up on very fast
networks and shared memory systems (i.e. multi-CPU / multi-core
architectures). We further expect the speed-up to become worse (in
comparison to the ideal linear speed-up) with an increasing number of
processes.</p>
</div>
</div>
<div class="section" id="restarting-mpi-runs">
<span id="id7"></span><h3>Restarting MPI runs<a class="headerlink" href="manual.html#restarting-mpi-runs" title="Permalink to this headline">¶</a></h3>
<p>There is one situation that should be avoided when exploiting parallel
computation. Usually, a simulation (involving for example a hysteresis
loop), can be continued using the <tt class="docutils literal"><span class="pre">--restart</span></tt> switch. This is also
true for MPI runs.</p>
<p>However, the number of CPUs used <em>must not change</em> between the initial
and any subsequent runs. (The reason for this is that the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt>
file needs to store the mesh as it has been reordered for <em>n</em> CPUs. If
we continue the run with another number of CPUs, the mesh data will
not be correct anymore which will lead to errors when extracting the
data from the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> file.)</p>
<p>Note also that there is currently no warning issued (in Nmag 0.1) if a user ventures
into such a simulation.</p>
</div>
<span id="document-example_excoupling/doc"></span><div class="section" id="more-than-one-magnetic-material-exchange-coupled">
<span id="id1"></span><h3>More than one magnetic material, exchange coupled<a class="headerlink" href="manual.html#more-than-one-magnetic-material-exchange-coupled" title="Permalink to this headline">¶</a></h3>
<p>To be written.</p>
</div>
</div>
</div>
<span id="document-background"></span><div class="section" id="background">
<span id="id1"></span><h2>Background<a class="headerlink" href="manual.html#background" title="Permalink to this headline">¶</a></h2>
<p>In this section, we list some background information on the simulation
package, some explanation of the philosophy behind it (which may
explain some of the user interface choices that have been made) and
explanation of some terms that are relevant.</p>
<div class="section" id="architecture-overview">
<h3>Architecture overview<a class="headerlink" href="manual.html#architecture-overview" title="Permalink to this headline">¶</a></h3>
<img alt="_images/nmag-architecture5007.png" class="align-center" src="_images/nmag-architecture5007.png" style="width: 500px; height: 515px;" />
<p>The Nmag environment that is described in this manual is shown as the blue box labelled <tt class="docutils literal"><span class="pre">Nmag</span> <span class="pre">Simulation</span> <span class="pre">Script</span></tt>. This is importing the <tt class="docutils literal"><span class="pre">nmag</span></tt> library &#8211; which is a Python library. This in turn, is built on the <a class="reference internal" href="manual.html#nsim-library">Nsim library</a> Python module. The nsim Python module uses compiled code which is written in Objective Caml. At this level the execution can be parallel and this is also used to link together existing libraries (yellow boxes).</p>
</div>
<div class="section" id="the-nsim-library">
<span id="nsim-library"></span><h3>The nsim library<a class="headerlink" href="manual.html#the-nsim-library" title="Permalink to this headline">¶</a></h3>
<p>Nmag is the high-level user interface that provides micromagnetic
capabilities to a general purpose finite element multi-physics field
theory library called nsim. Therefore, many of the concepts used by
Nmag are inherited from nsim.</p>
<p>This manual documents the high-level Nmag userinterface, it does not
document nsim. Some of the internal details of nsim are explained
in <a class="reference external" href="http://arxiv.org/abs/arXiv:0907.1587">http://arxiv.org/abs/arXiv:0907.1587</a>.</p>
</div>
<div class="section" id="fields-and-subfields">
<span id="id2"></span><h3>Fields and subfields<a class="headerlink" href="manual.html#fields-and-subfields" title="Permalink to this headline">¶</a></h3>
<div class="section" id="field">
<span id="id3"></span><h4>Field<a class="headerlink" href="manual.html#field" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="manual.html#field"><em>Field</em></a> is the central entity within the <a class="reference internal" href="manual.html#nsim-library"><em>The nsim library</em></a>. It represents physical
fields such as:</p>
<ul class="simple">
<li>magnetisation (usually a 3d vector field),</li>
<li>the magnetic exchange field (usually a 3d vector field), or</li>
<li>magnetic exchange energy (a scalar field).</li>
</ul>
<p>A field may contain degrees of freedom of different type, which belong
to different parts of a simulated object. For example, the
magnetisation field may contain the effective magnetisation (density)
for more than one type of magnetic atoms, which may make up different
parts of the object studied. In order to deal with this, we introduce
the concept of <a class="reference internal" href="manual.html#subfield"><em>Subfield</em></a>s: A Nmag/nsim field can be regarded as a
collection of subfields. Most often, there only is one subfield in a
field, but when it makes sense to group together multiple conceptually
independent fields (such as the effective magnetisation of the iron
atoms in a multilayer structure and that of some other magnetic metal
also present in the structure), a field may contain more than one
subfield: In particular, the magnetisation field <tt class="docutils literal"><span class="pre">M</span></tt> may contain
subfields <tt class="docutils literal"><span class="pre">M_Fe</span></tt> and <tt class="docutils literal"><span class="pre">M_Co</span></tt>.</p>
<p>The question what subfields to group together is partly a question of
design. For Nmag, the relevant choices have been made by the Nmag
developers, so the user should not have to worry about this.</p>
</div>
<div class="section" id="subfield">
<span id="id4"></span><h4>Subfield<a class="headerlink" href="manual.html#subfield" title="Permalink to this headline">¶</a></h4>
<p>Each field contains one or more <a class="reference internal" href="manual.html#subfield"><em>Subfield</em></a>s. For example, a
simulation with two different types of magnetic material (for example
Fe and Dy), has a field <tt class="docutils literal"><span class="pre">m</span></tt> for the normalised magnetisation and
this would contain two subfields <tt class="docutils literal"><span class="pre">m_Fe</span></tt> and <tt class="docutils literal"><span class="pre">m_Dy</span></tt>.</p>
<p>(It is partly a question of philosophy whether different material
magnetisations are treated as subfields in one field, or whether they
are treated as two fields. For now, we have chosen to collect all the
material magnetisations as different subfields in one field.)</p>
<p>Often, a field contains only one subfield and this may carry the same
name as the field.</p>
</div>
</div>
<div class="section" id="fields-and-subfields-in-nmag">
<span id="id5"></span><h3>Fields and Subfields in Nmag<a class="headerlink" href="manual.html#fields-and-subfields-in-nmag" title="Permalink to this headline">¶</a></h3>
<div class="section" id="example-one-magnetic-material">
<span id="id6"></span><h4>Example: one magnetic material<a class="headerlink" href="manual.html#example-one-magnetic-material" title="Permalink to this headline">¶</a></h4>
<p>Assuming we have a simulation of one material with name PermAlloy (Py),
we would have the following <a class="reference internal" href="manual.html#field"><em>Field</em></a>s and <a class="reference internal" href="manual.html#subfield"><em>Subfield</em></a>s:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="20%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Field</th>
<th class="head">Subfield</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>m</td>
<td>m_Py</td>
<td>normalised magnetisation</td>
</tr>
<tr><td>M</td>
<td>M_Py</td>
<td>magnetisation</td>
</tr>
<tr><td>H_total</td>
<td>H_total_Py</td>
<td>total effective field</td>
</tr>
<tr><td>H_ext</td>
<td>H_ext</td>
<td>external (applied) field (only one)</td>
</tr>
<tr><td>E_ext</td>
<td>E_ext_Py</td>
<td>energy density of Py due to external field</td>
</tr>
<tr><td>H_anis</td>
<td>H_anis_Py</td>
<td>crystal anisotropy field</td>
</tr>
<tr><td>E_anis</td>
<td>E_anis_Py</td>
<td>crystal anisotropy energy density</td>
</tr>
<tr><td>H_exch</td>
<td>H_exch_Py</td>
<td>exchange field</td>
</tr>
<tr><td>E_exch</td>
<td>E_exch_Py</td>
<td>exchange energy</td>
</tr>
<tr><td>H_demag</td>
<td>H_demag</td>
<td>demagnetisation field (only one)</td>
</tr>
<tr><td>E_demag</td>
<td>E_demag_Py</td>
<td>demagnetisation field energy density for Py</td>
</tr>
<tr><td>phi</td>
<td>phi</td>
<td>scalar potential for H_demag</td>
</tr>
<tr><td>rho</td>
<td>rho</td>
<td>magnetic charge density (div M)</td>
</tr>
<tr><td>H_total</td>
<td>H_total_Py</td>
<td>total effective field</td>
</tr>
</tbody>
</table>
<p>It is worth noting that the names of the fields are fixed whereas the
subfield names are (often) material dependent and given by</p>
<ul class="simple">
<li>the name of the field and the material name (joined through &#8216;<tt class="docutils literal"><span class="pre">_</span></tt>&#8216;)
if there is one (material-specific) subfield for every magnetisation or</li>
<li>the name of the field if there is only one subfield (such as the
demagnetisation field or the applied external field)</li>
</ul>
<p>This may seem a little bit confusing at first, but is easy to
understand once one accepts the general rule that the
material-dependent quantities - and only those - contain a
material-related suffix. All atomic species experience the
demagnetisation field in the same way, so this has to be <tt class="docutils literal"><span class="pre">H_demag</span></tt>
(i.e. non-material-specific). On the other hand, anisotropy depends on
the atomic species, so this is <tt class="docutils literal"><span class="pre">H_anis_Py</span></tt>, and therefore, the total
effective field also has to be material-specific: <tt class="docutils literal"><span class="pre">H_total_Py</span></tt>. (All
this becomes particularly relevant in systems where two types of
magnetic atoms are embedded in the same crystal lattice.)</p>
</div>
<div class="section" id="example-two-magnetic-materials">
<span id="id7"></span><h4>Example: two magnetic materials<a class="headerlink" href="manual.html#example-two-magnetic-materials" title="Permalink to this headline">¶</a></h4>
<p>This table from the <a class="reference internal" href="manual.html#example-two-different-magnetic-materials"><em>Example: two different magnetic materials</em></a> shows
the fields and subfields when more than one material is involved:</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="28%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Field</th>
<th class="head">Subfield(s)</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>m</td>
<td>m_Py, m_Co</td>
<td>normalised magnetisation</td>
</tr>
<tr><td>M</td>
<td>M_Py, M_Co</td>
<td>magnetisation</td>
</tr>
<tr><td>H_total</td>
<td>H_total_Py, H_total_Co</td>
<td>total effective field</td>
</tr>
<tr><td>H_ext</td>
<td>H_ext</td>
<td>external (applied) field (only one)</td>
</tr>
<tr><td>E_ext</td>
<td>E_ext_Py, E_ext_Co</td>
<td>energy density of Py due to external field</td>
</tr>
<tr><td>H_anis</td>
<td>H_anis_Py, H_anis_Co</td>
<td>crystal anisotropy field</td>
</tr>
<tr><td>E_anis</td>
<td>E_anis_Py, E_anis_Co</td>
<td>crystal anisotropy energy density</td>
</tr>
<tr><td>H_exch</td>
<td>H_exch_Py, H_exch_Co</td>
<td>exchange field</td>
</tr>
<tr><td>E_exch</td>
<td>E_exch_Py, E_exch_Co</td>
<td>exchange energy</td>
</tr>
<tr><td>H_demag</td>
<td>H_demag</td>
<td>demagnetisation field (only one)</td>
</tr>
<tr><td>E_demag</td>
<td>E_demag_Py, E_demag_Co</td>
<td>demagnetisation field energy density</td>
</tr>
<tr><td>phi</td>
<td>phi</td>
<td>scalar potential for H_demag</td>
</tr>
<tr><td>rho</td>
<td>rho</td>
<td>magnetic charge density (div M)</td>
</tr>
<tr><td>H_total</td>
<td>H_total_Py, H_total_Co</td>
<td>total effective field</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="obtaining-and-setting-subfield-data">
<span id="id8"></span><h4>Obtaining and setting subfield data<a class="headerlink" href="manual.html#obtaining-and-setting-subfield-data" title="Permalink to this headline">¶</a></h4>
<p>Data contained in subfields can be written to files (using
<a class="reference internal" href="manual.html#save-data"><em>save_data</em></a>), can be probed at particular points in space
(<a class="reference internal" href="manual.html#probe-subfield"><em>probe_subfield</em></a>, <a class="reference internal" href="manual.html#probe-subfield-siv"><em>probe_subfield_siv</em></a>), or can be obtained from all
sites simultaneously (<a class="reference internal" href="manual.html#get-subfield"><em>get_subfield</em></a>). Some data can also be set (in
particular the applied field <tt class="docutils literal"><span class="pre">H_ext</span></tt> using <a class="reference internal" href="manual.html#set-h-ext"><em>set_H_ext</em></a> and all the
subfields belonging to the field <tt class="docutils literal"><span class="pre">m</span></tt> using <a class="reference internal" href="manual.html#set-m"><em>set_m</em></a>).</p>
</div>
<div class="section" id="primary-and-secondary-fields">
<span id="id9"></span><h4>Primary and secondary fields<a class="headerlink" href="manual.html#primary-and-secondary-fields" title="Permalink to this headline">¶</a></h4>
<p>There are two different types of fields in nmag: <em>primary</em> and
<em>secondary</em> fields.</p>
<p><em>Primary fields</em> are those that the user can set
arbitrarily. Currently, these are the (normalised) magnetisation <tt class="docutils literal"><span class="pre">m</span></tt>
and the external field <tt class="docutils literal"><span class="pre">H_ext</span></tt> (which can be modified with <a class="reference internal" href="manual.html#set-m"><em>set_m</em></a>
and <a class="reference internal" href="manual.html#set-h-ext"><em>set_H_ext</em></a>).</p>
<p><em>Secondary</em> fields (which could also be called <em>dependent fields</em>) can
not be set directly from the user but are computed from the primary
fields.</p>
</div>
</div>
<div class="section" id="mesh">
<span id="id10"></span><h3>Mesh<a class="headerlink" href="manual.html#mesh" title="Permalink to this headline">¶</a></h3>
<p>In finite element calculations, we need a mesh to define the geometry
of the system. For development and debugging purposes, nsim includes
some (at present undocumented) capabilities to generate toy meshes
directly from geometry specifications, but for virtually all nsim
applications, the user will have to use an external tool to generate a
(tetrahedral) mesh file describing the geometry.</p>
<div class="section" id="node">
<span id="id11"></span><h4>Node<a class="headerlink" href="manual.html#node" title="Permalink to this headline">¶</a></h4>
<p>Roughly speaking, a mesh is a tessellation of space where the support
points are called <em>mesh nodes</em>. nmag uses an unstructured mesh
(i.e. the cells filling up three-dimensional space are tetrahedra).</p>
</div>
<div class="section" id="node-id">
<span id="id12"></span><h4>node id<a class="headerlink" href="manual.html#node-id" title="Permalink to this headline">¶</a></h4>
<p>Each node in the finite element mesh has an associated node id. This
is an integer (starting from 0 for the first node).</p>
<p>This information is used when defining which node is connected to
which (see <a class="reference internal" href="manual.html#finite-element-mesh-generation"><em>Finite element mesh generation</em></a> for more details), and
when defining the <a class="reference internal" href="manual.html#site"><em>sites</em></a> at which the field degrees of freedom are
calculated.</p>
</div>
<div class="section" id="node-position">
<span id="id13"></span><h4>node position<a class="headerlink" href="manual.html#node-position" title="Permalink to this headline">¶</a></h4>
<p>The position (as a 3d vector) in space of a node.</p>
</div>
</div>
<div class="section" id="site">
<span id="id14"></span><h3>Site<a class="headerlink" href="manual.html#site" title="Permalink to this headline">¶</a></h3>
<p>A <a class="reference internal" href="manual.html#mesh"><em>Mesh</em></a> has nodes, and each node is identified by its <a class="reference internal" href="manual.html#node-id"><em>node id</em></a>.</p>
<p>If we use <em>first order basis functions</em> in the finite element
calculation, then a <em>site</em> is exactly the same as a <em>node</em>. In
micromagnetism, we almost always use first order basis functions
(because the requirement to resolve the exchange length forces us to
have a very fine mesh, and usually the motivation of using higher
order basis functions is to make the mesh coarser).</p>
<p>If we were to use <em>second</em> or <em>higher order base functions</em>, then we
have more sites than nodes. In a second order basis function
calculation, we identify sites by a tuple of <a class="reference internal" href="manual.html#node-id"><em>node id</em></a>.</p>
</div>
<div class="section" id="si-object">
<span id="id15"></span><h3>SI object<a class="headerlink" href="manual.html#si-object" title="Permalink to this headline">¶</a></h3>
<p>We are using a special <tt class="docutils literal"><span class="pre">SI</span></tt> object to express physical entities (see
also <a class="reference internal" href="manual.html#si"><em>SI</em></a>). Let us first clarify some terminology:</p>
<dl class="docutils">
<dt>physical entity</dt>
<dd>A pair (a,b) where a is a number (for example 10) and b is a product
of powers of dimensions (for example m^1s^-1) which we need to
express a physical quantity (in this example 10 m/s).</dd>
<dt>dimension</dt>
<dd>SI dimensions: meters (m), seconds (s), Ampere (A), kilogram (kg), Kelvin
(K), Mol (mol), candela (cd). These can be obtained using the <a class="reference internal" href="manual.html#units"><em>units</em></a> attribute of the <a class="reference internal" href="manual.html#si"><em>SI</em></a> object.</dd>
<dt>SI-value</dt>
<dd>for a given physical entity (a,b) where a is the numerical value and
b are the SI dimensions, this is just the numerical value a (and can be
obtained with the <a class="reference internal" href="manual.html#value"><em>value</em></a> attribute of the <a class="reference internal" href="manual.html#si"><em>SI</em></a> object).</dd>
<dt>Simulation Units</dt>
<dd>The dimensionless number that expressed an entity within the
simulation core. This is irrelevant to the user, except in highly
exotic situations.</dd>
</dl>
<p>There are several reasons for using SI objects:</p>
<ul class="simple">
<li>In the context of the micromagnetic simulations, the use of SI
objects avoids ambiguity as the user has to specify the right
dimensions and - where possible - the code will complain if these
are unexpected units (such as in the definition of material
parameters).</li>
<li>The specification of units is more important when the
micromagnetism is extended with other physical phenomena (moving
towards multi-physics calculations) for which, in principle, the
software cannot predict what units these will have.</li>
<li>Some convenience in having a choice of how to specify, for example,
magnetic fields (i.e. <tt class="docutils literal"><span class="pre">A/m</span></tt>, <tt class="docutils literal"><span class="pre">T/mu0</span></tt>, <tt class="docutils literal"><span class="pre">Oe</span></tt>). See also comments
in <a class="reference internal" href="manual.html#set-h-ext"><em>set_H_ext</em></a>.</li>
</ul>
<div class="section" id="library-of-useful-si-constants">
<span id="id16"></span><h4>Library of useful si constants<a class="headerlink" href="manual.html#library-of-useful-si-constants" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">si</span></tt> name space in nmag provides the following constants:</p>
<pre class="literal-block">
&#8220;&#8221;&#8220;Some useful SI constants&#8221;&#8220;&#8221;
import math
from lib import SI
kilogram = SI(1.0,[&#8220;kg&#8221;,1])  #: The kilogram
meter = SI(1.0,[&#8220;m&#8221;,1])      #: The meter
metre = meter                #  alternative spelling
Ampere = SI(1.0,[&#8220;A&#8221;,1])     #: The Ampere
Kelvin = SI(1.0,[&#8220;K&#8221;,1])     #: The Kelvin
second = SI(1.0,[&#8220;s&#8221;,1])     #: The second
candela = SI(1.0,[&#8220;cd&#8221;,1])   #: The candela
mol = SI(1.0,[&#8220;mol&#8221;,1])      #: The mol

#specific units for magnetism
Newton = kilogram*meter/second**2          #: Newton
mu0 = SI(4.0e-7*math.pi, &#8220;N/A^2&#8221;)          #: vacuum permeability mu0
Tesla = kilogram/Ampere/second**2          #: Tesla
Gauss = 1e-4*kilogram/Ampere/second**2     #: Gauss
Oersted=Gauss/mu0                          #: Oersted
Oe=Oersted                                 #: Oersted
gamma0 = SI(-2.2137286285040001e5, &#8220;m/A s&#8221;)#: gyromagnetic ratio gamma0

# units: degrees/nanosecond: Useful to specify the stopping_dm_dt
degrees_per_ns = SI(math.pi/180.0)/SI(1e-9, &#8220;s&#8221;)

# other units and constants
Joule = SI(&#8220;J&#8221;)
bohr_magneton = 9.2740094980e-24*Joule/Tesla # Bohr magneton
positron_charge = SI(1.6021765314e-19, &#8220;C&#8221;)
electron_charge =  -positron_charge
boltzmann_constant = SI(1.3806504e-23, &#8220;J/K&#8221;)
plank_constant = 6.6260689633e-34*Joule*second
reduced_plank_constant = plank_constant/(2*math.pi)


</pre>
<p>To express the magnetisation in A/m equivalent to the polaration of 1
Tesla, we could thus use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">si</span>

<span class="n">myM</span> <span class="o">=</span> <span class="mf">1.5</span><span class="o">*</span><span class="n">si</span><span class="o">.</span><span class="n">Tesla</span><span class="o">/</span><span class="n">si</span><span class="o">.</span><span class="n">mu0</span>
</pre></div>
</div>
<p>The command reference for <a class="reference internal" href="manual.html#si"><em>SI</em></a> provides some more details on the behaviour of SI objects.</p>
</div>
</div>
<div class="section" id="terms">
<span id="id17"></span><h3>Terms<a class="headerlink" href="manual.html#terms" title="Permalink to this headline">¶</a></h3>
<div class="section" id="stage-step-iteration-time-etc">
<span id="id18"></span><h4>Stage, Step, iteration, time, etc.<a class="headerlink" href="manual.html#stage-step-iteration-time-etc" title="Permalink to this headline">¶</a></h4>
<p>We use the same terminology for hysteresis loops as <a class="reference external" href="http://math.nist.gov/oommf/">OOMMF</a> (stage, step, iteration, time) and extend this slightly:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">step:</th><td class="field-body"><p class="first">A step is the smallest possible change of the fields. This
corresponds (usually) to carrying out a time integration of the
system over a small amount of time <cite>dt</cite>. Step is an integer starting
from 0.</p>
<p>If we minimise energy (rather than computing the time development
exactly), then a step may not necessarily refer to progressing the
simulation through real time.</p>
</td>
</tr>
<tr class="field"><th class="field-name">iteration:</th><td class="field-body"><p class="first">Another term for Step (deprecated)</p>
</td>
</tr>
<tr class="field"><th class="field-name">stage:</th><td class="field-body"><p class="first">An integer to identify all the calculations carried out at one
(constant) applied magnetic field (as in <a class="reference external" href="http://math.nist.gov/oommf/">OOMMF</a>).</p>
</td>
</tr>
<tr class="field"><th class="field-name">time:</th><td class="field-body"><p class="first">The time that has been simulated (typically of the order of
pico- or nanoseconds).</p>
</td>
</tr>
<tr class="field"><th class="field-name">id:</th><td class="field-body"><p class="first">This is an integer (starting from 0) that uniquely identifies
saved data. <em>I. e.</em> whenever data is saved, this number will increase by
1. It is available in the <a class="reference internal" href="manual.html#h5-data-files"><em>h5 data file</em></a> and the <a class="reference internal" href="manual.html#ndt"><em>Data files (.ndt)</em></a> data files,
and thus allows
to match data in the ndt files with the corresponding (spatially resolved)
field data in the h5 file.</p>
</td>
</tr>
<tr class="field"><th class="field-name">stage_step:</th><td class="field-body"><p class="first">The number of steps since we have started the current stage.</p>
</td>
</tr>
<tr class="field"><th class="field-name">stage_time:</th><td class="field-body"><p class="first">The amount of time that has been simulated since we started this stage.</p>
</td>
</tr>
<tr class="field"><th class="field-name">real_time:</th><td class="field-body"><p class="first">The amount of real time the simulation has been running
(this is the [wall] execution time) and therefore typically of the
order of minutes to days.</p>
</td>
</tr>
<tr class="field"><th class="field-name">local_time:</th><td class="field-body"><p class="first">A string (human readable) with the local time. Useful in
data files to see when an entry was saved.</p>
</td>
</tr>
<tr class="field"><th class="field-name">unix_time:</th><td class="field-body"><p class="first last">The number of (non-leap) seconds since 1.1.1970 - this is
the same information as local_time but represented in a more computer
friendly way for computing differences.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="some-geek-talk-deciphered">
<span id="id19"></span><h4>Some geek-talk deciphered<a class="headerlink" href="manual.html#some-geek-talk-deciphered" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>nmag uses some object orientation in the high-level user interface</dt>
<dd>presented here. There are a few special terms used in object
orientation that may not be familiar and of which we attempt to give
a very brief description:</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">method:</th><td class="field-body">A method is just a function that is associated to an object.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="solvers-and-tolerance-settings">
<span id="id20"></span><h3>Solvers and tolerance settings<a class="headerlink" href="manual.html#solvers-and-tolerance-settings" title="Permalink to this headline">¶</a></h3>
<p>There are a number of linear algebra solvers and one solver for
ordinary differential equations (ODEs) in nmag:</p>
<ol class="arabic">
<li><p class="first">two solvers for the calculation of the demagnetisation
field. Default values can be modified when creating the <a class="reference internal" href="manual.html#simulation"><em>Simulation</em></a>
object (this user interface is not final &#8211; if you really feel you
would like to change the defaults, please contact the <a class="reference internal" href="manual.html#contact"><em>nmag team</em></a> so
we can take your requirements into account in the next release).</p>
</li>
<li><p class="first">one solver for the system of algebraic equations that results from
the time integrator&#8217;s implicit integration scheme.</p>
<p>(We need to document the default settings and how to modify this.)</p>
</li>
<li><p class="first">the ODE integrator.</p>
<p>Setting of the tolerances for the ODE integrator can be done with
<a class="reference internal" href="manual.html#set-params"><em>set_params</em></a>. An example of this is shown in section <a class="reference internal" href="manual.html#example-tolerances"><em>Example: Timestepper tolerances</em></a>.</p>
</li>
</ol>
<p>We expect that for most users, the tolerances of the ODE integrator
are most important (see <a class="reference internal" href="manual.html#example-tolerances"><em>Example: Timestepper tolerances</em></a>) as this greatly affects
the performance of the simulation.</p>
</div>
<div class="section" id="the-equation-of-motion-the-landau-lifshitz-gilbert-equation">
<h3>The equation of motion: the Landau-Lifshitz-Gilbert equation<a class="headerlink" href="manual.html#the-equation-of-motion-the-landau-lifshitz-gilbert-equation" title="Permalink to this headline">¶</a></h3>
<p>The magnetisation evolution, as computed by the <a class="reference internal" href="manual.html#advance-time"><em>advance_time</em></a> or the
<a class="reference internal" href="manual.html#hysteresis"><em>hysteresis</em></a> methods of the <tt class="docutils literal"><span class="pre">Simulation</span></tt> class, is determined by the
following equation of motion:</p>
<blockquote>
<div>dM/dt = -llg_gamma_G * M x H + llg_damping * M x dM/dt,</div></blockquote>
<p>which is the Landau-Lifshitz-Gilbert equation (we often use the abbreviation
&#8220;LLG&#8221;), a vector equation, where <tt class="docutils literal"><span class="pre">M</span></tt>, <tt class="docutils literal"><span class="pre">H</span></tt> and <tt class="docutils literal"><span class="pre">dM/dt</span></tt> are three
dimensional vectors and <tt class="docutils literal"><span class="pre">x</span></tt> represent the vector product.
This equation is used to dermine the evolution of each component
of the magnetisation.
For example, if the system has two materials with name <tt class="docutils literal"><span class="pre">m1</span></tt> and <tt class="docutils literal"><span class="pre">m2</span></tt>,
then the magnetisation has two components <tt class="docutils literal"><span class="pre">M_m1</span></tt> and <tt class="docutils literal"><span class="pre">M_m2</span></tt> and
the equations:</p>
<blockquote>
<div><p>dM_m1/dt = -llg_gamma_G_m1 * M_m1 x H_m1 + llg_damping_m1 * M_m1 x dM_m1/dt,</p>
<p>dM_m2/dt = -llg_gamma_G_m2 * M_m2 x H_m2 + llg_damping_m2 * M_m2 x dM_m2/dt,</p>
</div></blockquote>
<p>determine the dynamics of <tt class="docutils literal"><span class="pre">M_m1</span></tt> and <tt class="docutils literal"><span class="pre">M_m2</span></tt>.
Here <tt class="docutils literal"><span class="pre">H_m1</span></tt> and <tt class="docutils literal"><span class="pre">H_m2</span></tt> are the effective fields relative to the two
components, while with <tt class="docutils literal"><span class="pre">dM_m1/dt</span></tt> and <tt class="docutils literal"><span class="pre">dM_m2/dt</span></tt> we denote the two time
derivatives. The constant <tt class="docutils literal"><span class="pre">llg_gamma_G_XX</span></tt> in front of the precession term
in the LLG equation is often called &#8220;gyromagnetic ratio&#8221;, even if usually,
in physics, the gyromagnetic ratio of a particle is the ratio between its
magnetic dipole moment and its angular momentum (and has units <tt class="docutils literal"><span class="pre">A</span> <span class="pre">s/kg</span></tt>).
It is then an improper nomenclature, but it occurs frequently in the
literature. The <tt class="docutils literal"><span class="pre">llg_damping_XX</span></tt> constant is called damping constant.
Notice that these two constants are specified on a per-material basis.
This means that each material has its own pair of constants
(<tt class="docutils literal"><span class="pre">llg_gamma_G_m1</span></tt>, <tt class="docutils literal"><span class="pre">llg_damping_m1</span></tt>) and
(<tt class="docutils literal"><span class="pre">llg_gamma_G_m2</span></tt>, <tt class="docutils literal"><span class="pre">llg_damping_m2</span></tt>).
The two constants are specified when the corresponding material is created
using the <a class="reference internal" href="manual.html#magmaterial"><em>MagMaterial</em></a> class.</p>
</div>
</div>
<span id="document-command_reference"></span><div class="section" id="command-reference">
<span id="id1"></span><h2>Command reference<a class="headerlink" href="manual.html#command-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="magmaterial">
<span id="id2"></span><h3>MagMaterial<a class="headerlink" href="manual.html#magmaterial" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">MagMaterial</span></tt></dd>
<dt>Class constructor information:</dt>
<dd><div class="first last highlight-python"><pre>(self,
name,
Ms=SI(0.86e6, "A/m"),
llg_damping=SI(0.5),
llg_gamma_G=SI(2.210173e5, "m/A s"),
exchange_coupling=SI(1.3e-11, "J/m"),
anisotropy=None,
anisotropy_order=None,
do_precession=True)</pre>
</div>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>name</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the material. This will be used in the names of
material dependent fields and subfields. Must be alphanumeric
(i.e. contain only the characters 0-9_a-zA-Z)
Examples: <tt class="docutils literal"><span class="pre">'Py'</span></tt>, <tt class="docutils literal"><span class="pre">'Fe_1'</span></tt>,  <tt class="docutils literal"><span class="pre">'Fe_2'</span></tt></p>
</dd>
<dt><cite>Ms</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">The saturation magnetisation of the material (in Ampere per
meter).</p>
<p class="last">Example (and default (PermAlloy) value): <tt class="docutils literal"><span class="pre">SI(0.86e6,&quot;A/m&quot;)</span></tt></p>
</dd>
<dt><cite>llg_gamma_G</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">The constant in front of the precession term in the LLG equation:</p>
<blockquote>
<div><p>dM/dt = -llg_gamma_G * M x H + llg_damping * M x dM/dt</p>
</div></blockquote>
<p>It is often called gyromagnetic ratio, even if usually, in physics,
the gyromagnetic ratio of a particle is the ratio between its magnetic
dipole moment and its angular momentum (and has units A*s/kg).
It is then an improper nomenclature, but it occurs frequently in the
literature.</p>
<p class="last">Example (and default value): <tt class="docutils literal"><span class="pre">SI(2.210173e5,</span> <span class="pre">&quot;m/A</span> <span class="pre">s&quot;)</span></tt>.</p>
</dd>
<dt><cite>llg_damping</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">The damping parameter (often called alpha). Optimum damping
for 1.0, realistic values are of the order of 0.01. The
default value (as in OOMMF) is 0.5.</p>
<p class="last">Example (and default value): <tt class="docutils literal"><span class="pre">SI(0.5,&quot;&quot;)</span></tt></p>
</dd>
<dt><cite>exchange_coupling</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">The coupling strength for the exchange interaction in Joule
per meter.</p>
<p class="last">Example (and default value): <tt class="docutils literal"><span class="pre">SI(1.3e-11,</span> <span class="pre">&quot;J/m&quot;)</span></tt></p>
</dd>
<dt><cite>anisotropy</cite> <span class="classifier-delimiter">:</span> <span class="classifier">PredefinedAnisotropy Object  or function(vector) -&gt; SI Object</span></dt>
<dd><p class="first">Either a predefined anisotropy (such as returned by
<a class="reference internal" href="manual.html#uniaxial-anisotropy">uniaxial_anisotropy</a> or <a class="reference internal" href="manual.html#cubic-anisotropy">cubic_anisotropy</a>), or a custom
function (which must be polynomial in the components of <tt class="docutils literal"><span class="pre">m</span></tt>)
<tt class="docutils literal"><span class="pre">a(m)</span></tt> that computes anisotropy energy density
as a function of the (normalised) magnetisation direction <tt class="docutils literal"><span class="pre">m</span></tt>.</p>
<p>If you specify a custom anisotropy function, you also
need to pass the order of the polynomial in the <tt class="docutils literal"><span class="pre">anisotropy_order</span></tt>
parameter.</p>
<p class="last">Default value is <tt class="xref docutils literal"><span class="pre">None</span></tt>, that is, no anisotropy term
is used.</p>
</dd>
<dt><cite>anisotropy_order</cite> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first">If a custom polynomial anisotropy function <tt class="docutils literal"><span class="pre">a(m)</span></tt> is specified, the order
of the polynomial must be given in this parameter. This is not required
for pre-defined <a class="reference internal" href="manual.html#uniaxial-anisotropy">uniaxial_anisotropy</a> or <a class="reference internal" href="manual.html#cubic-anisotropy">cubic_anisotropy</a> anisotropy
functions.</p>
<p class="last">Default value is <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
</dd>
<dt><cite>do_precession</cite> <span class="classifier-delimiter">:</span> <span class="classifier">True or False</span></dt>
<dd><p class="first last">Boolean that can switch off the precessional term in the LLG
equation. This is useful to improve convergence speed
when studying metastable configurations.</p>
</dd>
<dt><cite>properties</cite>: list of strings (default: [&#8220;magnetic&#8221;,&#8221;material&#8221;])</dt>
<dd><p class="first">A list of additional properties this material will be associated with.
Normally, users do not have to change this, but it is used internally
when setting up discretized operators.</p>
<p class="last">Example (and default value): <tt class="xref docutils literal"><span class="pre">True</span></tt></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="section" id="uniaxial-anisotropy">
<span id="id3"></span><h4>uniaxial_anisotropy<a class="headerlink" href="manual.html#uniaxial-anisotropy" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">uniaxial_anisotropy</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(axis,</span> <span class="pre">K1,</span> <span class="pre">K2=0)</span></tt></dd>
</dl>
<p>Returns a predefined anisotropy modelling an uniaxial anisotropy energy density term:</p>
<div class="highlight-python"><pre>E_anis = - K1 * &lt;axis, m&gt;^2 - K2 * &lt;axis, m&gt;^4</pre>
</div>
<p>(where <cite>m</cite> is the (normalised) magnetization.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>axis</cite> <span class="classifier-delimiter">:</span> <span class="classifier">vector (=list)</span></dt>
<dd><p class="first last">Easy axis (or hard axis, if K1 &lt; 0; will be normalised).</p>
</dd>
<dt><cite>K1</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first last">Second-order phenomenological anisotropy constant (as used in the equation above).</p>
</dd>
<dt><cite>K2</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">Fourth-order phenomenological anisotropy constant (as used in the equation above).</p>
<p class="last">Default value is <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cubic-anisotropy">
<span id="id4"></span><h4>cubic_anisotropy<a class="headerlink" href="manual.html#cubic-anisotropy" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">cubic_anisotropy</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(axis1,</span> <span class="pre">axis2,</span> <span class="pre">K1,</span> <span class="pre">K2=0,</span> <span class="pre">K3=0)</span></tt></dd>
</dl>
<p>Returns a predefined anisotropy modelling a cubic anisotropy energy density term:</p>
<div class="highlight-python"><pre>E_anis = K1 * (&lt;axis1,m&gt;^2 &lt;axis2,m&gt;^2 + &lt;axis1,m&gt;^2 &lt;axis3,m&gt;^2 + &lt;axis2,m&gt;^2 &lt;axis3,m&gt;^2)
       + K2 * (&lt;axis1,m&gt;^2 &lt;axis2,m&gt;^2 &lt;axis3,m&gt;^2)
       + K3 * (&lt;axis1,m&gt;^4 &lt;axis2,m&gt;^4 + &lt;axis1,m&gt;^4 &lt;axis3,m&gt;^4 + &lt;axis2,m&gt;^4 &lt;axis3,m&gt;^4)</pre>
</div>
<p>(where <cite>m</cite> is the (normalised) magnetisation.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>axis1</cite> <span class="classifier-delimiter">:</span> <span class="classifier">vector (=list)</span></dt>
<dd><p class="first last">First cubic anisotropy axis (will be normalised).</p>
</dd>
<dt><cite>axis2</cite> <span class="classifier-delimiter">:</span> <span class="classifier">vector (=list)</span></dt>
<dd><p class="first last">Second cubic anisotropy axis (will be orthonormalised with regards to <cite>axis1</cite>).</p>
</dd>
<dt><cite>K1</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first last">Fourth-order phenomenological anisotropy constant (as used in the equation above).</p>
</dd>
<dt><cite>K2</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">Sixth-order phenomenological anisotropy constant (as used in the equation above).</p>
<p class="last">Default value is <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
</dd>
<dt><cite>K3</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">Eigth-order phenomenological anisotropy constant (as used in the equation above).</p>
<p class="last">Default value is <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="simulation">
<span id="id5"></span><h3>Simulation<a class="headerlink" href="manual.html#simulation" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation</span></tt></dd>
<dt>Class constructor information:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">name=None,</span> <span class="pre">phi_BEM=None,</span> <span class="pre">periodic_bc=None,</span> <span class="pre">do_demag=True,</span> <span class="pre">do_anisotropy_jacobian=False,</span> <span class="pre">temperature=None,</span> <span class="pre">thermal_delta_t=None,</span> <span class="pre">user_seed_T=0,</span> <span class="pre">timestepper_max_order=2,</span> <span class="pre">timestepper_krylov_max=300,</span> <span class="pre">ksp_tolerances={},</span> <span class="pre">adjust_tolerances=False,</span> <span class="pre">use_pvode=True,</span> <span class="pre">lam_debugfile=None)</span></tt></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>name</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">Name of the simulation object; this is used e.g. for prefixing
filenames created by nmag.</p>
<p class="last">Default value is the name of the current script (sans extension).</p>
</dd>
<dt><cite>do_demag</cite> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Pass <tt class="xref docutils literal"><span class="pre">False</span></tt> to disable the demagnetisation field.</p>
</dd>
<dt><cite>do_anisotropy_jacobian</cite> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">Pass <tt class="xref docutils literal"><span class="pre">True</span></tt> to enable the inclusion of derivatives from the
anisotropy into the Jacobian. (Complicated anisotropy terms may blow
up memory requirements for the Jacobian.)</p>
<p class="last">Default value is <tt class="xref docutils literal"><span class="pre">True</span></tt>.</p>
</dd>
<dt><cite>temperature</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">Simulated temperature (unless equal to None, stochastic thermal
fluctuations will be enabled).</p>
<p class="last">Currently not supported (since July 2008)</p>
</dd>
<dt><cite>thermal_delta_t</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">Time step to use when stochastic thermal fluctuations are enabled.</p>
<p class="last">Currently not supported (since July 2008)</p>
</dd>
<dt><cite>timestepper_max_order</cite> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first">Maximum order for the time integrator (we use the BDF method).</p>
<p class="last">Default value is 2.</p>
</dd>
<dt><cite>timestepper_krylov_max</cite> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first">Maximum dimension of the Krylov subspace to be used in the time
integrator.</p>
<p class="last">Default (recommended) value is 300.</p>
</dd>
<dt><cite>ksp_tolerances</cite>: dictionary</dt>
<dd><p class="first">Keys to this dictionary are:
DBC.rtol DBC.atol DBC.dtol DBC.maxits
NBC.rtol NBC.atol NBC.dtol NBC.maxits</p>
<p class="last">Values are the petsc KSP-solver tolerances for the Dirichlet and
von Neumann Laplace solvers used internally to compute the magnetic
scalar potential from magnetic charge density.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="section" id="advance-time">
<span id="id6"></span><h4>advance_time<a class="headerlink" href="manual.html#advance-time" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.advance_time</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">target_time,</span> <span class="pre">max_it=-1,</span> <span class="pre">exact_tstop=None)</span></tt></dd>
</dl>
<p>This method carries out the time integration of the
Landau-Lifshitz and Gilbert equation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>target_time</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first last">The simulation will run until this time is reached. If the target_time is
zero, this will simply update all fields.</p>
</dd>
<dt><cite>max_it</cite> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The maximum number of iterations (steps) to be carried out
in this time integration call. If set to <tt class="docutils literal"><span class="pre">-1</span></tt>, then there is no limit.</p>
</dd>
<dt><cite>exact_tstop</cite> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">When exact_tstop is True, the time integration is advanced exactly
up to the given target_time. When False, the time integration ends
&#8220;close&#8221; to the target_time. The latter option can result in better
performance, since the time integrator is free to choose time
steps which are as wide as possible. When exact_tstop is not
given, or is None, the default value for this option will be used.
The default value can be set using the method set_params, which
should hence be used to control the behaviour of the hysteresis
and relax methods.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="get-subfield">
<span id="id7"></span><h4>get_subfield<a class="headerlink" href="manual.html#get-subfield" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.get_subfield</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">subfieldname,</span> <span class="pre">units=None)</span></tt></dd>
</dl>
<p>Given a subfieldname, this will return a numpy-array
containing all the data (one element for each site).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield, for example <tt class="docutils literal"><span class="pre">m_Py</span></tt> or <tt class="docutils literal"><span class="pre">H_demag</span></tt>.</p>
</dd>
</dl>
<p><cite>units</cite> : SI object</p>
<blockquote>
<div><p>Optional parameter. If it is provided, then the entity is
expressed in these units. If it is not provided, then the
correct SI dimensions for this subfield are looked up, and
<a class="reference internal" href="manual.html#si-object"><em>SI-value</em></a>s are returned.</p>
<p>If you would like to see simulation units in the output,
then use <tt class="docutils literal"><span class="pre">SI(1)</span></tt>.</p>
<p>In short: if you omit the second parameter, you will
obtain SI values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><cite>data</cite> : numpy-array</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="get-subfield-positions">
<span id="id8"></span><h4>get_subfield_positions<a class="headerlink" href="manual.html#get-subfield-positions" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.get_subfield_positions</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">subfieldname,</span> <span class="pre">pos_units=SI(1,['m',1.0]))</span></tt></dd>
</dl>
<p>This function provides the positions of the sites for data
obtained with <a class="reference internal" href="manual.html#get-subfield">get_subfield</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield, for example <tt class="docutils literal"><span class="pre">m_Py</span></tt> or <tt class="docutils literal"><span class="pre">H_demag</span></tt>.</p>
</dd>
<dt><cite>pos_units</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">Specifies the physical dimension in which positions are to be expressed.
Default is <tt class="docutils literal"><span class="pre">SI(1,'m')</span></tt>, which means to return site positions in meters.</p>
<p class="last">To obtain site positions in nanometers, use <tt class="docutils literal"><span class="pre">SI(1e-9,'m')</span></tt>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>pos</cite> <span class="classifier-delimiter">:</span> <span class="classifier">numpy-array</span></dt>
<dd><p class="first last">Array containing a position (i.e. 3 floating point
numbers) for every site.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="get-subfield-sites">
<span id="id9"></span><h4>get_subfield_sites<a class="headerlink" href="manual.html#get-subfield-sites" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.get_subfield_sites</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">subfieldname)</span></tt></dd>
</dl>
<p>This function provides the node indices of the sites for data
obtained with <a class="reference internal" href="manual.html#get-subfield">get_subfield</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield, for example <tt class="docutils literal"><span class="pre">m_Py</span></tt> or <tt class="docutils literal"><span class="pre">H_demag</span></tt>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>data</cite> <span class="classifier-delimiter">:</span> <span class="classifier">numpy-array</span></dt>
<dd><p class="first last">Array containing a list of integers for every site. The
integers within each list are node indices of the
mesh. There will be only one integer per site in first
order basis function calculations (which is the usual case
in micromagnetics)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="get-subfield-average">
<span id="id10"></span><h4>get_subfield_average<a class="headerlink" href="manual.html#get-subfield-average" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.get_subfield_average</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">field_name,</span> <span class="pre">subfield_name=None)</span></tt></dd>
</dl>
<p>the average of the subfield <tt class="docutils literal"><span class="pre">subfield_name</span></tt> of
the field <tt class="docutils literal"><span class="pre">fieldname</span></tt> as an SI object (or a list of [list
of [list of [...]]] SI objects in the field is a vector, 2nd rank tensor etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>field_name</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">name of the field</p>
</dd>
<dt><cite>subfield_name</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">name of the subfield</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>See also <a class="reference internal" href="manual.html#get-subfield-average-siv">get_subfield_average_siv</a>.</p>
</div>
<div class="section" id="get-subfield-average-siv">
<span id="id11"></span><h4>get_subfield_average_siv<a class="headerlink" href="manual.html#get-subfield-average-siv" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.get_subfield_average_siv</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">field_name,</span> <span class="pre">subfield_name=None)</span></tt></dd>
</dl>
<p>the average of the subfield <tt class="docutils literal"><span class="pre">subfield_name</span></tt> of
the field <tt class="docutils literal"><span class="pre">fieldname</span></tt> as a single floating point number (or
a list if it is a vector, or a list of list for matrices etc).</p>
<p>The number is expressed in SI units (hence the suffix _siv
which stands for si value).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>field_name</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">name of the field</p>
</dd>
<dt><cite>subfield_name</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">name of the subfield</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ave_M</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_subfield_average_siv</span><span class="p">(</span><span class="s">&quot;M&quot;</span><span class="p">,</span><span class="s">&quot;Py&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>will obtain the average magnetisation of the subfield M_Py of field M, for example
<tt class="docutils literal"><span class="pre">ave_M</span> <span class="pre">=</span> <span class="pre">[100000.00,0.,0.]</span></tt></p>
</div>
<div class="section" id="probe-subfield">
<span id="id12"></span><h4>probe_subfield<a class="headerlink" href="manual.html#probe-subfield" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.probe_subfield</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">subfieldname,</span> <span class="pre">pos,</span> <span class="pre">unit=None)</span></tt></dd>
</dl>
<p>ven subfield name and position (SI object), return data (as SI object).</p>
<p>Note that <tt class="docutils literal"><span class="pre">get_subfield_siv</span></tt> has the same functionality but
takes a list of floats for the position (instead of an SI
object) and returns (a list of) float(s) which is just the
<a class="reference internal" href="manual.html#si-object"><em>SI-value</em></a> of that physical entity.</p>
<p>If the subfield is not defined at that part of space, <tt class="xref docutils literal"><span class="pre">None</span></tt>
is returned.</p>
<p>If the subfield does generally not exist, then a <tt class="docutils literal"><span class="pre">KeyError</span></tt> exception
is thrown.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield</p>
</dd>
<dt><cite>pos</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI object</span></dt>
<dd><p class="first last">The position for which the data should be returned</p>
</dd>
<dt><cite>unit</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI object</span></dt>
<dd><p class="first">If you request the value for a subfield of a field that is
part of nmag (i.e. fields M, m, H_demag, etc), then you do
not need to provide this object.</p>
<p>If you request data of any other (multi-physics) fields,
then this function needs to know the SI dimensions of that
field (for the correct conversion from simulation units to
SI units).</p>
<p class="last">If incorrect dimensions are provided, the returned data is
likely to be wrongly scaled.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>data</cite> <span class="classifier-delimiter">:</span> <span class="classifier">[list [of list[ of ...]]] SI objects</span></dt>
<dd><p class="first last">The returned object is an SI object for scalar subfields,
a list of SI objects for vector fields, a list of list of
SI objects for (rank 2) tensor fields, etc.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="probe-subfield-siv">
<span id="id13"></span><h4>probe_subfield_siv<a class="headerlink" href="manual.html#probe-subfield-siv" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.probe_subfield_siv</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">subfieldname,</span> <span class="pre">pos,</span> <span class="pre">unit=None)</span></tt></dd>
</dl>
<p>The same behaviour as <tt class="docutils literal"><span class="pre">get_subfield</span></tt> but the <tt class="docutils literal"><span class="pre">pos</span></tt> and return
data are <a class="reference internal" href="manual.html#si-object"><em>SI-value</em></a>s (not SI objects).</p>
<p>If the subfield is not defined at that part of space, <tt class="xref docutils literal"><span class="pre">None</span></tt>
is returned.</p>
<p>If the subfield does generally not exist, then a <tt class="docutils literal"><span class="pre">KeyError</span></tt>
exception is thrown.</p>
<p>The input (position) and returned data is expressed in SI
units but of type float.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield</p>
</dd>
<dt><cite>pos</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of floats</span></dt>
<dd><p class="first last">The position for which the data should be returned (in meters)</p>
</dd>
<dt><cite>unit</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI object</span></dt>
<dd><p class="first">If you request the value for a subfield of a field that is part of nmag (i.e.
fields M, m, H_demag, etc), then you do not need to provide this object.</p>
<p>If you request data of any other (multi-physics) fields,
then this function needs to know the SI dimensions of that
field (for the correct conversion from simulation units to
SI units).</p>
<p class="last">If incorrect dimensions are provided, the returned data is
likely to be wrongly scaled.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>data</cite> <span class="classifier-delimiter">:</span> <span class="classifier">[list [of list[ of ...]]] float</span></dt>
<dd><p class="first last">The returned object is a float for scalar subfields,
a list of floats for vector fields, a list of list of
floats for (rank 2) tensor fields, etc.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="probe-h-demag-siv">
<span id="id14"></span><h4>probe_H_demag_siv<a class="headerlink" href="manual.html#probe-h-demag-siv" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.probe_H_demag_siv</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">pos,</span> <span class="pre">pos_unit=SI(1,['m',1.0]),</span> <span class="pre">epsilon=1e-07)</span></tt></dd>
</dl>
<p>ME: this function returns a wrong value for points outside
the mesh. For a sphere uniformly magnetised along +x, the x component
of the demag field outside should be positive, while it is negative.</p>
<p>Compute the demag field at given position. Works inside
and outside of magnetic materials. Note that most fields can only
be probed where they are defined. This function computes the demag
field at the given position on the fly, based on the boundary element
method.</p>
<p>Note that for large distances away from the magnetic material, we expect
this not to be very accurate. Furthermore, there is an awkward technical
problem whenever the probe point lies in-plane with any of the surface
triangles. These awkward limitations are strongly linked to the method
used to compute the scalar potential internally and are intrinsically
difficult to avoid. They will go away in the future when potential
computations will be performed with Hlib.</p>
<p>Also, this function should (at present) not be used to probe the
demag field for periodic structures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>pos</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of floats</span></dt>
<dd><p class="first last">The SI numbers described the position in meters. A command like
<tt class="docutils literal"><span class="pre">probe_H_demag_siv([0,0,1e-9])</span></tt> would thus probe the demag field one
nanometer away (in z-direction) from the origin.</p>
</dd>
<dt><cite>pos_unit</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI object</span></dt>
<dd><p class="first last">Optional argument that defaults to SI(&#8220;m&#8221;). The full SI position is
computed as pos*pos_unit. The above example could therefore be written as
<tt class="docutils literal"><span class="pre">probe_H_demag_siv([0,0,1],pos_unit=SI(1e-9,&quot;m&quot;))</span></tt>.</p>
</dd>
<dt><cite>epsilon</cite> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">This parameter is used internally to compute the demag
field via central differences from the magnetic
potential if the observer point is in the exterior (&#8220;vacuum&#8221;)
region. It is the distance between the two points at
which each of the field components is being computed
(because the field is the negative gradient of the
potential). The default value of 1e-7 should be sensible
if normal simulation units are used (i.e. the mesh was
provided with coordinates in the range 1-1000).
Typically, this parameter should be ignored. Note that this number is
measured in simulation units.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of floats containing the demag field in SI units (i.e. A/m) at the
specified position.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="hysteresis">
<span id="id15"></span><h4>hysteresis<a class="headerlink" href="manual.html#hysteresis" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.hysteresis</span></tt></dd>
<dt>Arguments:</dt>
<dd><div class="first last highlight-python"><pre>(
self,
H_ext_list,
save=[('averages', 'fields', at('stage_end'))],
do=[],
convergence_check=every('step', 5)
)</pre>
</div>
</dd>
</dl>
<p>This method executes a simulation where the applied field
is set in sequence to the values specified in <tt class="docutils literal"><span class="pre">H_ext_list</span></tt>.
The time integration proceeds with the same applied field
until convergence is reached. At this point the field is changed
to the next one in <tt class="docutils literal"><span class="pre">H_ext_list</span></tt> and the method <tt class="docutils literal"><span class="pre">reinitialise()</span></tt>
is called to proceed with the simulation.
The user can specify when to save data using the optional
argument <tt class="docutils literal"><span class="pre">save</span></tt>.</p>
<p>This allows to carry out hysteresis loop computations
and write the results to disk.</p>
<p>Technically we say that this function performs a multi-stage
simulation. In our terminology, a stage is a part of the simulation
where the field does not change. Therefore, every value
for the applied field specified in <tt class="docutils literal"><span class="pre">H_ext_list</span></tt> corresponds
to a different stage. Stages are numbered starting from 1,
which corresponds to <tt class="docutils literal"><span class="pre">H_ext_list[0]</span></tt>. In general during
stage number <tt class="docutils literal"><span class="pre">i</span></tt> the applied field is <tt class="docutils literal"><span class="pre">H_ext_list[i-1]</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>H_ext_list</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of values for the applied field</span></dt>
<dd><p class="first last">It is something like <tt class="docutils literal"><span class="pre">[H1,</span> <span class="pre">H2,</span> <span class="pre">H3,</span> <span class="pre">...]</span></tt>, where
<tt class="docutils literal"><span class="pre">Hi</span></tt> is the triple of components of the applied field,
i.e. SI objects having units of &#8220;A/m&#8221;;</p>
</dd>
<dt><cite>save</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of pairs <tt class="docutils literal"><span class="pre">(thing_to_save,</span> <span class="pre">when)</span></tt></span></dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">thing_to_save</span></tt> is either a string or a function provided
by the user and <tt class="docutils literal"><span class="pre">when</span></tt> is an instance of the class <tt class="docutils literal"><span class="pre">When</span></tt>,
i.e. an object which contains the specification of when
&#8220;the thing&#8221; has to be saved.</p>
<p>Possible string values for <tt class="docutils literal"><span class="pre">thing_to_save</span></tt> are:</p>
<blockquote class="last">
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">&quot;averages&quot;</span></tt>: to save the averages of all the fields
together with other information (such as the stage number,
the time reached, etc.). This is done calling the method
<tt class="docutils literal"><span class="pre">save_data()</span></tt>. Refer to its documentation
for further details;</li>
<li><tt class="docutils literal"><span class="pre">&quot;fields&quot;</span></tt>: to save all the fields. The method
<tt class="docutils literal"><span class="pre">save_data(fields='all')</span></tt> is called for this purpose;</li>
<li><tt class="docutils literal"><span class="pre">&quot;restart&quot;</span></tt>: to save the current magnetisation configuration
and all the information needed to restart the simulation.</li>
</ul>
</div></blockquote>
</dd>
<dt><cite>do</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of pairs <tt class="docutils literal"><span class="pre">(thing_to_do,</span> <span class="pre">when)</span></tt></span></dt>
<dd><p class="first">is very similar to the <tt class="docutils literal"><span class="pre">save</span></tt> argument, but is usually used
for other purposes.
<tt class="docutils literal"><span class="pre">thing_to_do</span></tt> is either a string or a function provided
by the user and <tt class="docutils literal"><span class="pre">when</span></tt> is an instance of the class <tt class="docutils literal"><span class="pre">When</span></tt>.</p>
<p>Possible string values for <tt class="docutils literal"><span class="pre">thing_to_do</span></tt> are:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">&quot;next_stage&quot;</span></tt>: induces the hysteresis method to advance
to the next stage;</li>
<li><tt class="docutils literal"><span class="pre">&quot;exit&quot;</span></tt>: induces the hysteresis method to exit,
even if the hysteresis computation has not still reached
its end.</li>
</ul>
</div></blockquote>
<p>The user can provide his own function to save data.
For example, the following three lines:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">my_fun</span><span class="p">(</span><span class="n">sim</span><span class="p">):</span>
  <span class="n">sim</span><span class="o">.</span><span class="n">save_data</span><span class="p">()</span>
<span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="n">my_fun</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">))])</span>
</pre></div>
</div>
<p>are equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">))])</span>
</pre></div>
</div>
<p>To specify when something has to be saved the module <tt class="docutils literal"><span class="pre">when</span></tt>
is used. The functions <tt class="docutils literal"><span class="pre">at</span></tt> and <tt class="docutils literal"><span class="pre">every</span></tt>, provided by
this module, can refer to the following time variables:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">step</span></tt>: the step number from the beginning of the simulation;</li>
<li><tt class="docutils literal"><span class="pre">stage_step</span></tt>: the step number from the beginning of
the current stage;</li>
<li><tt class="docutils literal"><span class="pre">time</span></tt>: the simulation time passed from the beginning
of the simulation (measured in <a class="reference internal" href="manual.html#si">SI</a> objects);</li>
<li><tt class="docutils literal"><span class="pre">stage_time</span></tt>: the simulation time passed from the beginning
of the current stage;</li>
<li><tt class="docutils literal"><span class="pre">stage</span></tt>: the number of the current stage;</li>
<li><tt class="docutils literal"><span class="pre">convergence</span></tt>: a boolean value which is <tt class="xref docutils literal"><span class="pre">True</span></tt>
if the convergence criterion is satisfied.
Use in this way <tt class="docutils literal"><span class="pre">at('convergence')</span></tt></li>
</ul>
</div></blockquote>
<p>Remember that you can combine time specifications using
the operator | (or) and &amp; (and):</p>
<div class="highlight-python"><pre>every('stage', 2) &amp; at('convergence') --&gt; only at convergence
                                          of odd stages
every('step', 10) | at('convergence') --&gt; at convergence
                                          and every 10 steps.</pre>
</div>
<p>Some usage examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Save fields (which implicitly will save the averages as well)</span>
<span class="c"># when the magnetisation stops changing for each applied field</span>
<span class="c"># (i.e. save at convergence):</span>
<span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>

<span class="c"># Averages will be saved every 10 steps, fields (and</span>
<span class="c"># implicitely averages) will be saved at convergence.</span>
<span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)),</span>
                          <span class="p">(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))])</span>

<span class="c"># Each stage will not last more than 10 ps, even</span>
<span class="c"># if the magnetisation is not relaxed yet.</span>
<span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">do</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;next_stage&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;stage_time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-11</span><span class="p">,</span> <span class="s">&quot;s&quot;</span><span class="p">)))])</span>

<span class="c"># Exit hysteresis loop simulation if the total number of</span>
<span class="c"># steps exceeds 1e6, save fields every 100 steps and at</span>
<span class="c"># convergence before that:</span>
<span class="n">sim</span><span class="o">.</span><span class="n">hysteresis</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">|</span>
                          <span class="n">at</span><span class="p">(</span><span class="s">&#39;convergence&#39;</span><span class="p">))],</span>
                     <span class="n">do</span> <span class="o">=</span><span class="p">[(</span><span class="s">&#39;exit&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">))])</span>

<span class="c"># Save averages every 0.1 ns (useful for fourier transform)</span>
<span class="c"># leave after 20 ns (using the related relax_ command)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">)))],</span>
          <span class="n">do</span>  <span class="o">=</span><span class="p">[(</span><span class="s">&#39;exit&#39;</span><span class="p">,</span> <span class="n">at</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">20e-9</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">)))])</span>

<span class="c"># Save averages every nanosecond, and fields every 100 ns.</span>
<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span><span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">))),</span>
                <span class="p">(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span>  <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">100e-9</span><span class="p">,</span><span class="s">&#39;s&#39;</span><span class="p">)))])</span>

<span class="c"># Save averages every nanosecond, and fields every 100 ns,</span>
<span class="c"># save restart file every 1000 steps</span>
<span class="n">sim</span><span class="o">.</span><span class="n">relax</span><span class="p">(</span><span class="n">save</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;averages&#39;</span><span class="p">,</span><span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-9</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">))),</span>
                <span class="p">(</span><span class="s">&#39;fields&#39;</span><span class="p">,</span>  <span class="n">every</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">SI</span><span class="p">(</span><span class="mf">100e-9</span><span class="p">,</span> <span class="s">&#39;s&#39;</span><span class="p">))),</span>
                <span class="p">(</span><span class="s">&#39;restart&#39;</span><span class="p">,</span> <span class="n">every</span><span class="p">(</span><span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))])</span>
</pre></div>
</div>
<p class="last">If <tt class="docutils literal"><span class="pre">save</span></tt> is not given, averages and fields will be saved whenever
the stage ends (this is the default behaviour).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="load-mesh">
<span id="id16"></span><h4>load_mesh<a class="headerlink" href="manual.html#load-mesh" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.load_mesh</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">filename,</span> <span class="pre">region_names_and_mag_mats,</span> <span class="pre">unit_length,</span> <span class="pre">do_reorder=False,</span> <span class="pre">manual_distribution=None)</span></tt></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>filename</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The file that contains the mesh in nmesh format (ascii or hdf5)</p>
</dd>
<dt><cite>region_names_and_mag_mats</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of 2-tuples</span></dt>
<dd><p class="first">A list of 2-tuples containing the region names and the
magnetic materials associated to each region. For example,
having two spheres (called <tt class="docutils literal"><span class="pre">region_A</span></tt> and <tt class="docutils literal"><span class="pre">region</span> <span class="pre">B</span></tt>)
with materials A and B in the mesh, the argument would be
[(&#8220;region_A&#8221;, A),(&#8220;region_B&#8221;,B)] where
A and B must have been defined previously as <tt class="docutils literal"><span class="pre">nmag.MagMaterial</span></tt>.</p>
<p class="last">Having two Materials X and Y both defined in region A (as in a magnetic
two-component alloy), we would use [(&#8220;region_A&#8221;,[X,Y])].</p>
</dd>
<dt><cite>unit_length</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI object</span></dt>
<dd><p class="first last">The SI object defines what a length of 1.0 in the mesh file
corresponds to in reality. If the length 1.0 in the mesh corresponds to
a nanometer, then this SI object would be given as SI(1e-9,&#8221;m&#8221;)</p>
</dd>
<dt><cite>do_reorder</cite> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If set to True, metis will be called to reorder the mesh
(aiming to bring together node ids that correspond to node
locations that are spatially close to each other). If this
doesn&#8217;t make sense to you, you should probably leave the
default (which is <tt class="xref docutils literal"><span class="pre">False</span></tt>).</p>
<p>Generally, we recommend to order a mesh using <tt class="docutils literal"><span class="pre">nmeshpp</span>
<span class="pre">--reordernodes</span> <span class="pre">mesh.nmesh</span> <span class="pre">orderedmesh.nmesh</span></tt>, and <em>not to
use</em> this reodering option here, if you think you need to
order it.</p>
<p>If you know nmag really well (you are probably a member of
the core team) then read on.</p>
<p>The use of <tt class="docutils literal"><span class="pre">do_reorder</span></tt> <em>can</em> make sense if either your
mesh is not ordered already, or you provide a
<tt class="docutils literal"><span class="pre">manual_distribution</span></tt> of nodes.</p>
<p class="last">The use of <tt class="docutils literal"><span class="pre">do_reorder</span></tt> makes no sense, if you run on more
than one CPU and leave the distribution of the nodes to
nmag (i.e. you use the default
<tt class="docutils literal"><span class="pre">manual_distribution==None</span></tt>).</p>
</dd>
<dt><cite>manual_distribution</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of integers</span></dt>
<dd><p class="first last">This list (if provided) describes how many nodes are to be
put onto which CPU under MPI-parallelized execution.  If
this is <tt class="xref docutils literal"><span class="pre">None</span></tt> (i.e. the default), then the distribution
is done automatically (through metis). This parameter
should generally not be used (unless you really know what
you are doing).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><cite>mesh</cite> : mesh object</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="load-m-from-h5file">
<span id="id17"></span><h4>load_m_from_h5file<a class="headerlink" href="manual.html#load-m-from-h5file" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.load_m_from_h5file</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">filename,</span> <span class="pre">**kwargs)</span></tt></dd>
</dl>
<p>magnetisation stored in <tt class="docutils literal"><span class="pre">filename</span></tt> to set the
magnetisation of the simulation. (If more than one magnetisation
configurations have been saved in the file, it will load the first
one.)</p>
<p>This can be used to retrieve the magnetisation saved in a restart file,
and to set the current magnetisation of the simulation object to this
magnetisation.</p>
<p>This restart file could have been written explicitely (using the
<a class="reference internal" href="manual.html#save-restart-file">save_restart_file</a> method), or implicitly by providing a &#8216;restart&#8217;
action to the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a>/<a class="reference internal" href="manual.html#relax">relax</a> commands.</p>
<p>To simply continue a hysteresis/relax simulation using the
<tt class="docutils literal"><span class="pre">--restart</span></tt> option, there is no need to use this function. It should
only be used if lower-level manipulation is required (see for example
<a class="reference internal" href="manual.html#current-driven-motion-of-a-vortex-in-a-thin-film"><em>Current-driven motion of a vortex in a thin film</em></a>).</p>
</div>
<div class="section" id="save-restart-file">
<span id="id18"></span><h4>save_restart_file<a class="headerlink" href="manual.html#save-restart-file" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.save_restart_file</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">filename=None,</span> <span class="pre">fieldnames=['m'],</span> <span class="pre">all=False)</span></tt></dd>
</dl>
<p>rent magnetic configuration into file that can be used for
restarting.</p>
<p>This function saves the current magnetisation, the time and
all what is needed to restart the simulation exactly from
the point it was invoked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><cite>filename</cite> : string</p>
<blockquote>
<div><p>The file into which the restart file is written. Defaults
RUNID_restart.h5.</p>
</div></blockquote>
<dl class="last docutils">
<dt><cite>fieldnames</cite>: list</dt>
<dd><p class="first last">The fieldnames to be saved. Defaults to [&#8216;m&#8217;]</p>
</dd>
<dt><cite>all</cite>:bool</dt>
<dd><p class="first last">If true, then all fields will be saved.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>This function is used by the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> and <a class="reference internal" href="manual.html#relax">relax</a> commands
to save a magnetic configuration from which a run can be
continued (using &#8211;restart).</p>
<p>Example:</p>
<blockquote>
<div><p>A common usecase for this function maybe to write the
magnetic configuration that comes from a relaxation process
to a file. And to load that configuration as the initial
configuration for a subsequent (series of) simulation(s).</p>
<p>In this case, one may want to provide the filename explicitely.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">save_restart_file</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&quot;relaxed_configuration.h5&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>One can then use the <a class="reference internal" href="manual.html#load-m-from-h5file">load_m_from_h5file</a>, to read this file
<tt class="docutils literal"><span class="pre">relaxed_configuration.h5</span></tt> and to use it to set the
magnetisation up in the subsequent simulation.</p>
</div></blockquote>
</div>
<div class="section" id="relax">
<span id="id19"></span><h4>relax<a class="headerlink" href="manual.html#relax" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.relax</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">H_applied=None,</span> <span class="pre">save=[('averages',</span> <span class="pre">'fields',</span> <span class="pre">at(stage_end,</span> <span class="pre">True))],</span> <span class="pre">do=[],</span> <span class="pre">convergence_check=every(5,</span> <span class="pre">'step'))</span></tt></dd>
</dl>
<p>This method carries out the time integration of the LLG until
the system reaches a (metastable) equilibrium.
Internally, this uses the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> loop command.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>H_applied</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of SI objects</span></dt>
<dd><p class="first">For a 3-d simulation, the SI-objects Hx, Hy and Hz would be
specified as <tt class="docutils literal"><span class="pre">[Hx,Hy,Hz]</span></tt>.</p>
<p class="last">Default value is <tt class="xref docutils literal"><span class="pre">None</span></tt>, resulting in the currently applied external
field <tt class="docutils literal"><span class="pre">H_ext</span></tt> being used.</p>
</dd>
<dt><cite>save</cite> <span class="classifier-delimiter">:</span> <span class="classifier">Schedule object</span></dt>
<dd><p class="first last">Allows to define what data to save at what events.
See documentation on the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> method and
on the <tt class="docutils literal"><span class="pre">Schedule</span></tt> object.</p>
</dd>
</dl>
<p class="last"><cite>convergence_check</cite> : every object The default value
(<tt class="docutils literal"><span class="pre">every('step',</span> <span class="pre">5)</span></tt> specifies that we ask the time
integrator to carry out 5 steps before we check for
convergence. If in doubt, ignore this feature.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="save-data">
<span id="id20"></span><h4>save_data<a class="headerlink" href="manual.html#save-data" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.save_data</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">fields=None,</span> <span class="pre">avoid_same_step=False)</span></tt></dd>
</dl>
<p>Save the <em>averages</em> of all defined (subfields) into a ascii
data file. The filename is composed of the simulation name
and the extension <tt class="docutils literal"><span class="pre">_dat.ndt</span></tt>. The
extension <tt class="docutils literal"><span class="pre">ndt</span></tt> stands for Nmag Data Table (analog to OOMMFs
<tt class="docutils literal"><span class="pre">.odt</span></tt> extension for this kind of data file.</p>
<p>If <tt class="docutils literal"><span class="pre">fields</span></tt> is provided, then it will also save the spatially resolved fields
to a file with extensions <tt class="docutils literal"><span class="pre">_dat.h5</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><cite>fields</cite> : None, &#8216;all&#8217; or list of fieldnames</p>
<blockquote>
<div><p>If None, then only spatially averaged data is saved into <tt class="docutils literal"><span class="pre">*ndt</span></tt> and <tt class="docutils literal"><span class="pre">*h5</span></tt> files.</p>
<p>If <tt class="docutils literal"><span class="pre">all</span></tt> (i.e. the string containing &#8216;all&#8217;), then all fields are saved.</p>
<p>If a list of fieldnames is given, then only the selected
fieldnames will be saved (i.e. [&#8216;m&#8217;,&#8217;H_demag&#8217;]).</p>
</div></blockquote>
<p><cite>avoid_same_step</cite> : bool</p>
<blockquote class="last">
<div><p>If <tt class="xref docutils literal"><span class="pre">True</span></tt>, then the data will only be saved if the
current <tt class="docutils literal"><span class="pre">clock['step']</span></tt> counter is different from the
step counter of the last saved configuration. If
<tt class="xref docutils literal"><span class="pre">False</span></tt>, then the data will be saved in any
case. Default is <tt class="docutils literal"><span class="pre">`False`</span></tt>. This is internally used by
the hysteresis command (which uses <tt class="docutils literal"><span class="pre">avoid_same_step</span> <span class="pre">==</span>
<span class="pre">True</span></tt>) to avoid saving the same data twice.</p>
<p>The only situation where the step counter may not have
changed from the last saved configuration is if the user
is modifying the magnetisation or external field manually
(otherwise the call of the time integrator to advance or
relax the system will automatically increase the step
counter).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="set-m">
<span id="id21"></span><h4>set_m<a class="headerlink" href="manual.html#set-m" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.set_m</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">values,</span> <span class="pre">subfieldname=None)</span></tt></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>values</cite> <span class="classifier-delimiter">:</span> <span class="classifier">vector (=list), function or numpy array.</span></dt>
<dd><p class="first last">The values to be set. See more detailed explanation below.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>This method sets the (normalised) magnetisation  (i.e. the <tt class="docutils literal"><span class="pre">m</span></tt> field)
to a particular value (or pattern).</p>
<p>It can be used in three different ways:</p>
<ol class="arabic">
<li><p class="first">Providing a constant vector</p>
<p>If given a vector, this function sets the <tt class="docutils literal"><span class="pre">m</span></tt> field to uniformly point in
the given direction, everywhere.</p>
<p>For example, to have the magnetisation point
in +x-direction, we could call the function like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>To point in a 45 degree direction between the x- and y-axis,
we could use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>(The magnetisation will automatically be normalised.)</p>
</li>
<li><p class="first">Providing a function</p>
<p>If the magnetisation is meant to vary spatially, then a
function can be given to the <tt class="docutils literal"><span class="pre">set_m</span></tt> method as in this
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">my_magnetisation</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)):</span>
    <span class="c"># get access to pi, cos and sin</span>
    <span class="kn">import</span> <span class="nn">math</span>

    <span class="c"># change angle of Mx and My by 10 degree when x varies by 1nm</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="mf">1e9</span><span class="p">)</span><span class="o">*</span><span class="mf">10.</span><span class="o">/</span><span class="mi">360</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">Mx</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">My</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">Mz</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c">#return magnetisation vector for position (x,y,z)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Mx</span><span class="p">,</span><span class="n">My</span><span class="p">,</span><span class="n">Mz</span><span class="p">)</span>

<span class="n">sim</span><span class="o">.</span><span class="n">set_m</span><span class="p">(</span><span class="n">my_magnetisation</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <tt class="docutils literal"><span class="pre">my_magnetisation</span></tt> returns the magnetisation vector
corresponding to the given 3d position in space.</p>
<p>This position <tt class="docutils literal"><span class="pre">(x,y,z)</span></tt> as given to the function is expressed in meters.</p>
</li>
<li><p class="first">Providing a numpy array.</p>
<p>If a numpy array is provided to set the values of the
subfield, then the shape of this array has to match the
shape of the subfield data. For example, if the subfield is
the magnetisation of material X, and this material is
defined on n mesh sites, then the array needs to have n
entries. Each of those has to be a 3-component array,
as the magnetisation vector has three components.</p>
<p>Note: the Simulation.get_subfield() function can be used to
obtain exactly such a numpy array for the relevant
subfield.</p>
<p>To read such a numpy array from a file, you can use the
<a class="reference internal" href="manual.html#get-subfield-from-h5file">get_subfield_from_h5file</a> function. However, you have to be
sure that the node order in the mesh (that is stored in the
_dat.h5 file) is the same as the mesh you are currently
using in your simulation. This should certainly be the case
if (i) both runs [i.e. the saved and the current] are based
on the same mesh, and (ii) you only us one CPU [as using
more than one results in repartitioning and reordering of
the mesh]. We aim to not allow setting &#8216;wrong&#8217; data here in
the future, but currently such checking is not
implemented. (fangohr 31/05/2008)</p>
</li>
</ol>
</div>
<div class="section" id="set-h-ext">
<span id="id22"></span><h4>set_H_ext<a class="headerlink" href="manual.html#set-h-ext" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.set_H_ext</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">values,</span> <span class="pre">unit=None)</span></tt></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>values</cite> <span class="classifier-delimiter">:</span> <span class="classifier">vector (=list), function or numpy array.</span></dt>
<dd><p class="first last">See <a class="reference internal" href="manual.html#set-m">set_m</a> for an explanation of possible <tt class="docutils literal"><span class="pre">values</span></tt>.</p>
</dd>
</dl>
<p><cite>unit</cite> : SI Object</p>
<blockquote class="last">
<div><p>An SI Object that is used as a multiplier for the
<tt class="docutils literal"><span class="pre">values</span></tt>. This unit has to be physically compatible with
Ampere per meter.</p>
<p>To set an applied field that is homogenous and points in
+x-direction, one can use:</p>
<div class="highlight-python"><pre>sim.set_H_ext([1e6, 0, 0], SI("A/m"))

which is equivalent to::

sim.set_H_ext([1, 0, 0], SI(1e6, "A/m"))</pre>
</div>
<p>However, we could also define the field in Oersted:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">nmag.si</span> <span class="kn">import</span> <span class="n">Oe</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_H_ext</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span><span class="n">Oe</span><span class="p">)</span>
</pre></div>
</div>
<p>or in Tesla/mu0:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">nmag.si</span> <span class="kn">import</span> <span class="n">Tesla</span><span class="p">,</span> <span class="n">mu0</span>
<span class="n">sim</span><span class="o">.</span><span class="n">set_H_ext</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">Tesla</span><span class="o">/</span><span class="n">mu0</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="set-pinning">
<span id="id23"></span><h4>set_pinning<a class="headerlink" href="manual.html#set-pinning" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.set_pinning</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">values)</span></tt></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><cite>values</cite> : vector (=list), function or numpy array.</td>
</tr>
</tbody>
</table>
<p>This method sets the scalar pinning field which defines a
local scale factor for <tt class="docutils literal"><span class="pre">dm/dt</span></tt>.</p>
<p>Default value is <tt class="docutils literal"><span class="pre">1.0</span></tt>, use <tt class="docutils literal"><span class="pre">0.0</span></tt> to force <tt class="docutils literal"><span class="pre">dm/dt</span></tt> to
zero, that is, to &#8220;pin&#8221; (fix) magnetisation at a certain
position.</p>
<p>Semantics of the <cite>values</cite> parameter match <a class="reference internal" href="manual.html#set-m">set_m</a>.</p>
</div>
<div class="section" id="set-params">
<span id="id24"></span><h4>set_params<a class="headerlink" href="manual.html#set-params" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.set_params</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">stopping_dm_dt=None,</span> <span class="pre">ts_rel_tol=None,</span> <span class="pre">ts_abs_tol=None,</span> <span class="pre">exact_tstop=None)</span></tt></dd>
</dl>
<p>Set the parameters which control the accuracy and performance
of the simulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>ts_rel_tol</cite> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">the relative error tolerance (default is 1e-6) for the timestepper</p>
</dd>
<dt><cite>ts_abs_tol</cite> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">the absolute error tolerance (default is 1e-6) for the timestepper</p>
</dd>
<dt><cite>stopping_dm_dt</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="manual.html#si">SI</a> object</span></dt>
<dd><p class="first">the value used in the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> and <a class="reference internal" href="manual.html#relax">relax</a> functions to decide
whether convergence has been reached. If the largest value for dm/dt drops
below <tt class="docutils literal"><span class="pre">stopping_dm_dt</span></tt>, then convergence has been reached.</p>
<p class="last">The default value for <tt class="docutils literal"><span class="pre">stopping_dm_dt</span></tt> this is that the
magnetisation changes less than one degree per nanosecond,
i.e. <tt class="docutils literal"><span class="pre">stopping_dm_dt</span> <span class="pre">=</span> <span class="pre">SI(17453292.519943293,['s',-1])</span></tt>.</p>
</dd>
<dt><cite>exact_tstop</cite> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">the value of exact_tstop which is used by the advance_time method
when the optional argument is not given. This is also the value
used by the relax and hysteresis methods. See the documentation
of advance_time for further details.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Note that this command has to be issued <em>after</em> having created
an m-field with the <a class="reference internal" href="manual.html#set-m">set_m</a> command.</p>
</div>
</div>
<div class="section" id="get-subfield-from-h5file">
<span id="id25"></span><h3>get_subfield_from_h5file<a class="headerlink" href="manual.html#get-subfield-from-h5file" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">get_subfield_from_h5file</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(*args,</span> <span class="pre">**nargs)</span></tt></dd>
</dl>
<p>Retrieve data from h5 file. Data are returned as an array of floating
point number (in SI units).</p>
<p>This function should be used with care, as the order of the entries in the
returned array depends on the partitioning of the mesh used when saving the
data.</p>
<p>Analog to <a class="reference internal" href="manual.html#get-subfield">get_subfield</a> (which returns subfield data for a subfield of a
simulation object), but will retrieve data from saved <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> file.</p>
<p>Note that the entries of the returned array are ordered accordingly
to the mesh used in this simulation object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>filename</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The full name of the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> data file.</p>
</dd>
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield to be retrieved.</p>
</dd>
<dt><cite>id</cite> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The <tt class="docutils literal"><span class="pre">id</span></tt> of the configuration to return (defaults to 0)</p>
</dd>
</dl>
<p><cite>row</cite> : integer</p>
<blockquote class="last">
<div><p>If the <tt class="docutils literal"><span class="pre">id</span></tt> is not specified, the <tt class="docutils literal"><span class="pre">row</span></tt> can be used to address the data
row with index <tt class="docutils literal"><span class="pre">row</span></tt>.</p>
<p>For example, the magnetisation may have been saved at some point during the
simulation into a file (for example using the <a class="reference internal" href="manual.html#restart-example"><em>Restart example</em></a> functionality, or using the <a class="reference internal" href="manual.html#save-data">save_data</a> method for the
first time to save the m-field (i.e. <tt class="docutils literal"><span class="pre">sim.save_data(fields=['m']</span></tt>) into a
new file).</p>
<p>We can use <tt class="docutils literal"><span class="pre">row=0</span></tt> to read the first magnetisation configuration that has
been written into this file (and <tt class="docutils literal"><span class="pre">row=1</span></tt> to access the second etc).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">numpy array</td>
</tr>
</tbody>
</table>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="get-subfield-positions-from-h5file">
<span id="id26"></span><h3>get_subfield_positions_from_h5file<a class="headerlink" href="manual.html#get-subfield-positions-from-h5file" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">get_subfield_positions_from_h5file</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(filename,</span> <span class="pre">subfieldname)</span></tt></dd>
</dl>
<p>Analogous to <a class="reference internal" href="manual.html#get-subfield-positions">get_subfield_positions</a> (which returns the positions of
nodes for a subfield of a simulation object), but will retrieve
data from saved <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>filename</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The full name of the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> data file.</p>
</dd>
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield to be retrieved.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>numpy array</dt>
<dd><p class="first last">The positions are returned as <a class="reference internal" href="manual.html#si-object"><em>si-value</em></a>s.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="get-subfield-sites-from-h5file">
<span id="id27"></span><h3>get_subfield_sites_from_h5file<a class="headerlink" href="manual.html#get-subfield-sites-from-h5file" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">get_subfield_sites_from_h5file</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(filename,</span> <span class="pre">subfieldname)</span></tt></dd>
</dl>
<p>Analogous to <a class="reference internal" href="manual.html#get-subfield-sites">get_subfield_sites</a> (which returns the site ids of
nodes for a subfield of a simulation object), but will retrieve
data from saved <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>filename</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The full name of the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> data file.</p>
</dd>
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield to be retrieved.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>numpy array</dt>
<dd><p class="first last">The ids are returned as <a class="reference internal" href="manual.html#si-object"><em>si-value</em></a>s.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="hmatrixsetup">
<span id="id28"></span><h3>HMatrixSetup<a class="headerlink" href="manual.html#hmatrixsetup" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">HMatrixSetup</span></tt></dd>
<dt>Class constructor information:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">algorithm='HCA2',</span> <span class="pre">**kwargs)</span></tt></dd>
</dl>
<p>ass collecting the parameters needed in order to set up an HMatrix
with HLib within Nmag.</p>
<p>The optional argument <tt class="docutils literal"><span class="pre">algorithm</span></tt> is by default set to &#8220;HCA2&#8221;.
At present no other values are supported.
The user can then specify a number of parameters in order to fine-tune
the setup of the HMatrix. <tt class="docutils literal"><span class="pre">**kwargs</span></tt> stands for one or more of the
following parameters (see <a class="reference external" href="http://www.hlib.org">Hlib</a> documentation
for detailed descriptions of the parameers):</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Parameters of HCA II:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><cite>eps_aca</cite> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">A heuristic parameter which influences the accuracy of HCA II.
By default this parameter is set to 1e-7</p>
</dd>
<dt><cite>poly_order</cite> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">A second parameter which influences the accuracy of the HCA II.
Its default setting is 4.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Parameter for recompression algorithm:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><cite>eps</cite> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">This parameter determines the accuracy of the recompression
algorithm, which optimises a given hierarchical matrix.
The default value is 0.001.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Parameters influencing the tree structure:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><cite>cluster_strategy</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">algorithm to be used for creating the cluster tree. Available choices
are &#8216;regular&#8217; (cluster constructed splitting the bounding box of the
surface in two smaller bounding boxes with half the size along x,
then y, z, x, and so on), &#8216;geometric&#8217; (similar to &#8216;regular&#8217; but the
splitting is done along longer dimension of the bounding box)
&#8216;regular_box&#8217; (behaves similarly to &#8216;regular&#8217;), &#8216;cardinality&#8217; (the
bounding box is split into two bounding boxes containing the same
number of points, cyclically along each dimension), &#8216;pca&#8217; (clustering
based on principal directions), &#8216;default&#8217; (uses the default).
The default clustering strategy is &#8216;regular&#8217;.</p>
</dd>
<dt><cite>eta</cite> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">eta is a parameter which influences the so called admissibility
criterion. As explained above, a subblock of the boundary element
matrix basically  describes the dipole potential at a cluster of
surface nodes A generated by a different cluster B. The subblock
can only be approximated when both cluster are spatially well
separated. To have an objective measure of what &#8216;well separated&#8217;
means, an admissibility criterion has been introduced. The smaller
the parameter eta is chosen, the more restrictive is the
admissibility criterion. The default value is 2.0.</p>
</dd>
<dt><cite>nmin</cite> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">In order to be able to adjust the coarseness of the tree structure
(a too fine tree structure would result in a higher amount of memory
required for the storage of the tree itself), a parameter nmin has
been introduced. It is the minimal number of lines or rows a
submatrix within a leave can have, and is by default set to 30.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Parameter for the numerical quadrature:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><cite>quadorder</cite> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The order of the Gaussian quadrature used to compute matrix entries
for the low-rank matrix blocks. For the matrix blocks, which are not
approximated, an analytical expression instead of numerical
integration is used. By default, quadorder is set to 3.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="si">
<span id="id29"></span><h3>SI<a class="headerlink" href="manual.html#si" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">SI</span></tt></dd>
<dt>Class constructor information:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">value,</span> <span class="pre">dimensions=[])</span></tt></dd>
</dl>
<p>Physical quantity in the SI units system.</p>
<p>This class allows to associate SI-dimensions (such as meter,
kilogram, Ampere, seconds, candela and mol) with a floating point
number.</p>
<p>The resulting object supports addition, subtraction, (which fails if
the dimensions of the objects in a sum or difference disagree),
multiplication and division.</p>
<p>There are different ways to create objects:</p>
<ol class="arabic">
<li><p class="first">The most fundamental approach is to
provide a value and a list of pairs where each pair is
a character identifying the SI base unit and an integer that
provides its power.</p>
<p>Examples:</p>
<ol class="upperalpha simple">
<li><tt class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">SI(10,['m',1,'s',-1])</span></tt> is the code to create an SI object v
that represents 10 m/s.</li>
<li><tt class="docutils literal"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">SI(0.6,['kg',1,'s',-2,'A',-1])</span></tt> is the code to create an SI
object T that represents  0.6 kg/(s^2 A) (i.e. 0.6 Tesla)</li>
</ol>
</li>
<li><p class="first">A more convenient way is to first define all the base units
like this (these are already defined in the <tt class="docutils literal"><span class="pre">si</span></tt> submodule, so
instead of the following lines below, we could also just write:
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">si</span> <span class="pre">import</span> <span class="pre">meter,second,Ampere</span></tt>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">meter</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">)</span> <span class="c"># alternative spelling: metre</span>
<span class="n">second</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;s&#39;</span><span class="p">)</span>
<span class="n">Ampere</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>and then to use these SI objects to create more complex
expressions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">v</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">meter</span><span class="o">/</span><span class="n">second</span>
<span class="n">B</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">kilogram</span><span class="o">/</span><span class="n">second</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">Ampere</span>
</pre></div>
</div>
<p>Of course, short hand notations can be defined such as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T</span> <span class="o">=</span> <span class="n">kilogram</span><span class="o">/</span><span class="n">second</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">Ampere</span>
<span class="n">B</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">Tesla</span>
</pre></div>
</div>
</li>
<li><p class="first">Finally, there is another convenient way:</p>
<p>Instead of a SI dimension vector as in (1), it is possible to pass
a string specifying dimensions. Examples are:</p>
<p>&#8220;A/m&#8221;, &#8220;V/m&#8221;, &#8220;J/m^3&#8221;, &#8220;m^2 s^(-2)&#8221;, &#8220;m^-3 s^-1&#8221; etc.</p>
<p>The dimensions parser will understand (in addition to m, kg, s, A, K, mol, cd):
J, N, W, T, V, C, Ohm, H</p>
</li>
</ol>
<p>A very basic demonstration of the SI object in use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">1e-3</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
<span class="go">&lt;SI: 1.001  m &gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span>
<span class="go">&lt;SI: 0.001  m^2 &gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">&lt;</span><span class="n">SI</span><span class="p">:</span> <span class="mi">1000</span>  <span class="o">&gt;</span>           <span class="c">#Note that this is dimensionless</span>
<span class="go">                           #because we divided meters by meters</span>
</pre></div>
</div>
<div class="section" id="value">
<span id="id30"></span><h4>value<a class="headerlink" href="manual.html#value" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">SI.value</span></tt></dd>
<dt>Property information</dt>
<dd><tt class="xref docutils literal"><span class="pre">None</span></tt></dd>
</dl>
<p>Read-only attribute to obtain (dimensionless) value of Physical Object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>value</cite> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The numerical value.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">SI</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#39;A/m&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">H</span><span class="o">.</span><span class="n">value</span>
<span class="go">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">H</span>
<span class="go">&lt;SI: 10  A / m &gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="units">
<span id="id31"></span><h4>units<a class="headerlink" href="manual.html#units" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">SI.units</span></tt></dd>
<dt>Property information</dt>
<dd><tt class="xref docutils literal"><span class="pre">None</span></tt></dd>
</dl>
<p>Read-only attribute to obtain units of Physical Object (returned as list of pairs of dimension name and power)</p>
</div>
<div class="section" id="in-units-of">
<span id="id32"></span><h4>in_units_of<a class="headerlink" href="manual.html#in-units-of" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">SI.in_units_of</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">unit_quantity)</span></tt></dd>
</dl>
<p>The object will be expressed in multiplies of
&#8216;unit_quantity&#8217;. This is useful to convert from one
measurement convention (such as m/s) to another one (such as
km/h). The return value is just a float.</p>
<p>The units of &#8216;unit_quantity&#8217; have to be compatible with the
units of the object itself (otherwise an exception is raised).</p>
<p>A simple example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inch</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mf">2.54e-2</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">inch</span><span class="p">)</span>
<span class="go">393.70078740157478</span>
</pre></div>
</div>
<p>Another example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;s&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">velocity</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">/</span><span class="n">s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">velocity</span>
<span class="go">&lt;SI: 2  m / s &gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">km</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="n">m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="mi">3600</span><span class="o">*</span><span class="n">s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">velocity</span><span class="o">.</span><span class="n">in_units_of</span><span class="p">(</span><span class="n">km</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
<span class="go">8.2</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>unit_quantity</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first last">The SI object itself (i.e. <tt class="docutils literal"><span class="pre">self</span></tt>) will be expressed in
multiplies of this <tt class="docutils literal"><span class="pre">unit_quantity</span></tt>.  `</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>float</dt>
<dd><p class="first last">This is the number that, multiplied by the <tt class="docutils literal"><span class="pre">unit_quantitity</span></tt> will
provide the SI quantity of the object itself.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="is-compatible-with">
<span id="id33"></span><h4>is_compatible_with<a class="headerlink" href="manual.html#is-compatible-with" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">SI.is_compatible_with</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">physical_quantity)</span></tt></dd>
</dl>
<p>Returns True when the given physical quantity is compatible with the object
itself.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nsim.si_units</span> <span class="kn">import</span> <span class="n">SI</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m_per_sec</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">SI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;s&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">km_per_hour</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">SI</span><span class="p">(</span><span class="mi">3600</span><span class="p">,</span><span class="s">&#39;s&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Newton</span> <span class="o">=</span> <span class="n">SI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;kg&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">SI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">SI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;s&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m_per_sec</span><span class="o">.</span><span class="n">is_compatible_with</span><span class="p">(</span><span class="n">Newton</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m_per_sec</span><span class="o">.</span><span class="n">is_compatible_with</span><span class="p">(</span><span class="n">km_per_hour</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="ipython">
<span id="id34"></span><h3>ipython<a class="headerlink" href="manual.html#ipython" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">ipython</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(globals=None,</span> <span class="pre">locals=None)</span></tt></dd>
</dl>
<p>Interactive python prompt (see <a class="reference internal" href="manual.html#example-ipython"><em>Example: IPython</em></a>).</p>
</div>
<div class="section" id="command-line-options">
<span id="id35"></span><h3>Command line options<a class="headerlink" href="manual.html#command-line-options" title="Permalink to this headline">¶</a></h3>
<p>Nmag supports a number of command line options to configure its behaviour.</p>
<p>Suppose the simulation script is called <tt class="docutils literal"><span class="pre">X.py</span></tt>, then these OPTIONS can be specified like this:</p>
<div class="highlight-python"><pre>nsim X.py OPTIONS</pre>
</div>
<p><tt class="docutils literal"><span class="pre">X.py</span></tt> needs to contain at least the line <tt class="docutils literal"><span class="pre">import</span> <span class="pre">nmag</span></tt> as this will process the command line options.</p>
<p>The available options are:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">&#8211;clean:</th><td class="field-body"><p class="first">to override any existing <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> and <tt class="docutils literal"><span class="pre">_dat.ndt</span></tt> files. If this
option is not provided and the data files exist already, then nmag
will interrupt the execution without having modified the data files
on the disk.</p>
<p>Example:</p>
<div class="highlight-python"><pre>nsim X.py --clean</pre>
</div>
</td>
</tr>
<tr class="field"><th class="field-name">&#8211;loglevel:</th><td class="field-body"><p class="first">this switch determines the amount of information that is being send
to stdout (usually the screen) and also to the file <tt class="docutils literal"><span class="pre">X_log.log</span></tt>.</p>
<p>The available levels are in increasing order of detail:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">error:</th><td class="field-body">print no messages apart from errors</td>
</tr>
<tr class="field"><th class="field-name">warning:</th><td class="field-body">print warnings</td>
</tr>
<tr class="field"><th class="field-name">info:</th><td class="field-body">print a moderate amount of information (default)</td>
</tr>
<tr class="field"><th class="field-name">info2:</th><td class="field-body">print slightly more information</td>
</tr>
<tr class="field"><th class="field-name">debug:</th><td class="field-body">print a lot of information (typically for developer and debugging use)</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python"><pre>nsim X.py --loglevel info2</pre>
</div>
<p>or:</p>
<div class="highlight-python"><pre>nsim X.py --loglevel debug</pre>
</div>
</td>
</tr>
<tr class="field"><th class="field-name">&#8211;slavelog:</th><td class="field-body"><p class="first">Log message from slave nodes (when running under MPI) are usually
supressed. This switch activates them. Printing these messages will
reduce the MPI performance somewhat as the messages are printed to
stdout on each slave, and then have to be transferred through the
network to the master process.</p>
<p>Note that any log-messages from the nodes will only go to stdout
(whereas log messages from the master will also go into the log
file, see <a class="reference internal" href="manual.html#file-names-for-log-files"><em>File names for log files</em></a>.)</p>
<p>Messages from slave nodes are preceeded by <tt class="docutils literal"><span class="pre">S0X</span></tt> where X is the
rank of the node. I.e. log messages from slave node with rank 2,
would start with <tt class="docutils literal"><span class="pre">S02</span></tt>.</p>
<p>Example:</p>
<div class="highlight-python"><pre>nsim X.py --slavelog</pre>
</div>
</td>
</tr>
<tr class="field"><th class="field-name">&#8211;restart:</th><td class="field-body"><p class="first">If a calculation of a hysteresis loop is interrupted (power cut,
computer crash, exceeding allocated run time on cluster, etc), then
the calculation can be carried out starting from the moment when the
last restart file was saved (see <a class="reference internal" href="manual.html#restart-example"><em>Restart example</em></a>).</p>
<p>This continuation is activated with the <tt class="docutils literal"><span class="pre">--restart</span></tt> switch.</p>
<p>Example:</p>
<div class="highlight-python"><pre>nsim X.py --restart</pre>
</div>
<p class="last">Note that this functionality is only available for the hysteresis loop.</p>
</td>
</tr>
</tbody>
</table>
<p>The command line options can be combined, for example:</p>
<div class="highlight-python"><pre>nsim X.py --clean --loglevel debug</pre>
</div>
<p>There are a few other switches (mostly for debugging) which can be seen using:</p>
<div class="highlight-python"><pre>nsim X.py --help</pre>
</div>
</div>
</div>
<span id="document-finite_element_mesh_generation"></span><div class="section" id="finite-element-mesh-generation">
<span id="id1"></span><h2>Finite element mesh generation<a class="headerlink" href="manual.html#finite-element-mesh-generation" title="Permalink to this headline">¶</a></h2>
<p>Finite element mesh generation is a difficult business, and one needs
to get used to using at least one mesh generating software package to
be able to create meshes for the geometries one wants to simulate.</p>
<p>A list of available free and commercial mesh generators is available at:
<a class="reference external" href="http://www.andrew.cmu.edu/user/sowen/softsurv.html">http://www.andrew.cmu.edu/user/sowen/softsurv.html</a></p>
<p>For nmag one needs to create &#8216;unstructured&#8217; meshes which means for
three dimensional simulations that the mesh simplices are tetrahedra,
and the surface elements are triangles.</p>
<p>We are not recommending any mesh generating software. We have used
<a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> to generate most of the meshes for this manual. The
Vienna/Sheffield group (Fidler and Schrefl) use the commercial mesh
generator <em>GID</em> (<a class="reference external" href="http://gid.cimne.upc.es/">http://gid.cimne.upc.es/</a>).</p>
<p>The mesh format used by nmag is called  nmesh  and described in
<a class="reference internal" href="manual.html#nmesh-file-format"><em>Nmesh file format</em></a>.</p>
<p>The <a class="reference internal" href="manual.html#nmeshimport"><em>nmeshimport</em></a> tool provides conversion from the following mesh
formats into nmesh files:</p>
<ul>
<li><p class="first">Netgen (neutral). Create mesh in Netgen, then go to <tt class="docutils literal"><span class="pre">File-&gt;Export</span>
<span class="pre">Filetype</span></tt> and ensure that <tt class="docutils literal"><span class="pre">Neutral</span> <span class="pre">Format</span></tt> is selected. Then
export the mesh with <tt class="docutils literal"><span class="pre">File-&gt;Export</span> <span class="pre">Mesh</span></tt>. (See also <a class="reference internal" href="manual.html#mesh-generation"><em>Mesh generation</em></a> which is part of the <a class="reference internal" href="manual.html#guided-tour"><em>Guided Tour</em></a>.)</p>
</li>
<li><p class="first">There is a contributed import module for <a class="reference external" href="http://www.fluent.com/software/gambit/index.htm">Gambit</a>. Use at your own risk.</p>
</li>
<li><p class="first"><a class="reference external" href="http://www.geuz.org/gmsh/">Gmsh</a> meshes written file format version 1.0 can be imported.</p>
<p>If you already have the Gmsh mesh file in format 2.0, then you can use</p>
<div class="highlight-python"><pre>$&gt; gmsh -3 -format msh1 -o outfile.msh infile.msh</pre>
</div>
<p>to create &#8216;outfile.msh&#8217; which contains the mesh in the gmesh file format 1.0 that can be imported.</p>
<dl class="docutils">
<dt>If you create the mesh interactively, then</dt>
<dd><ul class="first last simple">
<li>choose <tt class="docutils literal"><span class="pre">FILE</span> <span class="pre">-&gt;</span> <span class="pre">SAVE</span> <span class="pre">AS</span></tt>,</li>
<li>select <tt class="docutils literal"><span class="pre">Gmsh</span> <span class="pre">mesh</span> <span class="pre">(*.msh)</span></tt> from the drop down list,</li>
<li>choose filename and click <tt class="docutils literal"><span class="pre">OK</span></tt></li>
<li>When the <tt class="docutils literal"><span class="pre">MSH</span> <span class="pre">Options</span></tt> box appears, choose <tt class="docutils literal"><span class="pre">Version</span> <span class="pre">1.0</span></tt> from the
drop down list in the Format field.</li>
<li>click <tt class="docutils literal"><span class="pre">OK</span></tt></li>
</ul>
</dd>
</dl>
<p>If you create your meshes automatically from the command line, then add <tt class="docutils literal"><span class="pre">--format</span> <span class="pre">msh1</span></tt> to the command line
to instruct <a class="reference external" href="http://www.geuz.org/gmsh/">Gmsh</a> to write in the 1.0 format.</p>
</li>
</ul>
<div class="section" id="nmesh-file-format">
<span id="id2"></span><h3>Nmesh file format<a class="headerlink" href="manual.html#nmesh-file-format" title="Permalink to this headline">¶</a></h3>
<p>There are two nmesh file formats: <a class="reference internal" href="manual.html#ascii-nmesh"><em>Ascii nmesh</em></a> and <a class="reference internal" href="manual.html#hdf5-nmesh"><em>Hdf5 nmesh</em></a>.</p>
<div class="section" id="ascii-nmesh">
<span id="id3"></span><h4>Ascii nmesh<a class="headerlink" href="manual.html#ascii-nmesh" title="Permalink to this headline">¶</a></h4>
<p>This section describes the syntax of the nmesh ascii files. You only
need to read this if you would like to know what the nmesh ascii
format looks like. This is only necessary if you (i) need to convert
nmesh ascii files into other mesh formats, or (ii) if you have
generated a mesh in a format that is not supported by <a class="reference internal" href="manual.html#nmeshimport"><em>nmeshimport</em></a>.</p>
<p>(You could in principle convert any data into the <cite>nmesh hdf5</cite> format
but it is expected that it is easier to convert the mesh into a <cite>nmesh
ascii</cite> file, and then use <a class="reference internal" href="manual.html#nmeshpp"><em>nmeshpp</em></a> with option <tt class="docutils literal"><span class="pre">--convert</span></tt> to
convert the mesh frnm nmesh ascii to nmesh hdf5.)</p>
<p>We describe the structure of the ascii nmesh file format using the
following example: A <a class="reference download internal" href="_downloads/smallsphere.nmesh"><tt class="xref download docutils literal"><span class="pre">mesh</span> <span class="pre">file</span></tt></a> for
a sphere with radius 1 (with <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> and this geometry file
<a class="reference download internal" href="_downloads/sphere.geo"><tt class="xref download docutils literal"><span class="pre">sphere.geo</span></tt></a>):</p>
<img alt="_images/smallsphere.png" class="align-center" src="_images/smallsphere.png" style="width: 480px; height: 434px;" />
<p>The mesh file looks as follows:</p>
<div class="highlight-python"><pre># PYFEM mesh file version 1.0
# dim = 3      nodes = 79      simplices = 174         surfaces = 148          periodic = 0
79
         0.000000000000            0.000000000000            0.000000000000
         1.000000000000            0.000000000000            0.000000000000
         0.911922000000            0.410365000000            0.000000000000
         0.941662000000            0.159249000000            0.296499000000
&lt;snip&gt;
         0.038305000000           -0.552912000000           -0.107777000000
        -0.533150000000            0.052091000000           -0.084880000000
174
     1         58          0         62         78
     1         33         78         36         50
     1         19         77          0         17
     1         67         75         78         72
&lt;snip&gt;
     1         58          0         53         62
     1         77         51         32         39
     1         78         67         63         72
     1         78         49         63         50
148
     -1 1     45 51 59
     1 -1     5 12 13
     1 -1     25 37 39
&lt;snip&gt;
     1 -1     19 30 34
     1 -1     42 44 54
     1 -1     32 45 51</pre>
</div>
<p>We have removed a significant number of lines for the purpose of
abbreviation in the places marked with <tt class="docutils literal"><span class="pre">&lt;snip&gt;</span></tt>. We discuss the
different parts of this file in more detail:</p>
<ul>
<li><p class="first">The file starts with two lines starting with <tt class="docutils literal"><span class="pre">#</span></tt>.</p>
<ul>
<li><p class="first">The first line contains a file format version string which needs to have
exactly this form.</p>
</li>
<li><p class="first">The second line contains a summary of the data, i.e.:</p>
<dl class="docutils">
<dt>dim</dt>
<dd><p class="first last">the dimensionality of the space in which the mesh is defined (usually 3,
as we work with meshes in 3d space).</p>
</dd>
<dt>nodes</dt>
<dd><p class="first last">the number of nodes (also called vertices), here <tt class="docutils literal"><span class="pre">79</span></tt></p>
</dd>
<dt>simplices</dt>
<dd><p class="first last">the number of simplices (also called volume elements), here <tt class="docutils literal"><span class="pre">174</span></tt>.
In 3d, a simplex is a tetrahedron.</p>
</dd>
<dt>surfaces</dt>
<dd><p class="first last">the number of surface elements, here <tt class="docutils literal"><span class="pre">148</span></tt>. In 3d, the surface
elements are triangles.</p>
</dd>
<dt>periodic</dt>
<dd><p class="first last">the number of periodic identifications of points.</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p class="first">The next section contains the data for all the nodes. The first line
of this section contains (again) the total number of nodes
(<tt class="docutils literal"><span class="pre">79</span></tt>). All subsequent 79 lines in this section contain each the
position of one node. Because the dimensionality of space in this
example is 3, there are 3 floating point numbers per node (i.e. the
x, y and z-component).</p>
</li>
<li><p class="first">The next section contains the data for the simplices. The first line
of this section contains (again) the total number of simplices (here
<tt class="docutils literal"><span class="pre">174</span></tt>). The next 174 lines contain the following information each:</p>
<p>The first integer is a <em>region identifier</em>. In this example, we have
only one region (the sphere). This is useful, if different magnetic
materials are simulated at the same time. When the mesh is loaded
into nmag, one assigns material properties to these regions.</p>
<p>The next 4 integers (in 3 dimensions) are node identifiers. The 4 nodes
listed here, form a simplex. Note that the very first node has index 0.</p>
</li>
<li><p class="first">The next section contains the data for the surface elements. The
first line contains the number of surface elements (<tt class="docutils literal"><span class="pre">148</span></tt>). The
next 148 lines contain each the following information:</p>
<ul class="simple">
<li>The first two integers are the region identifiers between which the
surface is sandwiched. If there is no simplex on one side of the surface,
then the &#8220;outside&#8221; region identifier of <tt class="docutils literal"><span class="pre">-1</span></tt> will be used. (It is possible
to use other negative numbers to discern between different parts of the outer
boundary. This is occasionally important in nsim to specify Dirichlet and
von Neumann boundary conditions along different parts of a boundary.)</li>
<li>The following integers are the node ids of the nodes that define
the surface. (In this example, we have three nodes as the surface
elements are triangles.)</li>
</ul>
<p>Note that this last section is only contained in the file to make the
users&#8217; life easier (for, say, plotting of the mesh). This section on
surface elements can be omitted and nmesh will read and process the mesh
even if the surface elements are not specified (they can be computed from
the node and simplex data provided in the other sections).</p>
</li>
<li><p class="first">The next section contains data about periodic points. The first line
again is the number of data lines to follow. Each data line gives the
node indices belonging to one set of points that are treated as
copies of the same point. (I.e. Nmag will know that field degrees of
freedom associated to points from such a set will have &#8220;mirage&#8221; copies and
use this information internally e.g. in the time integrator and when building
finite element matrix operators.)</p>
</li>
</ul>
</div>
<div class="section" id="hdf5-nmesh">
<span id="id4"></span><h4>Hdf5 nmesh<a class="headerlink" href="manual.html#hdf5-nmesh" title="Permalink to this headline">¶</a></h4>
<p>In addition to the <a class="reference internal" href="manual.html#ascii-nmesh"><em>Ascii nmesh</em></a> format, there is another (binary and
compressed) way of storing nmesh meshes. This is based on the <a class="reference external" href="http://www.hdfgroup.org/">hdf5</a>
library which often is abbreviated as <tt class="docutils literal"><span class="pre">h5</span></tt>.</p>
<p>We recommend that this file-format to store meshes as it is a
compressed binary file format, and thus much more space efficient. The
<a class="reference internal" href="manual.html#nmeshpp"><em>nmeshpp</em></a> tool can convert (using <tt class="docutils literal"><span class="pre">--convert</span></tt>) ascii nmesh files into
hdf5 files. Likewise, using the <a class="reference internal" href="manual.html#nmeshimport"><em>nmeshimport</em></a> tool with a target file
name that ends in <tt class="docutils literal"><span class="pre">.h5</span></tt> will also choose this file format. We
strongly recommend to use the extension <tt class="docutils literal"><span class="pre">.nmesh.h5</span></tt> (but <tt class="docutils literal"><span class="pre">.h5</span></tt> is
sufficient to trigger saving meshes in hdf5 format).</p>
<p>For conversion of other mesh formats to a format readable by nmesh,
we suggest to bring data into <a class="reference internal" href="manual.html#ascii-nmesh"><em>Ascii nmesh</em></a> format, and then convert
this ascii nmesh file to a .h5 file.</p>
<p>For completeness, we outline the <tt class="docutils literal"><span class="pre">nmesh.h5</span></tt> file format
here. Knowledge of <a class="reference external" href="http://www.hdfgroup.org/">hdf5</a> or <a class="reference external" href="http://www.pytables.org/">pytables</a> may be useful to understand the
underlying concepts.</p>
<p>The nmesh.h5 file contains the following nodes (this is output from
<a class="reference external" href="http://www.pytables.org/">pytables</a>&#8216;s <tt class="docutils literal"><span class="pre">ptdump</span></tt> program):</p>
<div class="highlight-python"><pre>/ (RootGroup) ''
/etc (Group) 'Configuration and version data'
/etc/filetype (Array(1L,)) 'data file type'
/etc/fileversion (Array(1L,)) 'data file type version'
/mesh (Group) 'Mesh data'
/mesh/points (CArray(1154L, 3L), shuffle,
              zlib(5)) 'Positions of mesh nodes (=points)'
/mesh/simplices (CArray(4953L, 4L), shuffle, zlib(5))
             'Indices of nodes (starting from zero).
              Each row is one simplex.'
/mesh/simplicesregions (CArray(4953L,), shuffle, zlib(5))
             'Region ids (one for each simplex).'</pre>
</div>
<p>In short, the position of the mesh nodes are stored in
<tt class="docutils literal"><span class="pre">/mesh/points</span></tt> as 8byte-floats. The simplices (i.e. tetrahedra in
3d) are stored in <tt class="docutils literal"><span class="pre">/mesh/simplices</span></tt> as a set of integers (4 in 3d)
per simplex which are the indices of the mesh nodes that form the
simplex. We also need to store to what physical region each simplex
belongs. Regions are coded by integer values (with 0 being vacuum, and
-1 the area outside the mesh) and stored in <tt class="docutils literal"><span class="pre">/mesh/simplicesregions</span></tt>.</p>
</div>
</div>
<div class="section" id="mesh-file-size">
<span id="id5"></span><h3>mesh file size<a class="headerlink" href="manual.html#mesh-file-size" title="Permalink to this headline">¶</a></h3>
<p>The following table shows the size of the mesh file used in <a class="reference internal" href="manual.html#example-2"><em>Example 2: Computing the time development of a system</em></a> stored in various formats.</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="20%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Filename</th>
<th class="head">size (kB)</th>
<th class="head">type</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>bar30_30_100.neutral</td>
<td>1036</td>
<td>ascii</td>
</tr>
<tr><td>bar30_30_100.neutral.gz</td>
<td>246</td>
<td>gzipped ascii</td>
</tr>
<tr><td>bar30_30_100.nmesh</td>
<td>794</td>
<td>ascii</td>
</tr>
<tr><td>bar30_30_100.nmesh.h5</td>
<td>203</td>
<td>hdf5</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The <tt class="docutils literal"><span class="pre">.neutral</span></tt> file is the mesh as written by <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> in this
particular format. The second line shows the file size of the same
file after compressing with <tt class="docutils literal"><span class="pre">gzip</span></tt>. The third line shows the size of
the mesh stored as an <a class="reference internal" href="manual.html#ascii-nmesh"><em>Ascii nmesh</em></a> file while the last line gives
the size of the corresponding <a class="reference internal" href="manual.html#hdf5-nmesh"><em>Hdf5 nmesh</em></a> file.</p>
</div>
</div>
<span id="document-executables"></span><div class="section" id="executables">
<span id="id1"></span><h2>Executables<a class="headerlink" href="manual.html#executables" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ncol">
<span id="id2"></span><h3>ncol<a class="headerlink" href="manual.html#ncol" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">ncol</span></tt> is a utility to conveniently analyse <a class="reference internal" href="manual.html#ndt"><em>Data files (.ndt)</em></a> files.</p>
<p>Suppose we have data file with name X_dat.ndt. We can then use:</p>
<div class="highlight-python"><pre>ncol X_dat.ndt</pre>
</div>
<p>or simply:</p>
<div class="highlight-python"><pre>ncol X</pre>
</div>
<p>to display the content of the file. This is useful to quickly gain an
overview of the data in the file.  For the <a class="reference internal" href="manual.html#example-2"><em>Example 2: Computing the
time development of a system</em></a>, the command is:</p>
<div class="highlight-python"><pre>ncol bar</pre>
</div>
<p>which produces this output:</p>
<div class="highlight-python"><pre>0 :         #time           #&lt;s&gt;              0
1 :            id             &lt;&gt;              0
2 :          step             &lt;&gt;              0
3 :  last_step_dt            &lt;s&gt;              0
4 :    stage_time            &lt;s&gt;              0
5 :    stage_step             &lt;&gt;              0
6 :         stage             &lt;&gt;              0
7 :    E_total_Py      &lt;kg/ms^2&gt;  -260346.5776034
8 :           phi            &lt;A&gt;  2.50626665111e-07
9 :      E_ext_Py      &lt;kg/ms^2&gt;              0
10:     H_demag_0          &lt;A/m&gt;  -263661.6673782
11:     H_demag_1          &lt;A/m&gt;  -8.212128727093
12:     H_demag_2          &lt;A/m&gt;  -77027.64089399
13:     dmdt_Py_0         &lt;A/ms&gt;  -8.250903922407e+15
14:     dmdt_Py_1         &lt;A/ms&gt;  2.333345040949e+16
15:     dmdt_Py_2         &lt;A/ms&gt;  8.250903922407e+15
16:           pin             &lt;&gt;              1
17:   H_anis_Py_0          &lt;A/m&gt;              0
18:   H_anis_Py_1          &lt;A/m&gt;              0
19:   H_anis_Py_2          &lt;A/m&gt;              0
20:        m_Py_0             &lt;&gt;  0.7071067811865
21:        m_Py_1             &lt;&gt;              0
22:        m_Py_2             &lt;&gt;  0.7071067811865
23:        M_Py_0          &lt;A/m&gt;  608111.8318204
24:        M_Py_1          &lt;A/m&gt;              0
25:        M_Py_2          &lt;A/m&gt;  608111.8318204
26:     E_anis_Py      &lt;kg/ms^2&gt;              0
27:     E_exch_Py      &lt;kg/ms^2&gt;  3.114630036477e-11
28:           rho        &lt;A/m^2&gt;  3.469702141876e+13
29:       H_ext_0          &lt;A/m&gt;              0
30:       H_ext_1          &lt;A/m&gt;              0
31:       H_ext_2          &lt;A/m&gt;              0
32:  H_total_Py_0          &lt;A/m&gt;  -263661.6673782
33:  H_total_Py_1          &lt;A/m&gt;  -8.212128727085
34:  H_total_Py_2          &lt;A/m&gt;  -77027.64089399
35:    E_demag_Py      &lt;kg/ms^2&gt;  -260346.5776034
36:   H_exch_Py_0          &lt;A/m&gt;  2.037901097873e-11
37:   H_exch_Py_1          &lt;A/m&gt;              0
38:   H_exch_Py_2          &lt;A/m&gt;  2.037901097873e-11
39: maxangle_m_Py          &lt;deg&gt;              0
40:     localtime             &lt;&gt;  2007/10/04-20:46:28
41:      unixtime            &lt;s&gt;  1191527188.269</pre>
</div>
<p>The four columns above show the following data: the first is just a
line number count. The second is the <em>name</em> of the data. The third
provides the <em>units</em> of this data type. The fourth displays the first
data value in the file (typically corresponding to the configuration
of the simulation when <a class="reference internal" href="manual.html#save-data"><em>save_data</em></a> was called the first time).</p>
<p>The meaning of the keywords <tt class="docutils literal"><span class="pre">time</span></tt>, <tt class="docutils literal"><span class="pre">id</span></tt>, <tt class="docutils literal"><span class="pre">step</span></tt>, <tt class="docutils literal"><span class="pre">stage_time</span></tt>,
<tt class="docutils literal"><span class="pre">stage_step</span></tt>, <tt class="docutils literal"><span class="pre">stage</span></tt>, <tt class="docutils literal"><span class="pre">localtime</span></tt> and <tt class="docutils literal"><span class="pre">unixtime</span></tt> is explained
in section <a class="reference internal" href="manual.html#stage-step-iteration-time-etc"><em>Stage, Step, iteration, time, etc.</em></a>.</p>
<p id="unique-identifier-id">The role of the <strong>id</strong> counter is to provide a reference to the
configuration that was saved, and it is a <strong>unique identifier</strong> of a
physical configuration. It is used to identify configurations in the
<tt class="docutils literal"><span class="pre">_dat.h5</span></tt> file (which stores spatially resolved fields) and to
identify the corresponding (spatially averaged) data in the
<tt class="docutils literal"><span class="pre">_dat.ndt</span></tt> file. This <tt class="docutils literal"><span class="pre">id</span></tt> is used to uniquely identify physical
configurations in nmag.  (See also: <a class="reference internal" href="manual.html#why-can-you-not-use-the-step-as-a-unique-identifier"><em>Why can you not use the step as a unique identifier?</em></a>)</p>
<p><tt class="docutils literal"><span class="pre">last_step_dt</span></tt> is the length of the last time step carried out by
the timestepper. This is a useful indicator to learn about the
stiffness of the system: the time step is adjusted automatically to
achieve a certain accuracy, and thus the size of the time step
reflects how hard it is to integrate the equations of motion.</p>
<p>The fields starting with <tt class="docutils literal"><span class="pre">E_total_Py</span></tt> down to <tt class="docutils literal"><span class="pre">H_exch_Py_2</span></tt> are
all nsim subfields (see <a class="reference internal" href="manual.html#field"><em>fields</em></a>), and the data stored for these are
spatially averaged numbers. For example, the subfield <tt class="docutils literal"><span class="pre">M_Py_0</span></tt> is
the x-component of the Magnetisation of the material <tt class="docutils literal"><span class="pre">Py</span></tt> averaged
over all the space where this material is defined.</p>
<p>The <tt class="docutils literal"><span class="pre">maxangle_m_Py</span></tt> is the maximum angle (in degree) of the change
of the magnetisation from one node in the mesh to the next. It is
important that this number is small: the equations on which the
micromagnetic theory is based assume that the magnetisation changes
slowly as a function of space. In the discretised solvers (this
applies to nmag as it applies to OOMMF, Magpar and other codes),
this means that the maximum angle between neighbouring sites should be
kept small. How small is good enough? This is hard to say in
general. We provide some (subjective) guidance: Values of 180 degrees
(or -180 degrees) quite clearly indicate that the results of the
calculations must not be trusted (i.e. they are wrong). Values around
90 degrees make the results highly questionable. Values of below 30
degrees indicate that the results are probably reliable. The smaller
the value, the more accurate the results will be. If this is new to you, you may want to read the <a class="reference internal" href="manual.html#mini-tutorial-micromagnetic-modelling"><em>Mini tutorial micromagnetic modelling</em></a> and in particular the section <a class="reference internal" href="manual.html#what-size-of-the-cells-fd-and-tetrahedra-fe-should-i-choose"><em>What size of the cells (FD) and tetrahedra (FE) should I choose?</em></a>.</p>
<p>The general syntax for calling <tt class="docutils literal"><span class="pre">ncol</span></tt> is:</p>
<div class="highlight-python"><pre>ncol [OPTIONS] datafile [COLS]</pre>
</div>
<p>A list of options can be obtained with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ncol</span> <span class="o">--</span><span class="n">help</span>
</pre></div>
</div>
<p>Available options include:</p>
<div class="highlight-python"><pre>-h, --help            show this help message and exit
--scale="{col1:factor1,col2:factor2,col3:factor3}"
                      scale col1 by factor1, col2 by factor 2 etc
--last-of="column"    Select only the rows where 'column' changes.
-l                    Select only the last row for each stage (i.e.
                      typically the relaxed state)
--mod="field"         Compute the magnitude of given field, i.e.
                      '--mod H_demag' computes
                      sqrt(H_demag_0^2+H_demag_1^2+H_demag_2^2). More than
                      one field can be provided (comma separated) but there
                      must be no spaces between the fields. (I.e. '--mod
                      m_Py,H_ext'). These modulus entries will be printed
                      last (after any other COLS that have been provided),
                      and in the order given in the '--mod' switch.
--odt                 Expect to process odt file (as produced by OOMMF, see
                      http://math.nist.gov/oommf/ and http://math.nist.gov/o
                      ommf/doc/userguide12a3/userguide/Data_Table_File_Forma
                      t_ODT.html).</pre>
</div>
</div>
<div class="section" id="nmagpp">
<span id="id3"></span><h3>nmagpp<a class="headerlink" href="manual.html#nmagpp" title="Permalink to this headline">¶</a></h3>
<p>The stage <tt class="docutils literal"><span class="pre">nmagpp</span></tt> program is the NMAG data PostProcessor. It can be used to</p>
<ul class="simple">
<li>convert data stored in <tt class="docutils literal"><span class="pre">RUNID_dat.h5</span></tt> files into vtk files</li>
<li>dump the data to the screen.</li>
</ul>
<p>The documentation is available with the <tt class="docutils literal"><span class="pre">--help</span></tt> switch:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">nmagpp</span> <span class="o">--</span><span class="n">help</span>
</pre></div>
</div>
<div class="section" id="inspecting-the-content">
<span id="id4"></span><h4>Inspecting the content<a class="headerlink" href="manual.html#inspecting-the-content" title="Permalink to this headline">¶</a></h4>
<p>We describe some typical scenarios, using the data file <tt class="docutils literal"><span class="pre">bar_dat.h5</span></tt>
that is generated in <a class="reference internal" href="manual.html#example-2"><em>Example 2: Computing the time development of a
system</em></a>.</p>
<p>The <tt class="docutils literal"><span class="pre">bar_dat.h5</span></tt> file contains spatially resolved data for all
fields in the simulation (because we have used the
<tt class="docutils literal"><span class="pre">save_data(fields='all')</span></tt> command). Some of the functions of
<tt class="docutils literal"><span class="pre">nmagpp</span></tt> apply to one or more fields (such as <tt class="docutils literal"><span class="pre">--dump</span></tt> and
<tt class="docutils literal"><span class="pre">--vtk</span></tt>) and these can be specified through a <tt class="docutils literal"><span class="pre">--fields</span></tt> command
line parameter. Similarly, the <tt class="docutils literal"><span class="pre">--range</span></tt> command will limit the number of saved configurations which will be processed.</p>
<p>Try <tt class="docutils literal"><span class="pre">nmagpp</span> <span class="pre">--help</span></tt> for further documentation. Some examples:</p>
<ul>
<li><p class="first">Checking what at what configurations have been saved:</p>
<div class="highlight-python"><pre>nmagpp --idlist bar</pre>
</div>
<p>produces:</p>
<div class="highlight-python"><pre>id   stage   step     time fields
 0-&gt;    1      0         0 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
10-&gt;    1    312     5e-11 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
20-&gt;    1    495     1e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
30-&gt;    1    603   1.5e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
40-&gt;    1    678     2e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
50-&gt;    1    726   2.5e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
60-&gt;    1    762     3e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho</pre>
</div>
</li>
</ul>
<p>The <tt class="docutils literal"><span class="pre">id</span></tt> is the same <a class="reference internal" href="manual.html#unique-identifier-id"><em>unique identifier id</em></a> used in the <a class="reference internal" href="manual.html#ndt"><em>Data files (.ndt)</em></a> files that can be
read with the <a class="reference internal" href="manual.html#ncol"><em>ncol</em></a> command. In particular, its purpose is to identify
time steps saved in the ndt file with the corresponding data saved in
the h5 data file.</p>
<p>Columns <tt class="docutils literal"><span class="pre">time</span></tt> (measured in seconds), <tt class="docutils literal"><span class="pre">step</span></tt> and <tt class="docutils literal"><span class="pre">stage</span></tt> are
just providing some further information (see <a class="reference internal" href="manual.html#stage-step-iteration-time-etc"><em>Stage, Step, iteration, time, etc.</em></a>) Finally, the available (i.e. saved) fields for every
configuration are listed. The list of fields is not displayed
completely if it is long (unless the <tt class="docutils literal"><span class="pre">--printall</span></tt> switch is used).</p>
</div>
<div class="section" id="dumping-data">
<span id="id5"></span><h4>Dumping data<a class="headerlink" href="manual.html#dumping-data" title="Permalink to this headline">¶</a></h4>
<p>Suppose we are interested in the magnetisation data stored at id
0. We restrict the data to the <tt class="docutils literal"><span class="pre">m</span></tt> field using the <tt class="docutils literal"><span class="pre">--fields</span> <span class="pre">m</span></tt> switch, and restrict the number <tt class="docutils literal"><span class="pre">ids</span></tt> to dump using <tt class="docutils literal"><span class="pre">--range</span> <span class="pre">0</span></tt>:</p>
<div class="highlight-python"><pre>nmagpp --fields m --range 0 --dump bar</pre>
</div>
<p>produces output that starts like this:</p>
<div class="highlight-python"><pre>field    : m
subfield : m_Py
time     : 0 * &lt;SI: 1  s &gt;
id       : 0
step     : 0
stage    : 0
field unit: &lt;SI: 1  &gt;
position unit: &lt;SI: 1e-09  m &gt;
row: 0
#Start (index in h5 table, dofsite, pos, data)
   0:   0 : (  0,  0,  0) : (    0.707107,            0,     0.707107)
   1:   1 : (  3,  0,  0) : (    0.707107,            0,     0.707107)
   2:   2 : (  6,  0,  0) : (    0.707107,            0,     0.707107)
   3:   3 : (  9,  0,  0) : (    0.707107,            0,     0.707107)</pre>
</div>
<p>The first few rows provide some metadata such as which field and
subfield the data is about, at what simulation time it was saved (here
0 seconds), what the id, step and stage is. It further shows the
<tt class="docutils literal"><span class="pre">field</span> <span class="pre">unit</span></tt> and the <tt class="docutils literal"><span class="pre">position</span> <span class="pre">unit</span></tt>. These give the physical
dimensions with which the numerical quantities from the table have to
be multiplied to get dimensionful physical quantities. For example,
the positions in the table are provided as <tt class="docutils literal"><span class="pre">(0,0,0)</span></tt>, <tt class="docutils literal"><span class="pre">(3,0,0)</span></tt>,
<tt class="docutils literal"><span class="pre">(6,0,0)</span></tt> etc. These numbers have to be multiplied by
<tt class="docutils literal"><span class="pre">&lt;SI:</span> <span class="pre">1e-09</span> <span class="pre">m</span> <span class="pre">&gt;</span></tt> = 1e-9 meters to obtain the actual positions
in SI units. In other words, the position coordinate data is expressed in
nanometers. In this particular example, the field data &#8211; the normalised
magnetisation &#8211; is dimensionless.</p>
<p>Followed by the keyword <tt class="docutils literal"><span class="pre">#Start</span></tt> the actual data starts (in the next
line).  The format of the subsequent data lines is as follows:</p>
<ul class="simple">
<li>Column 1: index of the site in the h5 file. This mostly relevant for
developers.</li>
<li>Column 2: the index of the site. As long as we are dealing with
first order basis functions (as is nearly always the case in
micromagnetics), this is equivalent to the node id in the mesh.</li>
<li>Columns 3, 4, 5: enclosed in parentheses, the position of the site
is expressed in units of the <tt class="docutils literal"><span class="pre">position</span> <span class="pre">unit</span></tt>.</li>
<li>Columns 6, 7, 8: enclosed in parentheses, the actual field data
expressed in units of the <tt class="docutils literal"><span class="pre">field</span> <span class="pre">unit</span></tt>.</li>
</ul>
<p>In short, the first line of the actual data:</p>
<div class="highlight-python"><pre>0:   0 : (  0,  0,  0) : (    0.707107,            0,     0.707107)</pre>
</div>
<p>tells us that the normalised magnetisation at node id <tt class="docutils literal"><span class="pre">0</span></tt>, and
position <tt class="docutils literal"><span class="pre">(0,0,0)</span> <span class="pre">nm</span></tt> is pointing in the direction
<tt class="docutils literal"><span class="pre">(0.707107,0,0.707107)</span></tt>.</p>
<p>Another example: Suppose we are interested in the magnetisation field
<tt class="docutils literal"><span class="pre">M</span></tt> (this is the non-normalised magnetisation measured in Ampere per
meter) at time 1e-10 seconds (i.e. id=20). We use this
command:</p>
<div class="highlight-python"><pre>nmagpp --fields M --dump --range 20 bar</pre>
</div>
<p>to obtain output beginning like this:</p>
<div class="highlight-python"><pre>field    : m
subfield : m_Py
time     : 1e-10 * &lt;SI: 1  s &gt;
id       : 20
step     : 495
stage    : 1
field unit: &lt;SI: 1  &gt;
position unit: &lt;SI: 1e-09  m &gt;
row: 2
#Start (index in h5 table, dofsite, pos, data)
   0          0 (           0            0            0 ) (    0.182556     0.525948     0.830694 )
   1          1 (           3            0            0 ) (    0.165008     0.534525     0.828888 )
   2          2 (           6            0            0 ) (    0.104837     0.544846     0.831957 )
   3          3 (           9            0            0 ) (    0.029925     0.552054     0.833272 )
   4</pre>
</div>
<p>In principle, this output data can be parsed by other tools to extract
the positions and the data. However, it is hoped that other options of
the nmagpp tool (such as the <tt class="docutils literal"><span class="pre">--vtk</span></tt> switch ) already cover most of
the situations where the need to convert data may arise. (If you would
like to export the raw data into another file format or application,
please contact the <a class="reference internal" href="manual.html#contact"><em>nmag team</em></a> to request this feature, as it may be
of interest to other people as well.)</p>
<p>It is further possible to access the data in the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> files
directly from tailor written post-processing scripts. See <a class="reference internal" href="manual.html#example-post-processing-of-saved-field-data"><em>example:
post processing of saved field data</em></a>.</p>
</div>
<div class="section" id="range-of-data-to-be-processed">
<span id="id6"></span><h4>Range of data to be processed<a class="headerlink" href="manual.html#range-of-data-to-be-processed" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">--range</span></tt> switch allows a variety of ways to express which of
the <tt class="docutils literal"><span class="pre">ids</span></tt> in the data file should be selected (for dumping to the
screen, or conversion to a vtk file). Here are some examples:</p>
<div class="highlight-python"><pre>--range 17                        #will select 17
--range "range(5,10)"             #will select [5,6,7,8,9]
--range "[2,5,10,42]"             #will select [2,5,10,42]
--range "range(10)+[20,25,31,42]" #will select [0,1,2,3,...,9,10,20,25,31,42]
--range "max(ids)"                #will select the last saved id</pre>
</div>
</div>
<div class="section" id="conversion-to-vtk-file">
<span id="id7"></span><h4>Conversion to vtk file<a class="headerlink" href="manual.html#conversion-to-vtk-file" title="Permalink to this headline">¶</a></h4>
<p>The command</p>
<blockquote>
<div>nmagpp &#8211;range 0 &#8211;vtk test.vtk bar</div></blockquote>
<p>will take the dataset with <tt class="docutils literal"><span class="pre">id</span></tt>=0 in the <tt class="docutils literal"><span class="pre">bar_dat.h5</span></tt> file and convert it
to a (binary) vtk file with name <tt class="docutils literal"><span class="pre">test.vtk</span></tt>. For vtk files, the
default is to convert all fields. However, if a field (or a list of fields) is specified
using the <tt class="docutils literal"><span class="pre">--field</span></tt> option, then only this field is converted. This
may be useful if disk space or conversion time is an issue.</p>
<p>We can convert multiple time steps into a set of vtk files with one
command. For example, to convert for all saved configurations all
fields into vtk files, use:</p>
<div class="highlight-python"><pre>nmagpp --vtk alltest.vtk bar</pre>
</div>
<p>This will create files <tt class="docutils literal"><span class="pre">alltest-000000.vtk</span></tt>, <tt class="docutils literal"><span class="pre">alltest-000010.vtk</span></tt>,
<tt class="docutils literal"><span class="pre">alltest-000020.vtk</span></tt>, <tt class="docutils literal"><span class="pre">alltest-000030.vtk</span></tt>, <tt class="docutils literal"><span class="pre">alltest-000040.vtk</span></tt>,
<tt class="docutils literal"><span class="pre">alltest-000050.vtk</span></tt>, and <tt class="docutils literal"><span class="pre">alltest-000060.vtk</span></tt>.</p>
<p>The conversion to vtk can be combined with the <tt class="docutils literal"><span class="pre">--range</span></tt> command.
(See  <a class="reference internal" href="manual.html#range-of-data-to-be-processed"><em>Range of data to be processed</em></a>). For example, to convert every
second saved configuration (i.e. ids 0, 20, 40) into vtk files, we could use:</p>
<div class="highlight-python"><pre>nmagpp --range "range(0,60,20)" --vtk x.vtk bar</pre>
</div>
<p>The string &#8220;range(0,60,20)&#8221; is a Python expression and will evaluate
to [0,20,40] (because it is the list of integers starting from 0,
going up to [but not including] 60, in steps of 20). This will create
files <tt class="docutils literal"><span class="pre">x-000000.vtk</span></tt>, <tt class="docutils literal"><span class="pre">x-000020.vtk</span></tt> and <tt class="docutils literal"><span class="pre">x-000040.vtk</span></tt>.</p>
</div>
<div class="section" id="other-features">
<span id="id8"></span><h4>Other features<a class="headerlink" href="manual.html#other-features" title="Permalink to this headline">¶</a></h4>
<p>Use:</p>
<blockquote>
<div>nmagpp &#8211;help</div></blockquote>
<p>to get an overview of other features of nmag, and further details.</p>
</div>
</div>
<div class="section" id="nmeshpp">
<span id="id9"></span><h3>nmeshpp<a class="headerlink" href="manual.html#nmeshpp" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">nmeshpp</span></tt> program is the NMESHPreProcesser and NMESHPostProcessor.
It provides quick access to some statistical information
about nmesh meshes. The basic usage is</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">nmeshpp</span> <span class="pre">[OPTIONS]</span> <span class="pre">INPUTFILE</span> <span class="pre">[OUTPUTFILE]</span></tt></div></blockquote>
<p>where <tt class="docutils literal"><span class="pre">INPUT</span></tt> is the name of a nmesh file (either in ascii or hdf5
format), <tt class="docutils literal"><span class="pre">OUTPUTFILE</span></tt> is the name of the file to be written to (if
required; this depends on the <tt class="docutils literal"><span class="pre">OPTIONS</span></tt>) and OPTIONS can be one or
several of the options listed in the following subsections. We use the
mesh file <a class="reference download internal" href="_downloads/bar30_30_100.nmesh.h5"><tt class="xref download docutils literal"><span class="pre">bar30_30_100.nmesh.h5</span></tt></a> from <a class="reference internal" href="manual.html#example-2"><em>Example 2</em></a> to
illustrate the usage of <a class="reference internal" href="manual.html#nmeshpp"><em>nmeshpp</em></a>.</p>
<div class="section" id="general-information-info">
<span id="id10"></span><h4>General information (<tt class="docutils literal"><span class="pre">--info</span></tt>)<a class="headerlink" href="manual.html#general-information-info" title="Permalink to this headline">¶</a></h4>
<p>The command:</p>
<div class="highlight-python"><pre>nmeshpp --info bar30_30_100.nmesh.h5</pre>
</div>
<p>produces the following output:</p>
<div class="highlight-python"><pre>====== Info output: ========================================================
3-dimensional mesh
18671 volume elements (3d)
 3438 surface elements (2d)
 4086 points
    1 simplex regions ([1])
    2 point regions ([-1, 1])
    2 region volumes ([0.0, 89999.999999999782])
 1721 boundary points (-&gt; BEM size&lt;=  22MB)
    0 periodic points (mirage=0, total=0)
a0: average=3.543451, std=0.581220, min=1.953689, max=5.708395</pre>
</div>
<p>Starting from the top of the output, we are given the information that
this is a three-dimensional mesh, with its number of <em>volume elements</em>
(i.e. tetrahedra in 3d), <em>surface elements</em> (i.e. surface triangles) and
<em>points</em>.</p>
<p>We are also given a list of <em>simplex regions</em> (which is just [1]
here). If we had more than one region defined (say two disconnected
spheres that are to be associated with different material), then we
would have two entries here. The numbers given in this list are the
identifiers of the regions: in this example there is only one region
and it has the identifier 1.</p>
<p>The <em>point regions</em> is a list of all regions in which points are
located. This includes of course region 1. Region -1 represents the
vacuum around the meshed region. The points that are located on the
surface of the bar are located both in the bar (region 1) and in the
vacuum (region -1). Other negative region numbers (-2, -3) can be used
to discern different pieces of a boundary. (While this feature is at
present not used by Nmag, the underlying nsim framework provides
capabilities to e.g. associate Dirichlet boundary conditions to a
1/-1 boundary and von Neumann boundary conditions to a 1/-2 boundary.)</p>
<p>The <em>region volumes</em> provide the geometrical volume of the regions. By
convention, the vacuum has volume 0. In this example, the bar volume
is meant to be 30x30x100=90000. The deviation from this due to limited
numerical precision (and of the order of 1e-10).</p>
<p>The <em>boundary points</em> are the number of nodes located at the surface
of the bar. This number is important if using the hybrid finite
element/boundary element method to compute the demagnetisation field,
as the boundary element matrix size will be proportional to the square
of the number of boundary points. The size of the boundary element
matrix is given as well (see <a class="reference internal" href="manual.html#memory-requirements-of-boundary-element-matrix"><em>Memory requirements of boundary element matrix</em></a>).</p>
<p>The <em>periodic points</em> are the number of points that have <em>mirage
images</em> in the mesh. There will always be zero periodic points (and
thus zero mirage images) unless we are dealing with a periodic mesh
(see <a class="reference internal" href="manual.html#nmeshmirror"><em>nmeshmirror</em></a> and <a class="reference internal" href="manual.html#spin-waves-example"><em>Example: Spin-waves in periodic system</em></a>).</p>
<p>Finally, we are given some information about the statistics of the
edge lengths <em>a0</em> in the mesh: the average value, the standard
deviation, the maximum and minimum value. This is important as in
micromagnetics the angle of the magnetisation must not vary strongly
from one node to the next. In practice, the edge length a0 should
therefore be (significantly) smaller than the exchange length (see
<a class="reference internal" href="manual.html#what-size-of-the-cells-fd-and-tetrahedra-fe-should-i-choose"><em>What size of the cells (FD) and tetrahedra (FE) should I choose?</em></a>)</p>
</div>
<div class="section" id="memory-requirements-of-boundary-element-matrix">
<span id="id11"></span><h4>Memory requirements of boundary element matrix<a class="headerlink" href="manual.html#memory-requirements-of-boundary-element-matrix" title="Permalink to this headline">¶</a></h4>
<p>The boundary element matrix is densely populated matrix with s rows
and s columns, where s is the number of surface nodes in the
mesh. (Strictly, it is only the number of surface nodes that enclose a
ferromagnetic material.) Assuming we use 8 bytes to store one floating
point number, we can thus estimate the memory required to store this
matrix. In the example above, we have 1721 boundary points, and thus
1721*1721=2961841 matrix entries. Each entry requires 8 byte, so the
total memory requirement is 23694728 bytes, or approximately 23139
kilobytes or 23 megabytes.</p>
<p>The <tt class="docutils literal"><span class="pre">nmeshpp</span> <span class="pre">-i</span></tt> command can be used to quickly check how big the
BEM matrix is. A computation is only feasible if the RAM of the
computer can hold the boundary element matrix. (When carrying out a
distributed calculation, it is sufficient if the total RAM of all
machines can hold the matrix.)</p>
</div>
<div class="section" id="inspecting-the-quality-of-a-mesh">
<span id="id12"></span><h4>Inspecting the quality of a mesh<a class="headerlink" href="manual.html#inspecting-the-quality-of-a-mesh" title="Permalink to this headline">¶</a></h4>
<p>The quality of a mesh can be defined in various ways. In
micromagnetics, we usually want tetrahedra that have edges of nearly
identical length (i.e. we do not want the tetrahedra to be flat).</p>
<p><tt class="docutils literal"><span class="pre">nmeshpp</span></tt> uses the ratio of the radius of the in-sphere (the sphere
that can just fit into a tetrahedron so that it touches the sides) to
radius of the circumsphere (the sphere passing through the four corners),
multiplied by the number of dimensions. This number is 1.0 for a
perfect tetrahedron with identical edge lengths, and 0 for a
completely flat (effectively 2-dimensional) tetrahedron.</p>
<p>The command:</p>
<div class="highlight-python"><pre>nmeshpp -q bar30_30_100.nmesh.h5</pre>
</div>
<p>computes a histogram of the distribution of this quality parameter for
the bar mesh, and produces this output:</p>
<div class="highlight-python"><pre>====== Quality output: ======================================================
[qual interval] counts = probability
[ 0.000- 0.100]      0 = 0.00%
[ 0.100- 0.200]      0 = 0.00%
[ 0.200- 0.300]      0 = 0.00%
[ 0.300- 0.400]      0 = 0.00%
[ 0.400- 0.500]      1 = 0.01% *
[ 0.500- 0.600]     42 = 0.22% *
[ 0.600- 0.700]    364 = 1.95% **
[ 0.700- 0.800]   2420 =12.96% ************
[ 0.800- 0.900]   8252 =44.20% ****************************************
[ 0.900- 1.000]   7592 =40.66% *************************************</pre>
</div>
</div>
<div class="section" id="histogram-of-edge-lengths">
<span id="id13"></span><h4>Histogram of edge lengths<a class="headerlink" href="manual.html#histogram-of-edge-lengths" title="Permalink to this headline">¶</a></h4>
<p>The command:</p>
<div class="highlight-python"><pre>nmeshpp -a bar30_30_100.nmesh.h5</pre>
</div>
<p>computes a histogram of the edge length distribution of the mesh:</p>
<div class="highlight-python"><pre>====== a0 output: ===========================================================
[a0   interval] counts = probability
[ 1.954- 2.329]    234 = 0.63% **
[ 2.329- 2.705]   1424 = 3.81% *******
[ 2.705- 3.080]   7921 =21.17% *************************************
[ 3.080- 3.456]   8790 =23.50% ****************************************
[ 3.456- 3.831]   7573 =20.24% ***********************************
[ 3.831- 4.207]   5884 =15.73% ***************************
[ 4.207- 4.582]   3769 =10.08% ******************
[ 4.582- 4.957]   1385 = 3.70% *******
[ 4.957- 5.333]    365 = 0.98% **
[ 5.333- 5.708]     63 = 0.17% *

average   a0: &lt;a0&gt;   = 3.543451
stand dev a0: &lt;a0^2&gt; = 0.581220^2
min and max :        =(1.953689,5.708395)</pre>
</div>
</div>
</div>
<div class="section" id="convert-nmesh-h5-to-nmesh-file-and-back">
<span id="id14"></span><h3>Convert nmesh.h5 to nmesh file (and back)<a class="headerlink" href="manual.html#convert-nmesh-h5-to-nmesh-file-and-back" title="Permalink to this headline">¶</a></h3>
<p>The command:</p>
<div class="highlight-python"><pre>nmeshpp -c mesh.nmesh.h5 mesh.nmesh</pre>
</div>
<p>converts a the mesh <tt class="docutils literal"><span class="pre">mesh.nmesh.h5</span></tt> (in h5 format) to the <tt class="docutils literal"><span class="pre">mesh.nmesh</span></tt> (in ascii format). Works also in the reverse way. <tt class="docutils literal"><span class="pre">nmeshpp</span></tt> will save as <tt class="docutils literal"><span class="pre">h5</span></tt> file if the last extension of the file to write is <tt class="docutils literal"><span class="pre">.h5</span></tt>.</p>
<div class="section" id="nmeshmirror">
<span id="id15"></span><h4>nmeshmirror<a class="headerlink" href="manual.html#nmeshmirror" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">nmeshmirror</span></tt> tool can create periodic meshes out of a non-periodic mesh. The geometry described by the non-periodic mesh has to
be a cuboid. This can be mirrored along one (or more) of the planes
defined by the sides of the cuboid.</p>
<p>The general usage is</p>
<div class="highlight-python"><pre>nmeshmirror meshfile error1 error2 directions newfile remove</pre>
</div>
<p>where:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">meshfile</span></tt> is the original (non-periodic) ASCII nmesh file</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">error1</span></tt> is the maximum distance between two points in
order to consider them coincident (case of points on mirroring planes)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">error2</span></tt> is the maximum distance between a point and the surface
opposite to the one used as mirroring plane in order to consider the
point periodic</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">directions</span></tt> is a list of values 0,1 or -1, corresponding to the
direction(s) over which the mesh is mirrored: 1 corresponds to
mirroring along the positive given axis, -1 along the negative given
axis and 0 corresponds to no mirroring along the given axis.</p>
<p>For a three dimensional mesh, there are three options to mirror the
mesh (along the x, y and z direction). In that case, the
<tt class="docutils literal"><span class="pre">directions</span></tt> would be a list of three integers, for example
<tt class="docutils literal"><span class="pre">0,1,0</span></tt> to mirror the input mesh on the xz plane that limits the
mesh in the y direction.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">newfile</span></tt> is the name of the ASCII file with the new periodic mesh</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">remove</span></tt> is an optional argument which takes the values 0 and 1
and removes the periodic points from the final mesh when is set to 1.
The default value is 0.</p>
</li>
</ul>
<p>Calling <tt class="docutils literal"><span class="pre">orig.nmesh</span></tt> the ASCII file of a 3D non-periodic mesh, an example
of the use of nmeshmirror is the following, where the mesh is mirrored
along the positive x-axis and the negative z-axis:</p>
<div class="highlight-python"><pre>nmeshmirror orig.nmesh 1e-6 1e-6 1,0,-1 periodic.nmesh</pre>
</div>
<p>resulting in a periodic mesh along the same axes.</p>
</div>
<div class="section" id="nmeshsort">
<span id="id16"></span><h4>nmeshsort<a class="headerlink" href="manual.html#nmeshsort" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">nmeshsort</span></tt> script sorts the nodes of a mesh along a given axis
(not recommended when using parmetis with multiple-object meshes). We
expect this to be most relevant to developers.</p>
<p>The general usage is</p>
<div class="highlight-python"><pre>nmeshsort meshfile axis newfile</pre>
</div>
<p>where:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">meshfile</span></tt> is the original ASCII nmesh file</li>
<li><tt class="docutils literal"><span class="pre">axis</span></tt> is the axis over which the sorting takes place</li>
<li><tt class="docutils literal"><span class="pre">newfile</span></tt> is the name of the ASCII file with the new periodic mesh</li>
</ul>
<p>Calling <tt class="docutils literal"><span class="pre">orig.nmesh</span></tt> the ASCII file of a 3D mesh, an example
of the use of nmeshsort is the following, where the mesh is sorted
along the z-axis:</p>
<div class="highlight-python"><pre>nmeshsort orig.nmesh 2 sorted.nmesh</pre>
</div>
</div>
</div>
<div class="section" id="nmeshimport">
<span id="id17"></span><h3>nmeshimport<a class="headerlink" href="manual.html#nmeshimport" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="manual.html#nmeshimport"><em>nmeshimport</em></a> command can be used to read other mesh formats and write them into the nmesh format that can be read by nmag.</p>
<p>The <tt class="docutils literal"><span class="pre">nmeshimport</span></tt> tool can convert <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a>, Gambit and <a class="reference external" href="http://www.geuz.org/gmsh/">Gmsh</a> files
into nmesh files.</p>
<p>The general usage is:</p>
<div class="highlight-python"><pre>nmeshimport OPTIONS INPUTFILE NMESHFILE</pre>
</div>
<p>The OPTION to import from <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> is <tt class="docutils literal"><span class="pre">--netgen</span></tt>. The (contributed)
code for importing from a Gambit mesh file is <tt class="docutils literal"><span class="pre">--gambit</span></tt>.
The OPTION to import from <a class="reference external" href="http://www.geuz.org/gmsh/">Gmsh</a> is <tt class="docutils literal"><span class="pre">--gmsh</span></tt>.</p>
<p>Usage example: assuming we have a file <tt class="docutils literal"><span class="pre">mymesh.neutral</span></tt> created with
<a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> and would like to convert it to <tt class="docutils literal"><span class="pre">mymesh.nmesh.h5</span></tt>, we could
use this command:</p>
<div class="highlight-python"><pre>nmeshimport --netgen mymesh.neutral mymesh.nmesh.h5</pre>
</div>
<p>Use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">nmeshimport</span> <span class="o">--</span><span class="n">help</span>
</pre></div>
</div>
<p>to see all available features.</p>
</div>
<div class="section" id="nsim">
<span id="id18"></span><h3>nsim<a class="headerlink" href="manual.html#nsim" title="Permalink to this headline">¶</a></h3>
<p>This is the main executable. It superficially appears to be a Python
interpreter, but has extended functionality. In particular, it has
support for parallel execution (using MPI), and contains extensions
accessible in the additional built-in <tt class="docutils literal"><span class="pre">ocaml</span></tt> module which provides
the additional functionality of the nsim multiphysics
system. (Nmag is a Python library on top of nsim, which itself is
implemented in Objective Caml.)</p>
</div>
<div class="section" id="nsimversion">
<span id="id19"></span><h3>nsimversion<a class="headerlink" href="manual.html#nsimversion" title="Permalink to this headline">¶</a></h3>
<p>A script that provides some information about the version of the
software.</p>
<p>If you need to report a bug/problem, please include the
output of this program.</p>
<p>From release 0.2 onwards, please use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">nsim</span> <span class="o">--</span><span class="n">version</span>
</pre></div>
</div>
<p>instead.</p>
</div>
</div>
<span id="document-files_and_file_names"></span><div class="section" id="files-and-file-names">
<span id="id1"></span><h2>Files and file names<a class="headerlink" href="manual.html#files-and-file-names" title="Permalink to this headline">¶</a></h2>
<div class="section" id="mesh-files-nmesh-nmesh-h5">
<span id="id2"></span><h3>mesh files (<tt class="docutils literal"><span class="pre">.nmesh</span></tt>, <tt class="docutils literal"><span class="pre">.nmesh.h5</span></tt>)<a class="headerlink" href="manual.html#mesh-files-nmesh-nmesh-h5" title="Permalink to this headline">¶</a></h3>
<p>Files that contain a finite element mesh. See <a class="reference internal" href="manual.html#nmesh-file-format"><em>Nmesh file format</em></a>.</p>
</div>
<div class="section" id="simulation-scripts-py">
<span id="id3"></span><h3>Simulation scripts (<tt class="docutils literal"><span class="pre">.py</span></tt>)<a class="headerlink" href="manual.html#simulation-scripts-py" title="Permalink to this headline">¶</a></h3>
<p>Files that contain simulation program code. The ending is (by
convention) <tt class="docutils literal"><span class="pre">.py</span></tt> which reflects that the programming language used
is Python.</p>
<p>All the example codes provided in the <a class="reference internal" href="manual.html#guided-tour"><em>Guided Tour</em></a> are such simulation scripts.</p>
</div>
<div class="section" id="data-files-ndt">
<span id="ndt"></span><h3>Data files (<tt class="docutils literal"><span class="pre">.ndt</span></tt>)<a class="headerlink" href="manual.html#data-files-ndt" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">ndt</span></tt> stands for Nmag Data Table, analog to <tt class="docutils literal"><span class="pre">odt</span></tt> files (<a class="reference external" href="http://math.nist.gov/oommf/">OOMMF</a>
Data Table) for the OOMMF project. In fact, <tt class="docutils literal"><span class="pre">ndt</span></tt> and <tt class="docutils literal"><span class="pre">odt</span></tt> files
are very similar.</p>
<p><tt class="docutils literal"><span class="pre">ndt</span></tt> files are ascii files where each row corresponds to one time
step (or, more generally, configuration of the system). The columns
contain:</p>
<ul class="simple">
<li>metadata such as<ul>
<li>a unique identifier for every row</li>
<li>the time at which the row was written</li>
</ul>
</li>
<li>(spatially) averaged <a class="reference internal" href="manual.html#field"><em>field</em></a> data</li>
</ul>
<p>The first two lines contain information about what data is stored in the various columns:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The first line provides a header</li>
<li>The second line provides the SI units</li>
</ol>
</div></blockquote>
<p>All other lines contain the actual data.</p>
<p>The file can be loaded into any data processing software (such as MS
Excel, Origin, Matlab, Gnuplot, ...). However, often it is more
convenient to use the <a class="reference internal" href="manual.html#ncol"><em>ncol</em></a> tool to select the relevant columns, and
only to pass the filtered data to a post-processing (e.g. plotting)
program.</p>
<p>Data is written into the <tt class="docutils literal"><span class="pre">ndt</span></tt> file whenever the <a class="reference internal" href="manual.html#save-data"><em>save_data</em></a> method
of the simulation object is called.</p>
</div>
<div class="section" id="data-files-h5">
<span id="h5-data-files"></span><h3>Data files (<tt class="docutils literal"><span class="pre">.h5</span></tt>)<a class="headerlink" href="manual.html#data-files-h5" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">h5</span></tt> data files store spatially resolved <a class="reference internal" href="manual.html#field"><em>fields</em></a>. The format is
a binary and compressed <a class="reference external" href="http://www.hdfgroup.org/">hdf5</a> format to which we have convenient
access via the <a class="reference external" href="http://www.pytables.org/">pytables</a> package for Python. The user should not have
to worry about reading this file directly, but use the <a class="reference internal" href="manual.html#nmagpp"><em>nmagpp</em></a> tool to
access the data.</p>
</div>
<div class="section" id="file-names-for-data-files">
<span id="id4"></span><h3>File names for data files<a class="headerlink" href="manual.html#file-names-for-data-files" title="Permalink to this headline">¶</a></h3>
<p>The filenames for the <a class="reference internal" href="manual.html#ndt"><em>Data files (.ndt)</em></a> and <a class="reference internal" href="manual.html#h5-data-files"><em>Data files (.h5)</em></a> are given by
concatenation of the <em>simulation name</em>, the extension <tt class="docutils literal"><span class="pre">_dat.</span></tt> and
the extension (<tt class="docutils literal"><span class="pre">.h5</span></tt> or <tt class="docutils literal"><span class="pre">.ndt</span></tt>).</p>
<p>When a simulation object is created, for example in a file called
<tt class="docutils literal"><span class="pre">mybar.py</span></tt> starting like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;bar&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>then the simulation name is <tt class="docutils literal"><span class="pre">bar</span></tt>.</p>
<p>If no name is provided, i.e. the file <tt class="docutils literal"><span class="pre">mybar.py</span></tt> starts like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">()</span>
</pre></div>
</div>
<p>then the simulation name will be the <em>run id</em>. The <em>run id</em> is the
filename of the simulation script (without the <tt class="docutils literal"><span class="pre">.py</span></tt> extension),
i.e. the simulation name then will be <tt class="docutils literal"><span class="pre">mybar</span></tt>.</p>
<p>Let us assume for the rest of this section that the simulation name
is <tt class="docutils literal"><span class="pre">bar</span></tt>.  Once we use the <a class="reference internal" href="manual.html#save-data"><em>save_data</em></a> command, for example like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">save_data</span><span class="p">()</span>
</pre></div>
</div>
<p>an <tt class="docutils literal"><span class="pre">ndt</span></tt> file will be created, with name <tt class="docutils literal"><span class="pre">bar_dat.ndt</span></tt> (= <tt class="docutils literal"><span class="pre">bar</span></tt>
+ <tt class="docutils literal"><span class="pre">_dat.</span></tt> + <tt class="docutils literal"><span class="pre">ndt</span></tt>).</p>
<p>Similarly, if we write the fields spatially resolved:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>a <a class="reference internal" href="manual.html#h5-data-files"><em>h5 data file</em></a> with name <tt class="docutils literal"><span class="pre">bar_dat.h5</span></tt> (= <tt class="docutils literal"><span class="pre">bar</span></tt> + <tt class="docutils literal"><span class="pre">_dat.</span></tt> + <tt class="docutils literal"><span class="pre">h5</span></tt>)
will be created.</p>
</div>
<div class="section" id="file-names-for-log-files">
<span id="id5"></span><h3>File names for log files<a class="headerlink" href="manual.html#file-names-for-log-files" title="Permalink to this headline">¶</a></h3>
<p>A log file is created that stores (most of) the messages displayed to
stdout (i.e. the screen). The name of the log file starts with the
name of the simulation script (without the <tt class="docutils literal"><span class="pre">.py</span></tt> extension), and ends with <tt class="docutils literal"><span class="pre">_log.log</span></tt>.</p>
<p>For example, a simulation script with name <tt class="docutils literal"><span class="pre">mybar.py</span></tt> will have an
associated log file with name <tt class="docutils literal"><span class="pre">mybar_log.log</span></tt>.</p>
<p>Another three files will be created if the (undocumented)
<tt class="docutils literal"><span class="pre">--dumpconf</span></tt> switch is provided. This are primarily of use to the
developers and can usually be ignored:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">mybar_log.conf</span></tt>:
This can be used to configure what data is logged.</li>
<li><tt class="docutils literal"><span class="pre">mybar_ocaml.conf</span></tt>:
Configuration of some variables used in the ocaml code</li>
<li><tt class="docutils literal"><span class="pre">mybar_nmag.conf</span></tt>:
Some variables used in the nmag code</li>
</ul>
</div>
</div>
<span id="document-faq"></span><div class="section" id="frequently-asked-questions">
<span id="id1"></span><h2>Frequently Asked Questions<a class="headerlink" href="manual.html#frequently-asked-questions" title="Permalink to this headline">¶</a></h2>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="manual.html#what-is-the-difference-between-the-oommf-and-nmag-approach" id="id13">What is the difference between the OOMMF and nmag approach?</a></li>
<li><a class="reference internal" href="manual.html#so-this-means-the-major-difference-is-cubes-vs-tetrahedra" id="id14">... So, this means the major difference is &#8220;cubes&#8221; vs. &#8220;tetrahedra&#8221;?</a></li>
<li><a class="reference internal" href="manual.html#why-do-you-have-your-own-python-interpreter-nsim" id="id15">Why do you have your own Python interpreter (=<tt class="docutils literal"><span class="pre">nsim</span></tt>)?</a></li>
<li><a class="reference internal" href="manual.html#what-is-nsim-i-thought-the-package-is-called-nmag" id="id16">What is nsim - I thought the package is called nmag?</a></li>
<li><a class="reference internal" href="manual.html#how-fast-is-nmag-in-comparison-to-magpar" id="id17">How fast is nmag in comparison to magpar?</a></li>
<li><a class="reference internal" href="manual.html#how-do-i-start-a-time-consuming-nmag-run-in-the-background" id="id18">How do I start a time-consuming nmag run in the background?</a></li>
<li><a class="reference internal" href="manual.html#nmag-claims-to-support-mpi-so-can-i-run-simulation-jobs-on-multiple-processors" id="id19">nmag claims to support MPI. So, can I run simulation jobs on multiple processors?</a></li>
<li><a class="reference internal" href="manual.html#how-should-i-cite-nmag" id="id20">How should I cite nmag?</a></li>
<li><a class="reference internal" href="manual.html#why-can-you-not-use-the-step-as-a-unique-identifier" id="id21">Why can you not use the step as a unique identifier?</a></li>
<li><a class="reference internal" href="manual.html#how-to-generate-a-mesh-with-more-than-one-region-using-gmsh" id="id22">How to generate a mesh with more than one region using GMSH?</a></li>
<li><a class="reference internal" href="manual.html#can-i-run-more-than-one-simulation-in-one-directory" id="id23">Can I run more than one simulation in one directory?</a></li>
<li><a class="reference internal" href="manual.html#can-i-save-data-to-an-arbitrary-directory" id="id24">Can I save data to an arbitrary directory?</a><ul>
<li><a class="reference internal" href="manual.html#do-you-really-need-to-do-so" id="id25">Do you really need to do so?</a></li>
<li><a class="reference internal" href="manual.html#how-to-save-data-to-a-different-directory" id="id26">How to save data to a different directory</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#how-to-check-the-convergence-of-a-simulation" id="id27">How to check the convergence of a simulation</a></li>
<li><a class="reference internal" href="manual.html#what-to-do-in-case-of-convergence-problems" id="id28">What to do in case of convergence problems</a></li>
<li><a class="reference internal" href="manual.html#how-to-visualise-the-difference-between-two-fields-defined-over-the-same-mesh" id="id29">How to visualise the difference between two fields defined over the same mesh</a></li>
<li><a class="reference internal" href="manual.html#how-to-re-sample-data-from-a-saved-h5-file" id="id30">How to re-sample data from a saved h5 file</a></li>
<li><a class="reference internal" href="manual.html#notes-on-using-gmsh-to-create-a-family-of-related-meshes" id="id31">Notes on using GMSH to create a family of related meshes</a></li>
</ul>
</div>
<div class="section" id="what-is-the-difference-between-the-oommf-and-nmag-approach">
<span id="id2"></span><h3><a class="toc-backref" href="manual.html#id13">What is the difference between the OOMMF and nmag approach?</a><a class="headerlink" href="manual.html#what-is-the-difference-between-the-oommf-and-nmag-approach" title="Permalink to this headline">¶</a></h3>
<p>There are several aspects. One important point is the calculation of
the demagnetisation field as this is a computationally very expensive step.</p>
<p><a class="reference external" href="http://math.nist.gov/oommf/">OOMMF</a> is based on discretising space into small cuboids (often called
&#8216;finite differences&#8217;). One advantage of this method is that the demag
field can be computed very efficiently (via fast Fourier
transformation techniques). One disadvantage is that this methods
works less well (i.e. less accurately) if the geometry shape does not
align with a cartesian grid as the boundary then is represented as a
staircase pattern.</p>
<p>nmag&#8216;s finite elements discretise space into many small
tetrahedra. The corresponding approach towards the computation of the
demagnetisation field (which is the same as <a class="reference external" href="http://www.magpar.net/">Magpar</a>&#8216;s method) is based
on the Fredkin and Koehler Hybrid Finite Element/Boundary Element
method. The advantage of this method (over OOMMF&#8217;s approach) is that
curved and spherical geometries can be spatially resolved much more
accurately. However, this method of calculating the demagnetisation
field is less efficient than OOMMF&#8217;s approach for thin films. (In
particular: memory requirements for the boundary element method grow
as the square of the number of surface points.) Note that for
simulation of thin films, the hybrid Finite Element/Boundary Element
(as used by nmag and <a class="reference external" href="http://www.magpar.net/">Magpar</a>) is likely to require a lot of memory
(see <a class="reference internal" href="manual.html#memory-requirements-of-boundary-element-matrix"><em>Memory requirements of boundary element matrix</em></a>).</p>
<p>There are other points that are related to the fundamentally different
discretisation approach used to turn a field theory problem (with a
conceptually infinite number of degrees of freedom) into a finite
problem: OOMMF assumes the magnetisation in every cell to be constant
(with jumps at boundaries), while Nmag assumes magnetisation to be
continuous and vary linearly within cells (thus slightly violating the
constraint of constant magnitude within a cell of non-constant
magnetisation).</p>
</div>
<div class="section" id="so-this-means-the-major-difference-is-cubes-vs-tetrahedra">
<span id="id3"></span><h3><a class="toc-backref" href="manual.html#id14">... So, this means the major difference is &#8220;cubes&#8221; vs. &#8220;tetrahedra&#8221;?</a><a class="headerlink" href="manual.html#so-this-means-the-major-difference-is-cubes-vs-tetrahedra" title="Permalink to this headline">¶</a></h3>
<p>No. Simplicial mesh discretisation is fundamentally different from
finite-difference discretisation. With OOMMF, say, magnetisation
degrees of freedom are associated with the centers(!) of the cells,
while with nmag, they are associated with corners. This conceptual
difference has many implications, e.g. for the question how to
conceptually deal with the exchange interaction between different
materials.</p>
</div>
<div class="section" id="why-do-you-have-your-own-python-interpreter-nsim">
<span id="id4"></span><h3><a class="toc-backref" href="manual.html#id15">Why do you have your own Python interpreter (=<tt class="docutils literal"><span class="pre">nsim</span></tt>)?</a><a class="headerlink" href="manual.html#why-do-you-have-your-own-python-interpreter-nsim" title="Permalink to this headline">¶</a></h3>
<p>In order to provide the ability to run code in a distributed
environment (using MPI), we cannot use the standard Python
executable. (Technically speaking, a program started under MPI control
will receive extra MPI-related command line arguments which upset the
standard Python interpreter.) It so happens that &#8211; by providing our
own Python executable which is called <tt class="docutils literal"><span class="pre">nsim</span></tt> &#8211; we have easier
access to the low-level library of nsim which is written in
Objective Caml.</p>
</div>
<div class="section" id="what-is-nsim-i-thought-the-package-is-called-nmag">
<span id="id5"></span><h3><a class="toc-backref" href="manual.html#id16">What is nsim - I thought the package is called nmag?</a><a class="headerlink" href="manual.html#what-is-nsim-i-thought-the-package-is-called-nmag" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="manual.html#nsim-library"><em>The nsim library</em></a> is our general purpose multi-physics simulation
environment. The corresponding executable is started through the <a class="reference internal" href="manual.html#nsim"><em>nsim</em></a>
command. Nmag is a collection of scripts that provide micromagnetic
functionality on top of nsim. For this reason, nsim is being mentioned
a lot in the manual.</p>
</div>
<div class="section" id="how-fast-is-nmag-in-comparison-to-magpar">
<span id="id6"></span><h3><a class="toc-backref" href="manual.html#id17">How fast is nmag in comparison to magpar?</a><a class="headerlink" href="manual.html#how-fast-is-nmag-in-comparison-to-magpar" title="Permalink to this headline">¶</a></h3>
<p>Internally, some of the magpar and nmag core components are
structurally very similar. In particular, the time integration routine
is almost identical up to some philosophical issues such as how to
keep the length of the magnetisation vector constant, and whether or
not to use a symmetrical exchange matrix and a post-processing step
rather than combining these into an asymmetrical matrix, etc. The
actual wall clock time used will depend to a large degree on the
requested accuracy of the calculations (see <a class="reference internal" href="manual.html#example-tolerances"><em>example timestepper
tolerances</em></a>).</p>
<p>Given equivalent tolerance parameters, we have found (the
single-process version of) nmag to be about as fast as magpar. The
computation of an individual velocity dM/dt is very similar in nmag
and magpar, and about equally efficient. However, we observe that,
depending on the particular problem, subtle differences in the
philosophies underlying time integration can lead to noticeable
differences in the number of individual steps required to do some
particular simulation, which can be up to about 25% of simulation time
in either direction.</p>
<p>Setup time is a different issue: nmag derives its flexibility from
abstract approaches where magpar uses hard-coded compiled
functions. Where magpar uses a hand-coded Jacobian, nmag employs the
nsim core to symbolically compute the derivative of the equations of
motion. There is a trade-off: the flexibility of being able to
introduce another term into the equations of motion without having to
manually adjust the code for the Jacobian comes at a price in
execution time. Therefore, nmag&#8217;s setup time at present is far larger
than magpar&#8217;s. This can be alleviated to a considerable degree by
providing hard-coded &#8220;bypass routines&#8221; which can be used as
alternatives to the symbolically founded methods for special
situations that are frequently encountered (such as setting up a
Laplace operator matrix). Conceptually, it is easy to add support for
this but due to limited manpower, it has not happened yet.</p>
<p>In short: once the setup stage is over, nmag is about as fast as
magpar. Magpar&#8217;s setup time, however, is much smaller.
Magpar is also more efficient in memory usage.</p>
</div>
<div class="section" id="how-do-i-start-a-time-consuming-nmag-run-in-the-background">
<span id="id7"></span><h3><a class="toc-backref" href="manual.html#id18">How do I start a time-consuming nmag run in the background?</a><a class="headerlink" href="manual.html#how-do-i-start-a-time-consuming-nmag-run-in-the-background" title="Permalink to this headline">¶</a></h3>
<p>While this is a Unix rather than a nmag issue, it comes up
sufficiently often to address it here.</p>
<p>Well-known techniques to run programs in the background are:</p>
<blockquote>
<div><ul>
<li><p class="first">Using the &#8220;nohup&#8221; (no-hangup) command, as in:</p>
<div class="highlight-python"><pre>nohup nsim sphere1.py &amp;</pre>
</div>
</li>
<li><p class="first">Using the at-daemon for scheduling of command execution at
given times:</p>
<div class="highlight-python"><pre>at now
warning: commands will be executed using /bin/sh
at&gt; nsim example1.py
at&gt; &lt;EOT&gt;
job 2 at Fri Dec 14 12:08:00 2007</pre>
</div>
</li>
<li><p class="first">Manual daemonization by using a parent process which forks &amp; exits,
as in:</p>
<div class="highlight-python"><pre>perl -e 'exit(0) if fork(); exec "nsim sphere1.py"'</pre>
</div>
<p>(But if you know Unix to that degree, you presumably would
not have asked in the first place.)</p>
</li>
<li><p class="first">One of the most elegant ways to start a process in the background
is by using the &#8220;screen&#8221; utility, which is installed on a number of
Unix systems. With &#8220;screen&#8221;, it becomes possible to start a text
terminal session in such a way that one can &#8220;detach&#8221; from it while
keeping the session alive, and even log out and log in again much
later and from a different machine, re-attaching the terminal
session and continuing work from the point where it was left.</p>
<p>While it is a good idea to read the documentation, most basic usage of
&#8220;screen&#8221; requires the knowledge of three commands only:</p>
<blockquote>
<div><ul class="simple">
<li>With &#8220;screen -R&#8221;, one can re-attach to a running session,
automatically creating a new one if none was created before.</li>
<li>Within a &#8220;screen&#8221; session, Control+a is a prefix keyboard command
for controlling &#8220;screen&#8221;: Pressing Control-a and then Control-d
will detach the session.</li>
<li>Control-a ? will being up a help screen showing all &#8220;screen&#8221;
keyboard commands.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="nmag-claims-to-support-mpi-so-can-i-run-simulation-jobs-on-multiple-processors">
<span id="id8"></span><h3><a class="toc-backref" href="manual.html#id19">nmag claims to support MPI. So, can I run simulation jobs on multiple processors?</a><a class="headerlink" href="manual.html#nmag-claims-to-support-mpi-so-can-i-run-simulation-jobs-on-multiple-processors" title="Permalink to this headline">¶</a></h3>
<p>Yes. See <a class="reference internal" href="manual.html#example-parallel-execution-mpi"><em>Example: Parallel execution (MPI)</em></a>.</p>
</div>
<div class="section" id="how-should-i-cite-nmag">
<span id="id9"></span><h3><a class="toc-backref" href="manual.html#id20">How should I cite nmag?</a><a class="headerlink" href="manual.html#how-should-i-cite-nmag" title="Permalink to this headline">¶</a></h3>
<p>Please cite:</p>
<ul class="simple">
<li>Thomas Fischbacher, Matteo Franchin, Giuliano Bordignon, and Hans
Fangohr.  <em>A Systematic Approach to Multiphysics Extensions of
Finite-Element-Based Micromagnetic Simulations: Nmag</em>, in IEEE
Transactions on Magnetics, <strong>43</strong>, 6, 2896-2898 (2007). (Available <a class="reference external" href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4202717">online</a>)</li>
</ul>
</div>
<div class="section" id="why-can-you-not-use-the-step-as-a-unique-identifier">
<span id="id10"></span><h3><a class="toc-backref" href="manual.html#id21">Why can you not use the step as a unique identifier?</a><a class="headerlink" href="manual.html#why-can-you-not-use-the-step-as-a-unique-identifier" title="Permalink to this headline">¶</a></h3>
<p>There are two reasons. Firstly, nmag may be extended in future to
support effective energy minimisation in which case the <tt class="docutils literal"><span class="pre">step</span></tt>
becomes somewhat meaningless (although it could probably still be used
as an identifier if we identify minimisation iterations with
steps). Secondly (and more importantly), in nmag, the user can modify
the magnetisation directly using <a class="reference internal" href="manual.html#set-m"><em>set_m</em></a> (either scripted or
interactively). This will change the configuration of the system
without increasing the step counter of the time integrator. For this
reason, we have the <a class="reference internal" href="manual.html#unique-identifier-id"><em>unique identifier id</em></a>.</p>
</div>
<div class="section" id="how-to-generate-a-mesh-with-more-than-one-region-using-gmsh">
<span id="id11"></span><h3><a class="toc-backref" href="manual.html#id22">How to generate a mesh with more than one region using GMSH?</a><a class="headerlink" href="manual.html#how-to-generate-a-mesh-with-more-than-one-region-using-gmsh" title="Permalink to this headline">¶</a></h3>
<p>To assign different material properties to different objects, the mesher needs to assign different region number to different simplices of the mesh. The manual shows how to do this for netgen (see <a class="reference download internal" href="_downloads/two_cubes.geo"><tt class="xref download docutils literal"><span class="pre">two_cubes.geo</span></tt></a>) file in example <a class="reference internal" href="manual.html#example-two-different-magnetic-materials"><em>Example: two different magnetic materials</em></a>).</p>
<p>How does one define different regions using GMSH? User Xu Shu (Wuhan,
China) kindly provides this solution:</p>
<blockquote>
<div>Within GMSH, one has to firstly &#8220;add physical groups&#8221; and choose the
two detached volumes separately to add them into different groups,
then choose &#8220;edit&#8221; to redefine the number of the two groups, thus you
can get two physical objects as you want.</div></blockquote>
</div>
<div class="section" id="can-i-run-more-than-one-simulation-in-one-directory">
<span id="id12"></span><h3><a class="toc-backref" href="manual.html#id23">Can I run more than one simulation in one directory?</a><a class="headerlink" href="manual.html#can-i-run-more-than-one-simulation-in-one-directory" title="Permalink to this headline">¶</a></h3>
<p>If you want to run two (or more) simulations in the same directory,
then this is fine as well as long as they have different <em>simulation names</em>.</p>
<p>The simulation name is either the string given to the constructor of
the simulation object, or &#8211; if no name is defined explicitly &#8211; the
name of the python file that contains the simulation script (without
the <tt class="docutils literal"><span class="pre">.py</span></tt> extension). See <a class="reference internal" href="manual.html#file-names-for-data-files"><em>File names for data files</em></a> for a detailed
example for this.</p>
<p>Data and log files will all start with the simulation name, followed
by some specific appended string and specific file extensions. It is
thus safe to run simulations with different names in the same
directory.</p>
</div>
<div class="section" id="can-i-save-data-to-an-arbitrary-directory">
<h3><a class="toc-backref" href="manual.html#id24">Can I save data to an arbitrary directory?</a><a class="headerlink" href="manual.html#can-i-save-data-to-an-arbitrary-directory" title="Permalink to this headline">¶</a></h3>
<div class="section" id="do-you-really-need-to-do-so">
<h4><a class="toc-backref" href="manual.html#id25">Do you really need to do so?</a><a class="headerlink" href="manual.html#do-you-really-need-to-do-so" title="Permalink to this headline">¶</a></h4>
<p>First, consider whether you really need to save data in a different
directory. Remember that you can run many simulation with one single
script just using a different simulation name, like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="o">...</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="s">&#39;one&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="s">&#39;two&#39;</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>When you save the data for simulation <tt class="docutils literal"><span class="pre">one</span></tt> you get files like
<tt class="docutils literal"><span class="pre">one_dat.h5</span></tt> and <tt class="docutils literal"><span class="pre">one_dat.ndt</span></tt>, while when dealing with simulation <tt class="docutils literal"><span class="pre">two</span></tt> you get <tt class="docutils literal"><span class="pre">two_dat.h5</span></tt> and <tt class="docutils literal"><span class="pre">two_dat.nd5</span></tt>. There is no interference
between the two simulations (and in particular it is necessary to save thedata in different directories.)</p>
</div>
<div class="section" id="how-to-save-data-to-a-different-directory">
<h4><a class="toc-backref" href="manual.html#id26">How to save data to a different directory</a><a class="headerlink" href="manual.html#how-to-save-data-to-a-different-directory" title="Permalink to this headline">¶</a></h4>
<p>When you run a simulation script which saves data from a simulation,
the files are saved by default in the current working directory.  In
order to change this and save data into a directory called <tt class="docutils literal"><span class="pre">./mydir/</span></tt>
you should start your script in the following way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nmag</span>
<span class="kn">import</span> <span class="nn">nsim.features</span>
<span class="n">fts</span> <span class="o">=</span> <span class="n">nsim</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">Features</span><span class="p">()</span>
<span class="n">fts</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;etc&#39;</span><span class="p">,</span> <span class="s">&#39;savedir&#39;</span><span class="p">,</span> <span class="s">&#39;./mydir/&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Alternatively, you can change the current working directory at the
beginning of the file with ordinary Python code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">os</span>
<span class="n">initial_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">curdir</span><span class="p">)</span>
<span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="s">&#39;./mydir&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="o">...</span>
<span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">initial_dir</span><span class="p">)</span>
</pre></div>
</div>
<p>If the directory you want to write to does not exist then (in both the
two example) you may have to create it first, with something like:</p>
<blockquote>
<div><p>the_dir = &#8216;./mydir&#8217;
import os
if not os.path.exists(the_dir):</p>
<blockquote>
<div>os.mkdir(the_dir)</div></blockquote>
</div></blockquote>
</div>
</div>
<div class="section" id="how-to-check-the-convergence-of-a-simulation">
<h3><a class="toc-backref" href="manual.html#id27">How to check the convergence of a simulation</a><a class="headerlink" href="manual.html#how-to-check-the-convergence-of-a-simulation" title="Permalink to this headline">¶</a></h3>
<p>How long it takes to run a simulation? This depends very much on what
you are simulating and under what conditions (applied field, current,
etc). Sometimes, however, your simulation may not be ending as quickly as
you expected and you may want to check what is happening. It may be,
indeed, that the simulation is not converging, which means that it may
actually never end. One thing you can do in such a case is to take a
look at the file <tt class="docutils literal"><span class="pre">*_progress.txt</span></tt>, where <tt class="docutils literal"><span class="pre">*</span></tt> stands for the simulation
name (given to the <tt class="docutils literal"><span class="pre">Simulation</span></tt> class when creating the simulation
oject). For example, if you created your simulation object with a line
such as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">s</span> <span class="o">=</span> <span class="n">nmag</span><span class="o">.</span><span class="n">Simulation</span><span class="p">(</span><span class="s">&#39;one&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Then you may be looking for a file with name <tt class="docutils literal"><span class="pre">one_progress.txt</span></tt>. If
you used simply <tt class="docutils literal"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">nmag.Simulation()</span></tt> and your file is named
<tt class="docutils literal"><span class="pre">two.py</span></tt> then you should look for a file with name
<tt class="docutils literal"><span class="pre">two_progress.txt</span></tt>. This file contains statistics about the time
integrator. You&#8217;ll first get the current time, step number, etc. Then
you&#8217;ll get a list of rows each containing four columns, such as:</p>
<div class="highlight-python"><pre>123 0.456 0.123 None</pre>
</div>
<p>Column 1 is the step reached, an integer number which always
increases. The file shows convergence statistics for the last few
steps (it doesn&#8217;t contain statistics for all the steps, since this
would make it quickly very big). Column 2 contains the current value
of max || dM/dt ||. Column 3 contains the stopping value of
dM/dt. Convergence is reached when column 2 &lt; column 3 for at least
two times. If the simulations is going well, then you should see that
column 2 contains numbers which are not oscillating rapidly and are
rather decreasing or increasing &#8220;smoothly&#8221;. This is what typically
should happen, even if it can be that your simulation has really a
bizarre dynamics which really oscillates in a frenetic way, so one
should be careful when analysing the data. The fourth column contains
an evaluation of the quality of the convergence according to what we
just said. This number should be close to one when the convergence is
smooth and close to zero when it is oscillating dramatically.</p>
</div>
<div class="section" id="what-to-do-in-case-of-convergence-problems">
<h3><a class="toc-backref" href="manual.html#id28">What to do in case of convergence problems</a><a class="headerlink" href="manual.html#what-to-do-in-case-of-convergence-problems" title="Permalink to this headline">¶</a></h3>
<p>If your simulation has really a convergence problem, you can do two
things:</p>
<ul class="simple">
<li>improve the tolerances <tt class="docutils literal"><span class="pre">ts_abs_err</span></tt> and <tt class="docutils literal"><span class="pre">ts_rel_err</span></tt>
(decrease these numbers) by using the method <tt class="docutils literal"><span class="pre">set_params</span></tt> of the
<tt class="docutils literal"><span class="pre">Simulation</span></tt> object;</li>
<li>use a <tt class="docutils literal"><span class="pre">do=[('next_stage',</span> <span class="pre">at('stage_time',SI(x,</span> <span class="pre">'s')))]</span></tt> as an
argument to the <tt class="docutils literal"><span class="pre">hysteresis</span></tt> method. This way
you impose a maximum time <tt class="docutils literal"><span class="pre">x</span></tt> to spend in the computation of a stage
(you should make sure this makes sense in your case).</li>
</ul>
</div>
<div class="section" id="how-to-visualise-the-difference-between-two-fields-defined-over-the-same-mesh">
<h3><a class="toc-backref" href="manual.html#id29">How to visualise the difference between two fields defined over the same mesh</a><a class="headerlink" href="manual.html#how-to-visualise-the-difference-between-two-fields-defined-over-the-same-mesh" title="Permalink to this headline">¶</a></h3>
<p>First save the data into two <strong>ASCII</strong> VTK files. For example:</p>
<div class="highlight-python"><pre>nmagpp --vtk=m.vtk --vtkascii --fields=m simulation_name</pre>
</div>
<p>Note the option <tt class="docutils literal"><span class="pre">&quot;--vtkascii&quot;</span></tt> to force the creation of a ASCII file.
Let&#8217;s say this command created the two files <tt class="docutils literal"><span class="pre">m-000000.vtk</span></tt> and <tt class="docutils literal"><span class="pre">m-000001.vtk</span></tt>.
You can now use the library <tt class="docutils literal"><span class="pre">pyvtk</span></tt> to load the two files, compute the difference and save it back to a third file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span><span class="o">,</span> <span class="nn">pyvtk</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">pyvtk</span><span class="o">.</span><span class="n">VtkData</span><span class="p">(</span><span class="s">&quot;m-000000.vtk&quot;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">pyvtk</span><span class="o">.</span><span class="n">VtkData</span><span class="p">(</span><span class="s">&quot;m-000001.vtk&quot;</span><span class="p">)</span>
<span class="n">va</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vectors</span>
<span class="n">vb</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vectors</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">va</span><span class="p">)):</span>
    <span class="n">va</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">va</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vb</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
<span class="n">a</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="s">&quot;difference.vtk&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Save this text to a file named <tt class="docutils literal"><span class="pre">diff.py</span></tt> and run it as:</p>
<div class="highlight-python"><pre>python diff.py</pre>
</div>
<p>You&#8217;ll get a third file with name <tt class="docutils literal"><span class="pre">difference.vtk</span></tt> containing the difference of the two fields.</p>
<p>If you are repeating this operation many times, it may become annoying to open again and again the <tt class="docutils literal"><span class="pre">diff.py</span></tt> file to change the names of the input files. You can then modify the script as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">numpy</span><span class="o">,</span> <span class="nn">pyvtk</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">pyvtk</span><span class="o">.</span><span class="n">VtkData</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">pyvtk</span><span class="o">.</span><span class="n">VtkData</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">va</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vectors</span>
<span class="n">vb</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vectors</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">va</span><span class="p">)):</span>
    <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">va</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">va</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vb</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
<span class="n">a</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>The name of the files are taken from the command line. You can then compute the difference using:</p>
<div class="highlight-python"><pre>python diff.py a.vtk b.vtk a_minus_b.vtk</pre>
</div>
<p>Notice that in the last version of the script we also added the line:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>which does just check that the two files are using the same set of points (i.e. the same mesh).</p>
</div>
<div class="section" id="how-to-re-sample-data-from-a-saved-h5-file">
<h3><a class="toc-backref" href="manual.html#id30">How to re-sample data from a saved h5 file</a><a class="headerlink" href="manual.html#how-to-re-sample-data-from-a-saved-h5-file" title="Permalink to this headline">¶</a></h3>
<p>(Available in Nmag-0.2.0)</p>
<p>You can load an h5 file like this</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">ocaml</span>
<span class="kn">from</span> <span class="nn">nmag.h5probe</span> <span class="kn">import</span> <span class="n">Fields</span>
<span class="n">handler</span> <span class="o">=</span> <span class="n">Fields</span><span class="p">(</span><span class="s">&quot;infile.h5&quot;</span><span class="p">)</span>
<span class="n">field</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="n">set_field_data</span><span class="p">(</span><span class="s">&quot;m&quot;</span><span class="p">,</span> <span class="s">&quot;Py&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>And probe one of its fields:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="c"># In mesh units (typically is nanometres)</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">ocaml</span><span class="o">.</span><span class="n">probe_field</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="s">&quot;m_Py&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>This way you can create two arrays: <tt class="docutils literal"><span class="pre">rs</span></tt> containing an array of points and <tt class="docutils literal"><span class="pre">vs</span></tt> containing the corresponding values.
You can then use pyvtk to generate a VTK file from these:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pyvtk</span>

<span class="n">grid</span> <span class="o">=</span> <span class="n">pyvtk</span><span class="o">.</span><span class="n">UnstructuredGrid</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pyvtk</span><span class="o">.</span><span class="n">PointData</span><span class="p">(</span><span class="n">pyvtk</span><span class="o">.</span><span class="n">Vectors</span><span class="p">(</span><span class="n">vs</span><span class="p">))</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">pyvtk</span><span class="o">.</span><span class="n">VtkData</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="n">v</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="s">&quot;outfile.vtk&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is a full example, which probes the magnetisation in the outer skin of a cylinder, in sections which are not equally spaced.
Notice the usage of the function <tt class="docutils literal"><span class="pre">float_set</span></tt> to specify where the sampling should be denser (originally, here is where a domain wall was).
The script should be used as <tt class="docutils literal"><span class="pre">nsim</span> <span class="pre">probe.py</span> <span class="pre">infile.h5</span> <span class="pre">outfile.vtk</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">pyvtk</span>

<span class="kn">import</span> <span class="nn">ocaml</span>
<span class="kn">from</span> <span class="nn">nmag.h5probe</span> <span class="kn">import</span> <span class="n">Fields</span>
<span class="kn">from</span> <span class="nn">nmag</span> <span class="kn">import</span> <span class="n">float_set</span>

<span class="c"># First we probe the field in the required points</span>
<span class="n">handler</span> <span class="o">=</span> <span class="n">Fields</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">field</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="n">set_field_data</span><span class="p">(</span><span class="s">&quot;m&quot;</span><span class="p">,</span> <span class="s">&quot;Py&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">xs</span> <span class="o">=</span> <span class="n">float_set</span><span class="p">([</span><span class="o">-</span><span class="mf">150.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">145.0</span><span class="p">,</span> <span class="p">[],</span> <span class="o">-</span><span class="mf">15.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">12.5</span><span class="p">,</span> <span class="p">[],</span> <span class="mf">15.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="p">[],</span> <span class="mf">50.0</span><span class="p">])</span>
<span class="n">angles</span> <span class="o">=</span> <span class="n">float_set</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">20</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">])</span>
<span class="n">R</span><span class="p">,</span> <span class="n">R2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.9</span><span class="p">,</span> <span class="mf">5.1</span><span class="p">)</span>

<span class="n">rs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">vs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">:</span>
  <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">angles</span><span class="p">:</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">R</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)]</span>
    <span class="n">rs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">R2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">R2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)])</span>
    <span class="n">vs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ocaml</span><span class="o">.</span><span class="n">probe_field</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="s">&quot;m_Py&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

<span class="c"># Now we output the values to a VTK file</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">pyvtk</span><span class="o">.</span><span class="n">UnstructuredGrid</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pyvtk</span><span class="o">.</span><span class="n">PointData</span><span class="p">(</span><span class="n">pyvtk</span><span class="o">.</span><span class="n">Vectors</span><span class="p">(</span><span class="n">vs</span><span class="p">))</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">pyvtk</span><span class="o">.</span><span class="n">VtkData</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="n">v</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="notes-on-using-gmsh-to-create-a-family-of-related-meshes">
<h3><a class="toc-backref" href="manual.html#id31">Notes on using GMSH to create a family of related meshes</a><a class="headerlink" href="manual.html#notes-on-using-gmsh-to-create-a-family-of-related-meshes" title="Permalink to this headline">¶</a></h3>
<p>If you want to create many meshes using Gmsh, you may first generate a
mesh manually.  Then you can create a Python script which uses this
mesh as a template to quickly create a mesh for a different set of
parameters.  Below is such a script which shows how to do so. The mesh
file (geo) has been enclosed between quotes <tt class="docutils literal"><span class="pre">&quot;&quot;&quot;</span></tt> and some of the
values for the points coordinates have been substituted with strings
that the Python script substitutes with real values.</p>
<p>Note that we use <tt class="docutils literal"><span class="pre">Mesh.CharacteristicLengthFactor</span> <span class="pre">=</span> <span class="pre">5.0;</span></tt> to control
the discretisation of the mesh. We also use <tt class="docutils literal"><span class="pre">Physical</span> <span class="pre">Volume(1)</span> <span class="pre">=</span>
<span class="pre">{1};</span></tt> to make sure that the mesh region is labeled starting from
region number 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mesh</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">cl1 = 1;</span>
<span class="s">Point(1) = {$x2$, 0, 0, cl1};</span>
<span class="s">Point(2) = {$x2$, $x2$, 0, cl1};</span>
<span class="s">Point(3) = {0, $x2$, 0, cl1};</span>
<span class="s">Point(4) = {0, $x1$, 0, cl1};</span>
<span class="s">Point(5) = {$x1$, 0, 0, cl1};</span>
<span class="s">Point(6) = {$x0$, $x0$, 0, cl1};</span>
<span class="s">Point(7) = {$x0$, $x1$, 0, cl1};</span>
<span class="s">Point(8) = {$x1$, $x0$, 0, cl1};</span>
<span class="s">Point(9) = {$x2$, 0, $y1$, cl1};</span>
<span class="s">Point(10) = {$x1$, 0, $y1$, cl1};</span>
<span class="s">Point(14) = {$x1$, $x0$, $y1$, cl1};</span>
<span class="s">Point(18) = {$x0$, $x0$, $y1$, cl1};</span>
<span class="s">Point(19) = {$x0$, $x1$, $y1$, cl1};</span>
<span class="s">Point(23) = {0, $x1$, $y1$, cl1};</span>
<span class="s">Point(27) = {0, $x2$, $y1$, cl1};</span>
<span class="s">Point(31) = {$x2$, $x2$, $y1$, cl1};</span>
<span class="s">Line(1) = {1, 5};</span>
<span class="s">Line(2) = {5, 8};</span>
<span class="s">Circle(3) = {8, 6, 7};</span>
<span class="s">Line(4) = {7, 4};</span>
<span class="s">Line(5) = {4, 3};</span>
<span class="s">Line(6) = {3, 2};</span>
<span class="s">Line(7) = {2, 1};</span>
<span class="s">Line(11) = {9, 10};</span>
<span class="s">Line(12) = {10, 14};</span>
<span class="s">Circle(13) = {14, 18, 19};</span>
<span class="s">Line(14) = {19, 23};</span>
<span class="s">Line(15) = {23, 27};</span>
<span class="s">Line(16) = {27, 31};</span>
<span class="s">Line(17) = {31, 9};</span>
<span class="s">Line(19) = {1, 9};</span>
<span class="s">Line(20) = {5, 10};</span>
<span class="s">Line(24) = {8, 14};</span>
<span class="s">Line(28) = {7, 19};</span>
<span class="s">Line(32) = {4, 23};</span>
<span class="s">Line(36) = {3, 27};</span>
<span class="s">Line(40) = {2, 31};</span>
<span class="s">Line Loop(9) = {1, 2, 3, 4, 5, 6, 7};</span>
<span class="s">Plane Surface(9) = {9};</span>
<span class="s">Line Loop(21) = {1, 20, -11, -19};</span>
<span class="s">Ruled Surface(21) = {21};</span>
<span class="s">Line Loop(25) = {2, 24, -12, -20};</span>
<span class="s">Ruled Surface(25) = {25};</span>
<span class="s">Line Loop(29) = {3, 28, -13, -24};</span>
<span class="s">Ruled Surface(29) = {29};</span>
<span class="s">Line Loop(33) = {4, 32, -14, -28};</span>
<span class="s">Ruled Surface(33) = {33};</span>
<span class="s">Line Loop(37) = {5, 36, -15, -32};</span>
<span class="s">Ruled Surface(37) = {37};</span>
<span class="s">Line Loop(41) = {6, 40, -16, -36};</span>
<span class="s">Ruled Surface(41) = {41};</span>
<span class="s">Line Loop(45) = {7, 19, -17, -40};</span>
<span class="s">Ruled Surface(45) = {45};</span>
<span class="s">Line Loop(46) = {11, 12, 13, 14, 15, 16, 17};</span>
<span class="s">Plane Surface(46) = {46};</span>
<span class="s">Surface Loop(1) = {9, 46, 21, 25, 29, 33, 37, 41, 45};</span>

<span class="s">Volume(1) = {1};</span>

<span class="s">Physical Volume(1) = {1};</span>

<span class="s">Mesh.CharacteristicLengthFactor = $discret$;</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">create_mesh</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span>
                <span class="n">inner_size</span><span class="o">=</span><span class="mf">100.0</span><span class="p">,</span>
                <span class="n">curvature</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span>
                <span class="n">width</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
                <span class="n">thickness</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span>
                <span class="n">discretisation</span><span class="o">=</span><span class="mf">2.5</span><span class="p">):</span>
  <span class="k">global</span> <span class="n">mesh</span>
  <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">inner_size</span>
  <span class="n">variables</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;x0&quot;</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">curvature</span><span class="p">),</span>
               <span class="p">(</span><span class="s">&quot;x1&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
               <span class="p">(</span><span class="s">&quot;x2&quot;</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">width</span><span class="p">),</span>
               <span class="p">(</span><span class="s">&quot;y1&quot;</span><span class="p">,</span> <span class="n">thickness</span><span class="p">),</span>
               <span class="p">(</span><span class="s">&quot;discret&quot;</span><span class="p">,</span> <span class="n">discretisation</span><span class="p">)]</span>
  <span class="k">for</span> <span class="n">variable_name</span><span class="p">,</span> <span class="n">variable_value</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;$</span><span class="si">%s</span><span class="s">$&quot;</span> <span class="o">%</span> <span class="n">variable_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">variable_value</span><span class="p">))</span>

  <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span>
  <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
  <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="n">create_mesh</span><span class="p">(</span><span class="s">&quot;dots.geo&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<span id="document-useful_tools"></span><div class="section" id="useful-tools">
<span id="id1"></span><h2>Useful tools<a class="headerlink" href="manual.html#useful-tools" title="Permalink to this headline">¶</a></h2>
<div class="section" id="vtk">
<span id="id2"></span><h3>vtk<a class="headerlink" href="manual.html#vtk" title="Permalink to this headline">¶</a></h3>
<p>The homepage of the Visualisation ToolKit (vtk) is
<a class="reference external" href="http://www.vtk.org">http://www.vtk.org</a>. VTK provides is is an open source, freely
available software system for 3D computer graphics, image processing,
and visualization. It also provides a file-format which is called
&#8216;vtk&#8217;. A number of high-level user interfaces exist to visualise data
provided in such vtk files. These include:</p>
<ul class="simple">
<li><a class="reference internal" href="manual.html#mayavi"><em>MayaVi</em></a> (<a class="reference external" href="http://mayavi.sourceforge.net/">http://mayavi.sourceforge.net/</a>)</li>
<li>VisIt (<a class="reference external" href="http://www.llnl.gov/visit/">http://www.llnl.gov/visit/</a>)</li>
<li>ParaView (<a class="reference external" href="http://www.paraview.org/">http://www.paraview.org/</a>)</li>
</ul>
</div>
<div class="section" id="mayavi">
<span id="id3"></span><h3>MayaVi<a class="headerlink" href="manual.html#mayavi" title="Permalink to this headline">¶</a></h3>
<p>&#8220;MayaVi is a free, easy to use scientific data visualizer. It is
written in Python and uses the Visualization Toolkit (VTK) for
graphical rendering. MayaVi is free and distributed under the
conditions of the BSD license. It is also cross platform and should
run on any platform where both Python and VTK are available (which is
almost any Unix, Mac OSX or Windows).&#8221; The MayaVi web page is
<a class="reference external" href="http://mayavi.sourceforge.net/">http://mayavi.sourceforge.net/</a>.</p>
<p>MayaVi has been used to generate many of the plots in this manual.
Other tools are available for visualisation of vtk files (see <a class="reference internal" href="manual.html#vtk"><em>vtk</em></a>).</p>
</div>
<div class="section" id="numpy">
<span id="id4"></span><h3>NumPy<a class="headerlink" href="manual.html#numpy" title="Permalink to this headline">¶</a></h3>
<p>Numerical Python (short <em>numpy</em>) is an extension library to Python
that provides fast array operations and is designed for numerical
work. This Python extension and documentation can be found at
<a class="reference external" href="http://numpy.scipy.org/">http://numpy.scipy.org/</a></p>
</div>
</div>
<span id="document-contact"></span><div class="section" id="contact">
<span id="id1"></span><h2>Contact<a class="headerlink" href="manual.html#contact" title="Permalink to this headline">¶</a></h2>
<p>The nmag developer team can be contacted at
<tt class="docutils literal"><span class="pre">nmag&#64;soton.ac.uk</span></tt>.</p>
<p>Questions about the usage of nmag can also be send to the <a class="reference internal" href="manual.html#nmag-users"><em>nmag-users</em></a> mailing list.</p>
</div>
<span id="document-tutorial/doc"></span><div class="section" id="mini-tutorial-micromagnetic-modelling">
<span id="id1"></span><h2>Mini tutorial micromagnetic modelling<a class="headerlink" href="manual.html#mini-tutorial-micromagnetic-modelling" title="Permalink to this headline">¶</a></h2>
<p>This section is intended for researchers who are just beginning to
explore micromagnetic modelling. It is assumed that you have some
knowledge on micromagnetics. We advise to read this whole section, and
then to look the <a class="reference internal" href="manual.html#guided-tour"><em>Guided Tour</em></a> examples (or to explore other
<a class="reference internal" href="manual.html#micromagnetic-packages"><em>Micromagnetic packages</em></a> at that point).</p>
<div class="section" id="introduction-micromagnetic-modelling">
<span id="id2"></span><h3>Introduction micromagnetic modelling<a class="headerlink" href="manual.html#introduction-micromagnetic-modelling" title="Permalink to this headline">¶</a></h3>
<p>To carry out micromagnetic simulations, a set of partial differential
equations have to be solved repeatedly. In order to be able to do
this, the simulated geometry has to be spatially discretised. The two
methods that are most widely spread in micromagnetic modelling are the
so-called finite difference (FD) method and the finite element (FE)
method. With either the FD or the FE method, we need to integrate the
Landau-Lifshitz and Gilbert equation numerically over time (this is a
coupled set of ordinary differential equations). All these
calculations are carried out by the <a class="reference internal" href="manual.html#micromagnetic-packages"><em>Micromagnetic packages</em></a> and the
user does not have to worry about these.</p>
<p>The finite difference method subdivides space into many small
cuboids. Sometimes the name <em>cell</em> is used to describe one of these
cuboids. (Warning: in finite difference simulations, the simulated
geometry is typically enclosed by a (big) cuboid which is also
referred to as <em>simulation cell</em>. Usually (!) it is clear from the
context which is meant.)  Typically, all simulation cells in one
finite difference simulation have the same geometry. A typical size
for such a cell could be a cube of dimensions 3nm by 3nm by 3nm.</p>
<p>Let&#8217;s assume we would like to simulate a sphere. The following picture</p>
<img alt="_images/fd.png" class="align-center" src="_images/fd.png" style="width: 200px; height: 180px;" />
<p>shows an approximation of the shape of the sphere by cubes. This is
the finite difference approach. For clarity, we have chosen rather
large cubes to resolve the sphere &#8211; in an actual simulation one would
typically use a much smaller cell size in order to resolve geometry
better.</p>
<p>On the other hand, the finite element method (typically) subdivides
space into many small tetrahedra. The tetrahedra are sometimes
referred to as the (finite element) mesh elements. Typically, the
geometry of these tetrahedra does vary throughout the simulated
region. This allows to combine the tetrahedra to approximate
complicated geometries.</p>
<p>Using tetrahedra, the a discretised sphere looks like this:</p>
<img alt="_images/fe.png" class="align-center" src="_images/fe.png" style="width: 200px; height: 186px;" />
<p>The spherical shape is approximated better than with the finite
differences.</p>
<p>The first step in setting up a micromagnetic simulation is to describe
the geometry. In the case of finite difference calculations, it will
depend on the package you use (currently there is only <a class="reference external" href="http://math.nist.gov/oommf/">OOMMF</a> freely
available) how to tell the package what geometry you would like to
use, and how small your simulation cells should be.</p>
<p>In the case of finite element calculations, you need to create a
finite element mesh (see <a class="reference internal" href="manual.html#finite-element-mesh-generation"><em>Finite element mesh generation</em></a>).</p>
</div>
<div class="section" id="what-is-better-finite-differences-or-finite-elements">
<span id="id3"></span><h3>What is better: finite differences or finite elements?<a class="headerlink" href="manual.html#what-is-better-finite-differences-or-finite-elements" title="Permalink to this headline">¶</a></h3>
<p>This depends on what you want to simulate. Here are some points to consider.</p>
<ul>
<li><p class="first">Finite difference simulations are best when the geometry you
simulate is of rectangular shape (i.e. a cube, a beam, a geometry
composed of such objects, a T profile, etc). In these situations,
the finite element discretisation of the geometry will not yield any
advantage. (Assuming that the finite difference grid is aligned with
the edges in the geometry.)</p>
</li>
<li><p class="first">Finite difference simulations need generally less computer memory
(RAM). This is in particular the case if you simulate geometries
with a big surface (such as thin films). See <a class="reference internal" href="manual.html#memory-requirements-of-boundary-element-matrix"><em>Memory requirements of boundary element matrix</em></a> for a description of the memory
requirements of the hybrid finite element/boundary element simulations (both
Nmag and <a class="reference external" href="http://www.magpar.net/">Magpar</a> are in this category).</p>
<p>If this turns out to be a problem for you, we suggest to read the section
<a class="reference internal" href="manual.html#compression-of-the-boundary-element-matrix-using-hlib"><em>Compression of the Boundary Element Matrix using HLib</em></a>.</p>
</li>
<li><p class="first">Finite element simulations are best suited to describe geometries
with some amount of curvature, or angles other than 90 degrees. For
such simulations, there is an error associated with the staircase
discretisation that finite difference approaches have to use. This
error is very much reduced when using finite elements.</p>
<p>(We state for completeness that there are techniques to reduce the
staircase effect in finite difference simulations but these are
currently not available in open source micromagnetic simulation
code.)</p>
</li>
<li><p class="first">For finite element simulations, the user has to create a finite
element mesh. This requires some practice (mostly to get used to a
meshing package), and in practice will take a significant amount of
the time required to set up a finite element simulation.</p>
</li>
</ul>
</div>
<div class="section" id="what-size-of-the-cells-fd-and-tetrahedra-fe-should-i-choose">
<span id="id4"></span><h3>What size of the cells (FD) and tetrahedra (FE) should I choose?<a class="headerlink" href="manual.html#what-size-of-the-cells-fd-and-tetrahedra-fe-should-i-choose" title="Permalink to this headline">¶</a></h3>
<p>There are several things to consider:</p>
<ul class="simple">
<li>the smaller the cells or tetrahedra, the more accurate the
simulation results.</li>
<li>the smaller the cells or tetrahedra, the more cells and tetrahedra
are required to describe a geometry. Memory requirements and
execution time increase with the number of cells and tetrahedra. In
practice this will limit the size of the system that can be
simulated.</li>
</ul>
<ul>
<li><p class="first">the discretisation length (this is the edge length of the cells or
the tetrahedra) should be <em>much smaller than the exchange
length</em>. The reason for this is that in the derivation of the
micromagnetic (Brown&#8217;s) equations, one assumes that the
magnetisation changes little in space (there is a Taylor expansion
for the exchange interaction). Therefore, we need to choose a
discretisation length so that the direction of the magnetisation
vectors varies little from one site (cell center in FD, node of
tetrahedron in FE) to the next. The difference of the magnetisation
vector is sometimes referred to as the &#8216;spin angle&#8217;: a spin angle of
0 degrees, means that the magnetisation at neighbouring sites points
in the same direction, whereas a spin angle of 180 degrees would mean
that they point in exactly opposite directions.</p>
<p>How much variation is acceptable, i.e. how big is the spin angle
allowed to be? It depends on the accuracy required. Some general
guidelines from M. Donahue [in email to H. Fangohr on 26 March
2002 referring to OOMMF] which we fully endorse :</p>
<p><tt class="docutils literal"><span class="pre">[Begin</span> <span class="pre">quote</span> <span class="pre">M.</span> <span class="pre">Donahue]</span></tt></p>
<ul class="simple">
<li>if the spin angle is approaching 180 degrees, then the results are
completely bogus.</li>
<li>over 90 degrees the results are highly questionable.</li>
<li>Under 30 degrees the results are probably reliable.</li>
</ul>
<p><tt class="docutils literal"><span class="pre">[end</span> <span class="pre">quote]</span></tt></p>
<p>It is <em>absolutely vital</em> that the spin angle does not become
excessive if the simulation results are to be trusted. (It is
probably the most common error in micromagnetics: one would like to
simulate a large geometry, thus one has to choose the discretisation
length large to get any results within reasonable time. However, the
results are often completely useless if the spin angle becomes too
large).</p>
<p>Because this is such an important issue, OOMMF &#8211; for example &#8211;
provides <tt class="docutils literal"><span class="pre">Max</span> <span class="pre">Spin</span> <span class="pre">Ang</span></tt> data in its <tt class="docutils literal"><span class="pre">odt</span></tt> data table file (for
the current configuration, the last stage, and the overall
run). Nmag has a columns <tt class="docutils literal"><span class="pre">maxangle_m_X</span></tt> in the <a class="reference internal" href="manual.html#ndt"><em>Data files (.ndt)</em></a> file that
provide this information (where <tt class="docutils literal"><span class="pre">X</span></tt> is the name of the magnetic
material).</p>
<p>You will probably find that often a discretisation length of half
the <a class="reference internal" href="manual.html#exchange-length"><em>Exchange length</em></a> or even about the <a class="reference internal" href="manual.html#exchange-length"><em>Exchange length</em></a> is
chosen. If the spin angle stays sufficiently low during the whole
simulation (including intermediate non-equilibrium configurations),
then this may be acceptable.</p>
<p>The ultimate test (recommended by &#8211; among others &#8211; M. Donahue and the
nmag team) is the following:</p>
</li>
<li><p class="first">cell size dependence test</p>
<p>The best way to check whether the cell size has been chosen small
enough, is to perform a series of simulations with increasing cell
size. Suppose we are simulating Permalloy (Ni80Fe20 with Ms=8e5 A/m,
A=1.3e-11) and the <a class="reference internal" href="manual.html#exchange-length"><em>Exchange length</em></a> l<sub>1</sub> is about 5nm. Suppose further
we would like to use a cell size of 5nm for our simulations.</p>
<p>We should then carry out the same simulation with smaller cell
sizes, for example, 4nm, 3nm, 2nm, 1nm. Now we need to study
(typically plot) some (scalar) entity of the simulation (such as
the coercive field, or the remanence magnetisation) as a function of
the cell size.</p>
<p>Ideally, this entity should converge towards a constant value when
we reduce the simulation cell size below a critical cell size. This
critical cell size is the maximum cell size that should be used to
carry out the simulations.</p>
<p>Be aware that (i) it is often nearly impossible to carry out these
simulations at smaller cell sizes [because of a lack of
computational power] and (ii) this method is not 100% fool proof
[the observed entity may appear to converge towards a constant but
actually start changing again if the cell size is reduced even
further].</p>
<p>One should therefore treat the suggestions made above as advise on
good practice, but never solely rely on this. Critical examination
of the validity of simulation results is a fundamental part of any
simulation work.</p>
</li>
</ul>
<p>In summary, it is vital to keep the maximum spin angle small to obtain
accurate results. One should always (!) check the value of the spin
angle in the data files. One should also carry out a series of
simulations where the spin angle is reduced from one simulation to the
next while keeping all other parameters and the geometry the
same. This should reveal any changes in the results that depend on the
discretisation length.</p>
<div class="section" id="exchange-length">
<span id="id5"></span><h4>Exchange length<a class="headerlink" href="manual.html#exchange-length" title="Permalink to this headline">¶</a></h4>
<p>There is sometimes confusion about what equation should be used to
compute the exchange length. In this document, we refer to this
equation for soft materials (where the demagnetisation energy is
driving domain wall formation)</p>
<div class="math">
<p><img src="_images/math/c37f718c6a2eacb2fe536e432165a068206ac236.png" alt="l_\mathrm{1} = \sqrt{\frac{2A}{\mu_0 M^2_\mathrm{s}}}" /></p>
</div><p>and this equation for hard materials (with uniaxial pinning) where the
crystal anisotropy governs domain wall lengths</p>
<div class="math">
<p><img src="_images/math/073c279e5444ee9e1c6864e26c9eeae78c2f18ab.png" alt="l_2 = \sqrt{\frac{A}{K_1}}" /></p>
</div><p>If in doubt which of the two equations is the right one, compute both
l<sub>1</sub> and l<sub>2</sub> and choose the minimum length as the relevant exchange
length for this system.</p>
</div>
<div class="section" id="further-reading">
<span id="id6"></span><h4>Further reading<a class="headerlink" href="manual.html#further-reading" title="Permalink to this headline">¶</a></h4>
<p>Micheal Donahue and co-workers have published a couple of papers on
the effect of cell size on vortex mobility:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://math.nist.gov/~MDonahue/publications.html#Donahue199606A">M. J. Donahue and R. D. McMichael, Physica B, 233, 272-278 (1997)</a></li>
<li><a class="reference external" href="http://math.nist.gov/~MDonahue/publications.html#Donahue20030528">M. J. Donahue and D. G. Porter, Physica B, 343, 177-183 (2004)</a></li>
</ul>
</div></blockquote>
<p>and one which included a section on discretisation-induced Neel wall
collapse</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://math.nist.gov/~MDonahue/publications.html#Donahue199710">M. J. Donahue, Journal of Applied Physics, 83, 6491-6493 (1998)</a></li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="micromagnetic-packages">
<span id="id7"></span><h3>Micromagnetic packages<a class="headerlink" href="manual.html#micromagnetic-packages" title="Permalink to this headline">¶</a></h3>
<p>The following micromagnetic simulation packages are freely available on the internet:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://math.nist.gov/oommf/">OOMMF</a> (finite differences)</li>
<li><a class="reference external" href="http://www.magpar.net/">Magpar</a> (finite elements)</li>
<li><a class="reference external" href="../../../../index.html">nmag</a> (finite elements)</li>
</ul>
</div></blockquote>
<p>These are general purpose packages. Some other (and partly closed
source/commercial packages) are listed at
<a class="reference external" href="http://math.nist.gov/oommf/otherlinks.html">http://math.nist.gov/oommf/otherlinks.html</a>.</p>
</div>
<div class="section" id="summary">
<span id="id8"></span><h3>Summary<a class="headerlink" href="manual.html#summary" title="Permalink to this headline">¶</a></h3>
<p>The most important points in short:</p>
<blockquote>
<div><ul class="simple">
<li>choose a small discretisation length so that the spin angle stays
well below 30 degrees.</li>
<li>if you want to simulate thin films (or other geometries with a lot
of surface [nodes]), with finite elements, consider how much memory
you would need for the boundary element matrix (best to do this
before you start creating the mesh).</li>
</ul>
</div></blockquote>
</div>
</div>
<span id="document-acknowledgements"></span><div class="section" id="acknowledgements">
<span id="id1"></span><h2>Acknowledgements<a class="headerlink" href="manual.html#acknowledgements" title="Permalink to this headline">¶</a></h2>
<p>This work has been financially supported by the <a class="reference external" href="http://www.epsrc.ac.uk">Engineering and
Physical Science Research Council (EPSRC)</a>
(GR/T09156/01,EP/E0400631/1) in the United Kingdom, through funding
from the European Community&#8217;s Seventh Framework Programme
(FP7/2007-2013) under Grant Agreement no 233552, and by the
<a class="reference external" href="http://www.soton.ac.uk">University of Southampton</a>.</p>
<p>We thank Thomas Schrefl, Wyn Williams, Michael Donahue, Richard
Boardman and Jürgen Zimmermann for useful discussion that have
supported the development of this tool.</p>
<p>Further acknowledgements go to the <a class="reference external" href="http://www.magpar.net/">Magpar</a> software and its main
author Werner Scholz. Magpar has provided a finite element
implementation of micromagnetics that has proved very useful in the
development of nmag. Special thanks to Werner Scholz who has discussed
various numerical problems with the nmag team in great depth.</p>
<p>We further thank the beta users for their helpful feedback, in
particular Michael Martens, David Vokoun, Niels Wiese, Gabriel David
Chaves O&#8217;Flynn and David Gonzales at the very early stages of the
project.</p>
</div>
</div>
<span class="target" id="indices-and-tables"></span></div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="manual.html#">NMAG User Manual v0.2.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Hans Fangohr, Thomas Fischbacher, Matteo Franchin, Giuliano Bordignon, Jacek Generowicz, Andreas Knittel, Michael Walter, Maximilian Albert.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>