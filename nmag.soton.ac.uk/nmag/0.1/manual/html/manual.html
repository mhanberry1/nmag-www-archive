<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>NMAG User Manual (0.1 Beta version)</title>
<meta name="authors" content="Hans Fangohr  Thomas Fischbacher  Matteo Franchin  Giuliano Bordignon  Jacek Generowicz  Andreas Knittel  Michael Walter" />
<link rel="stylesheet" href="voidspace_2008_03.css" type="text/css" />
</head>
<body>
<div class="document" id="nmag-user-manual-0-1-beta-version">
<h1 class="title">NMAG User Manual (0.1 Beta version)</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Authors:</th>
<td>Hans Fangohr
<br />Thomas Fischbacher
<br />Matteo Franchin
<br />Giuliano Bordignon
<br />Jacek Generowicz
<br />Andreas Knittel
<br />Michael Walter</td></tr>
<tr class="field"><th class="docinfo-name">Licence:</th><td class="field-body"><a class="reference external" href="http://www.gnu.org/licenses/gpl2.txt">GNU General Public License (GPL) version 2</a></td>
</tr>
<tr class="field"><th class="docinfo-name">SVN-Version:</th><td class="field-body">6481 compiled 2009-12-22 at 15:22.</td>
</tr>
<tr class="field"><th class="docinfo-name">Home page:</th><td class="field-body"><a class="reference external" href="../../../../index.html">http://nmag.soton.ac.uk</a></td>
</tr>
</tbody>
</table>
<!-- comment:
. -*- mode: rst -*- -->
<div align="center" class="align-center"><img alt="../images/nmaglogo500.png" class="align-center" src="../images/nmaglogo500.png" /></div>
<div class="contents topic" id="outline-of-document">
<p class="topic-title first">Outline of document</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="manual.html#introduction" id="id26">1&nbsp;&nbsp;&nbsp;Introduction</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#nmag-philosophy" id="id27">1.1&nbsp;&nbsp;&nbsp;Nmag Philosophy</a></li>
<li><a class="reference internal" href="manual.html#how-to-read-this-document" id="id28">1.2&nbsp;&nbsp;&nbsp;How to read this document</a></li>
<li><a class="reference internal" href="manual.html#development-status" id="id29">1.3&nbsp;&nbsp;&nbsp;Development status</a></li>
<li><a class="reference internal" href="manual.html#mailing-list" id="id30">1.4&nbsp;&nbsp;&nbsp;Mailing list</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#nmag-announce" id="id31">1.4.1&nbsp;&nbsp;&nbsp;nmag-announce</a></li>
<li><a class="reference internal" href="manual.html#nmag-users" id="id32">1.4.2&nbsp;&nbsp;&nbsp;nmag-users</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#support" id="id33">1.5&nbsp;&nbsp;&nbsp;Support</a></li>
<li><a class="reference internal" href="manual.html#license-and-disclaimer" id="id34">1.6&nbsp;&nbsp;&nbsp;License and Disclaimer</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#guided-tour" id="id35">2&nbsp;&nbsp;&nbsp;Guided Tour</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#id5" id="id36">2.1&nbsp;&nbsp;&nbsp;Example: Demag field in uniformly magnetised sphere</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#importing-nmag" id="id37">2.1.1&nbsp;&nbsp;&nbsp;Importing nmag</a></li>
<li><a class="reference internal" href="manual.html#creating-the-simulation-object" id="id38">2.1.2&nbsp;&nbsp;&nbsp;Creating the simulation object</a></li>
<li><a class="reference internal" href="manual.html#defining-magnetic-materials" id="id39">2.1.3&nbsp;&nbsp;&nbsp;Defining (magnetic) materials</a></li>
<li><a class="reference internal" href="manual.html#loading-the-mesh" id="id40">2.1.4&nbsp;&nbsp;&nbsp;Loading the mesh</a></li>
<li><a class="reference internal" href="manual.html#setting-the-initial-magnetisation" id="id41">2.1.5&nbsp;&nbsp;&nbsp;Setting the initial magnetisation</a></li>
<li><a class="reference internal" href="manual.html#setting-the-external-field" id="id42">2.1.6&nbsp;&nbsp;&nbsp;Setting the external field</a></li>
<li><a class="reference internal" href="manual.html#extracting-and-saving-data" id="id43">2.1.7&nbsp;&nbsp;&nbsp;Extracting and saving data</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#example-2-computing-the-time-development-of-a-system" id="id44">2.2&nbsp;&nbsp;&nbsp;Example 2: Computing the time development of a system</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#mesh-generation" id="id45">2.2.1&nbsp;&nbsp;&nbsp;Mesh generation</a></li>
<li><a class="reference internal" href="manual.html#the-simulation" id="id46">2.2.2&nbsp;&nbsp;&nbsp;The simulation</a></li>
<li><a class="reference internal" href="manual.html#analysing-the-data" id="id47">2.2.3&nbsp;&nbsp;&nbsp;Analysing the data</a></li>
<li><a class="reference internal" href="manual.html#higher-level-functions" id="id48">2.2.4&nbsp;&nbsp;&nbsp;Higher level functions</a></li>
<li><a class="reference internal" href="manual.html#relaxing-the-system" id="id49">2.2.5&nbsp;&nbsp;&nbsp;&quot;Relaxing&quot; the system</a></li>
<li><a class="reference internal" href="manual.html#relaxing-the-system-faster" id="id50">2.2.6&nbsp;&nbsp;&nbsp;&quot;Relaxing&quot; the system faster</a></li>
<li><a class="reference internal" href="manual.html#decreasing-execution-time" id="id51">2.2.7&nbsp;&nbsp;&nbsp;Decreasing execution time</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#example-simple-hysteresis-loop" id="id52">2.3&nbsp;&nbsp;&nbsp;Example: Simple hysteresis loop</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#hysteresis-simulation-script" id="id53">2.3.1&nbsp;&nbsp;&nbsp;Hysteresis simulation script</a></li>
<li><a class="reference internal" href="manual.html#hysteresis-loop-computation" id="id54">2.3.2&nbsp;&nbsp;&nbsp;Hysteresis loop computation</a></li>
<li><a class="reference internal" href="manual.html#obtaining-the-hysteresis-loop-data" id="id55">2.3.3&nbsp;&nbsp;&nbsp;Obtaining the hysteresis loop data</a></li>
<li><a class="reference internal" href="manual.html#plotting-the-hysteresis-loop-with-gnuplot" id="id56">2.3.4&nbsp;&nbsp;&nbsp;Plotting the hysteresis loop with Gnuplot</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#example-hysteresis-loop-for-stoner-wohlfarth-particle" id="id57">2.4&nbsp;&nbsp;&nbsp;Example: Hysteresis loop for Stoner-Wohlfarth particle</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#plotting-the-hysteresis-loop" id="id58">2.4.1&nbsp;&nbsp;&nbsp;Plotting the hysteresis loop</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#example-hysteresis-loop-for-thin-disk" id="id59">2.5&nbsp;&nbsp;&nbsp;Example: Hysteresis loop for thin disk</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#thin-disk-hysteresis-loop" id="id60">2.5.1&nbsp;&nbsp;&nbsp;Thin disk hysteresis loop</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#example-vortex-formation-and-propagation-in-disk" id="id61">2.6&nbsp;&nbsp;&nbsp;Example: Vortex formation and propagation in disk</a></li>
<li><a class="reference internal" href="manual.html#example-manipulating-magnetisation" id="id62">2.7&nbsp;&nbsp;&nbsp;Example: Manipulating magnetisation</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#modifying-the-magnetisation" id="id63">2.7.1&nbsp;&nbsp;&nbsp;Modifying the magnetisation</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#example-ipython" id="id64">2.8&nbsp;&nbsp;&nbsp;Example: IPython</a></li>
<li><a class="reference internal" href="manual.html#example-pinning-magnetisation" id="id65">2.9&nbsp;&nbsp;&nbsp;Example: Pinning Magnetisation</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#pinning-simulation-script" id="id66">2.9.1&nbsp;&nbsp;&nbsp;Pinning simulation script</a></li>
<li><a class="reference internal" href="manual.html#pinning-magnetisation" id="id67">2.9.2&nbsp;&nbsp;&nbsp;Pinning magnetisation</a></li>
<li><a class="reference internal" href="manual.html#visualisation" id="id68">2.9.3&nbsp;&nbsp;&nbsp;Visualisation</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#example-uniaxial-anisotropy" id="id69">2.10&nbsp;&nbsp;&nbsp;Example: Uniaxial anisotropy</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#uniaxial-anisotropy-simulation-script" id="id70">2.10.1&nbsp;&nbsp;&nbsp;Uniaxial anisotropy simulation script</a></li>
<li><a class="reference internal" href="manual.html#visualization" id="id71">2.10.2&nbsp;&nbsp;&nbsp;Visualization</a></li>
<li><a class="reference internal" href="manual.html#comparison" id="id72">2.10.3&nbsp;&nbsp;&nbsp;Comparison</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#example-cubic-anisotropy" id="id73">2.11&nbsp;&nbsp;&nbsp;Example: Cubic Anisotropy</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#cubic-anisotropy-simulation-script" id="id74">2.11.1&nbsp;&nbsp;&nbsp;Cubic anisotropy simulation script</a></li>
<li><a class="reference internal" href="manual.html#analyzing-the-result" id="id75">2.11.2&nbsp;&nbsp;&nbsp;Analyzing the result</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#example-arbitrary-anisotropy" id="id76">2.12&nbsp;&nbsp;&nbsp;Example: Arbitrary Anisotropy</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#arbitrary-anisotropy-simulation-script" id="id77">2.12.1&nbsp;&nbsp;&nbsp;Arbitrary anisotropy simulation script</a></li>
<li><a class="reference internal" href="manual.html#the-result" id="id78">2.12.2&nbsp;&nbsp;&nbsp;The result</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#restart-example" id="id79">2.13&nbsp;&nbsp;&nbsp;Restart example</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#saving-the-state-of-the-simulation" id="id80">2.13.1&nbsp;&nbsp;&nbsp;Saving the state of the simulation</a></li>
<li><a class="reference internal" href="manual.html#starting-and-restarting-the-simulation" id="id81">2.13.2&nbsp;&nbsp;&nbsp;Starting and restarting the simulation</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#example-two-different-magnetic-materials" id="id82">2.14&nbsp;&nbsp;&nbsp;Example: two different magnetic materials</a></li>
<li><a class="reference internal" href="manual.html#example-larmor-precession" id="id83">2.15&nbsp;&nbsp;&nbsp;Example: Larmor precession</a></li>
<li><a class="reference internal" href="manual.html#example-1d-periodicity" id="id84">2.16&nbsp;&nbsp;&nbsp;Example: 1D periodicity</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#introduction-periodic-boundary-conditions-macro-geometry" id="id85">2.16.1&nbsp;&nbsp;&nbsp;Introduction periodic boundary conditions (&quot;macro geometry&quot;)</a></li>
<li><a class="reference internal" href="manual.html#d-example" id="id86">2.16.2&nbsp;&nbsp;&nbsp;1d example</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#id12" id="id87">2.17&nbsp;&nbsp;&nbsp;Example: 2D periodicity</a></li>
<li><a class="reference internal" href="manual.html#example-spin-waves-in-periodic-system" id="id88">2.18&nbsp;&nbsp;&nbsp;Example: Spin-waves in periodic system</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#relaxation-script" id="id89">2.18.1&nbsp;&nbsp;&nbsp;Relaxation script</a></li>
<li><a class="reference internal" href="manual.html#visualising-the-magnetisation-evolution" id="id90">2.18.2&nbsp;&nbsp;&nbsp;Visualising the magnetisation evolution</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#example-post-processing-of-saved-field-data" id="id91">2.19&nbsp;&nbsp;&nbsp;Example: post processing of saved field data</a></li>
<li><a class="reference internal" href="manual.html#example-spin-transfer-torque-zhang-li-model" id="id92">2.20&nbsp;&nbsp;&nbsp;Example: Spin transfer torque (Zhang-Li model)</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#current-driven-motion-of-a-vortex-in-a-thin-film" id="id93">2.20.1&nbsp;&nbsp;&nbsp;Current-driven motion of a vortex in a thin film</a></li>
<li><a class="reference internal" href="manual.html#part-i-relaxation" id="id94">2.20.2&nbsp;&nbsp;&nbsp;Part I: Relaxation</a></li>
<li><a class="reference internal" href="manual.html#part-ii-current-driven-dynamics" id="id95">2.20.3&nbsp;&nbsp;&nbsp;Part II: Current driven dynamics</a></li>
<li><a class="reference internal" href="manual.html#standard-problem" id="id96">2.20.4&nbsp;&nbsp;&nbsp;Standard problem</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#example-current-driven-magnetisation-precession-in-nanopillars" id="id97">2.21&nbsp;&nbsp;&nbsp;Example: Current-driven magnetisation precession in nanopillars</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#two-simulations-in-one-single-script" id="id98">2.21.1&nbsp;&nbsp;&nbsp;Two simulations in one single script</a></li>
<li><a class="reference internal" href="manual.html#results-precession-of-the-magnetisation" id="id99">2.21.2&nbsp;&nbsp;&nbsp;Results: precession of the magnetisation</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#compression-of-the-boundary-element-matrix-using-hlib" id="id100">2.22&nbsp;&nbsp;&nbsp;Compression of the Boundary Element Matrix using HLib</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#hierarchical-matrices-in-micromagnetism" id="id101">2.22.1&nbsp;&nbsp;&nbsp;Hierarchical Matrices in Micromagnetism</a></li>
<li><a class="reference internal" href="manual.html#installation-of-hlib" id="id102">2.22.2&nbsp;&nbsp;&nbsp;Installation of HLib</a></li>
<li><a class="reference internal" href="manual.html#testing-the-hlib-bem-matrix-compression" id="id103">2.22.3&nbsp;&nbsp;&nbsp;Testing the HLib BEM Matrix compression</a></li>
<li><a class="reference internal" href="manual.html#using-hlib-example-1-demagnetisation-field-of-a-sphere" id="id104">2.22.4&nbsp;&nbsp;&nbsp;Using HLib example 1: Demagnetisation Field of a Sphere</a></li>
<li><a class="reference internal" href="manual.html#using-hlib-example-2-thin-films" id="id105">2.22.5&nbsp;&nbsp;&nbsp;Using HLib Example 2: Thin Films</a></li>
<li><a class="reference internal" href="manual.html#hlib-and-mpi" id="id106">2.22.6&nbsp;&nbsp;&nbsp;HLib and MPI</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#id23" id="id107">2.23&nbsp;&nbsp;&nbsp;Example: Timestepper tolerances</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#hysteris-loop-calculation-not-converging-a-word-of-warning" id="id108">2.23.1&nbsp;&nbsp;&nbsp;Hysteris loop calculation not converging? A word of warning ...</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#example-parallel-execution-mpi" id="id109">2.24&nbsp;&nbsp;&nbsp;Example: Parallel execution (MPI)</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#using-mpich2" id="id110">2.24.1&nbsp;&nbsp;&nbsp;Using mpich2</a></li>
<li><a class="reference internal" href="manual.html#using-mpich1" id="id111">2.24.2&nbsp;&nbsp;&nbsp;Using mpich1</a></li>
<li><a class="reference internal" href="manual.html#visualising-the-partition-of-the-mesh" id="id112">2.24.3&nbsp;&nbsp;&nbsp;Visualising the partition of the mesh</a></li>
<li><a class="reference internal" href="manual.html#performance" id="id113">2.24.4&nbsp;&nbsp;&nbsp;Performance</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#restarting-mpi-runs" id="id114">2.25&nbsp;&nbsp;&nbsp;Restarting MPI runs</a></li>
<li><a class="reference internal" href="manual.html#more-than-one-magnetic-material-exchange-coupled" id="id115">2.26&nbsp;&nbsp;&nbsp;More than one magnetic material, exchange coupled</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#background" id="id116">3&nbsp;&nbsp;&nbsp;Background</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#the-nsim-library" id="id117">3.1&nbsp;&nbsp;&nbsp;The nsim library</a></li>
<li><a class="reference internal" href="manual.html#fields-and-subfields" id="id118">3.2&nbsp;&nbsp;&nbsp;Fields and subfields</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#field" id="id119">3.2.1&nbsp;&nbsp;&nbsp;Field</a></li>
<li><a class="reference internal" href="manual.html#subfield" id="id120">3.2.2&nbsp;&nbsp;&nbsp;Subfield</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#fields-and-subfields-in-nmag" id="id121">3.3&nbsp;&nbsp;&nbsp;Fields and Subfields in Nmag</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#example-one-magnetic-material" id="id122">3.3.1&nbsp;&nbsp;&nbsp;Example: one magnetic material</a></li>
<li><a class="reference internal" href="manual.html#example-two-magnetic-material" id="id123">3.3.2&nbsp;&nbsp;&nbsp;Example: two magnetic material</a></li>
<li><a class="reference internal" href="manual.html#obtaining-and-setting-subfield-data" id="id124">3.3.3&nbsp;&nbsp;&nbsp;Obtaining and setting subfield data</a></li>
<li><a class="reference internal" href="manual.html#primary-and-secondary-fields" id="id125">3.3.4&nbsp;&nbsp;&nbsp;Primary and secondary fields</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#mesh" id="id126">3.4&nbsp;&nbsp;&nbsp;Mesh</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#node" id="id127">3.4.1&nbsp;&nbsp;&nbsp;Node</a></li>
<li><a class="reference internal" href="manual.html#node-id" id="id128">3.4.2&nbsp;&nbsp;&nbsp;node id</a></li>
<li><a class="reference internal" href="manual.html#node-position" id="id129">3.4.3&nbsp;&nbsp;&nbsp;node position</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#site" id="id130">3.5&nbsp;&nbsp;&nbsp;Site</a></li>
<li><a class="reference internal" href="manual.html#si-object" id="id131">3.6&nbsp;&nbsp;&nbsp;SI object</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#library-of-useful-si-constants" id="id132">3.6.1&nbsp;&nbsp;&nbsp;Library of useful si constants</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#terms" id="id133">3.7&nbsp;&nbsp;&nbsp;Terms</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#stage-step-iteration-time-etc" id="id134">3.7.1&nbsp;&nbsp;&nbsp;Stage, Step, iteration, time, etc.</a></li>
<li><a class="reference internal" href="manual.html#some-geek-talk-deciphered" id="id135">3.7.2&nbsp;&nbsp;&nbsp;Some geek-talk deciphered</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#solvers-and-tolerance-settings" id="id136">3.8&nbsp;&nbsp;&nbsp;Solvers and tolerance settings</a></li>
<li><a class="reference internal" href="manual.html#the-equation-of-motion-the-landau-lifshitz-gilbert-equation" id="id137">3.9&nbsp;&nbsp;&nbsp;The equation of motion: the Landau-Lifshitz-Gilbert equation</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#command-reference" id="id138">4&nbsp;&nbsp;&nbsp;Command reference</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#magmaterial" id="id139">4.1&nbsp;&nbsp;&nbsp;MagMaterial</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#uniaxial-anisotropy" id="id140">4.1.1&nbsp;&nbsp;&nbsp;uniaxial_anisotropy</a></li>
<li><a class="reference internal" href="manual.html#cubic-anisotropy" id="id141">4.1.2&nbsp;&nbsp;&nbsp;cubic_anisotropy</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#simulation" id="id142">4.2&nbsp;&nbsp;&nbsp;Simulation</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#advance-time" id="id143">4.2.1&nbsp;&nbsp;&nbsp;advance_time</a></li>
<li><a class="reference internal" href="manual.html#get-subfield" id="id144">4.2.2&nbsp;&nbsp;&nbsp;get_subfield</a></li>
<li><a class="reference internal" href="manual.html#get-subfield-positions" id="id145">4.2.3&nbsp;&nbsp;&nbsp;get_subfield_positions</a></li>
<li><a class="reference internal" href="manual.html#get-subfield-sites" id="id146">4.2.4&nbsp;&nbsp;&nbsp;get_subfield_sites</a></li>
<li><a class="reference internal" href="manual.html#get-subfield-average" id="id147">4.2.5&nbsp;&nbsp;&nbsp;get_subfield_average</a></li>
<li><a class="reference internal" href="manual.html#get-subfield-average-siv" id="id148">4.2.6&nbsp;&nbsp;&nbsp;get_subfield_average_siv</a></li>
<li><a class="reference internal" href="manual.html#probe-subfield" id="id149">4.2.7&nbsp;&nbsp;&nbsp;probe_subfield</a></li>
<li><a class="reference internal" href="manual.html#probe-subfield-siv" id="id150">4.2.8&nbsp;&nbsp;&nbsp;probe_subfield_siv</a></li>
<li><a class="reference internal" href="manual.html#probe-h-demag-siv" id="id151">4.2.9&nbsp;&nbsp;&nbsp;probe_H_demag_siv</a></li>
<li><a class="reference internal" href="manual.html#hysteresis" id="id152">4.2.10&nbsp;&nbsp;&nbsp;hysteresis</a></li>
<li><a class="reference internal" href="manual.html#load-mesh" id="id153">4.2.11&nbsp;&nbsp;&nbsp;load_mesh</a></li>
<li><a class="reference internal" href="manual.html#load-m-from-h5file" id="id154">4.2.12&nbsp;&nbsp;&nbsp;load_m_from_h5file</a></li>
<li><a class="reference internal" href="manual.html#save-restart-file" id="id155">4.2.13&nbsp;&nbsp;&nbsp;save_restart_file</a></li>
<li><a class="reference internal" href="manual.html#relax" id="id156">4.2.14&nbsp;&nbsp;&nbsp;relax</a></li>
<li><a class="reference internal" href="manual.html#save-data" id="id157">4.2.15&nbsp;&nbsp;&nbsp;save_data</a></li>
<li><a class="reference internal" href="manual.html#set-m" id="id158">4.2.16&nbsp;&nbsp;&nbsp;set_m</a></li>
<li><a class="reference internal" href="manual.html#set-h-ext" id="id159">4.2.17&nbsp;&nbsp;&nbsp;set_H_ext</a></li>
<li><a class="reference internal" href="manual.html#set-pinning" id="id160">4.2.18&nbsp;&nbsp;&nbsp;set_pinning</a></li>
<li><a class="reference internal" href="manual.html#set-params" id="id161">4.2.19&nbsp;&nbsp;&nbsp;set_params</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#get-subfield-from-h5file" id="id162">4.3&nbsp;&nbsp;&nbsp;get_subfield_from_h5file</a></li>
<li><a class="reference internal" href="manual.html#get-subfield-positions-from-h5file" id="id163">4.4&nbsp;&nbsp;&nbsp;get_subfield_positions_from_h5file</a></li>
<li><a class="reference internal" href="manual.html#get-subfield-sites-from-h5file" id="id164">4.5&nbsp;&nbsp;&nbsp;get_subfield_sites_from_h5file</a></li>
<li><a class="reference internal" href="manual.html#hmatrixsetup" id="id165">4.6&nbsp;&nbsp;&nbsp;HMatrixSetup</a></li>
<li><a class="reference internal" href="manual.html#si" id="id166">4.7&nbsp;&nbsp;&nbsp;SI</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#value" id="id167">4.7.1&nbsp;&nbsp;&nbsp;value</a></li>
<li><a class="reference internal" href="manual.html#units" id="id168">4.7.2&nbsp;&nbsp;&nbsp;units</a></li>
<li><a class="reference internal" href="manual.html#in-units-of" id="id169">4.7.3&nbsp;&nbsp;&nbsp;in_units_of</a></li>
<li><a class="reference internal" href="manual.html#is-compatible-with" id="id170">4.7.4&nbsp;&nbsp;&nbsp;is_compatible_with</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#ipython" id="id171">4.8&nbsp;&nbsp;&nbsp;ipython</a></li>
<li><a class="reference internal" href="manual.html#command-line-options" id="id172">4.9&nbsp;&nbsp;&nbsp;Command line options</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#finite-element-mesh-generation" id="id173">5&nbsp;&nbsp;&nbsp;Finite element mesh generation</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#nmesh-file-format" id="id174">5.1&nbsp;&nbsp;&nbsp;Nmesh file format</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#ascii-nmesh" id="id175">5.1.1&nbsp;&nbsp;&nbsp;Ascii nmesh</a></li>
<li><a class="reference internal" href="manual.html#hdf5-nmesh" id="id176">5.1.2&nbsp;&nbsp;&nbsp;Hdf5 nmesh</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#mesh-file-size" id="id177">5.2&nbsp;&nbsp;&nbsp;mesh file size</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#executables" id="id178">6&nbsp;&nbsp;&nbsp;Executables</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#ncol" id="id179">6.1&nbsp;&nbsp;&nbsp;ncol</a></li>
<li><a class="reference internal" href="manual.html#nmagpp" id="id180">6.2&nbsp;&nbsp;&nbsp;nmagpp</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#inspecting-the-content" id="id181">6.2.1&nbsp;&nbsp;&nbsp;Inspecting the content</a></li>
<li><a class="reference internal" href="manual.html#dumping-data" id="id182">6.2.2&nbsp;&nbsp;&nbsp;Dumping data</a></li>
<li><a class="reference internal" href="manual.html#range-of-data-to-be-processed" id="id183">6.2.3&nbsp;&nbsp;&nbsp;Range of data to be processed</a></li>
<li><a class="reference internal" href="manual.html#conversion-to-vtk-file" id="id184">6.2.4&nbsp;&nbsp;&nbsp;Conversion to vtk file</a></li>
<li><a class="reference internal" href="manual.html#other-features" id="id185">6.2.5&nbsp;&nbsp;&nbsp;Other features</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#nmeshpp" id="id186">6.3&nbsp;&nbsp;&nbsp;nmeshpp</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#general-information-info" id="id187">6.3.1&nbsp;&nbsp;&nbsp;General information (<tt class="docutils literal"><span class="pre">--info</span></tt>)</a></li>
<li><a class="reference internal" href="manual.html#memory-requirements-of-boundary-element-matrix" id="id188">6.3.2&nbsp;&nbsp;&nbsp;Memory requirements of boundary element matrix</a></li>
<li><a class="reference internal" href="manual.html#inspecting-the-quality-of-a-mesh" id="id189">6.3.3&nbsp;&nbsp;&nbsp;Inspecting the quality of a mesh</a></li>
<li><a class="reference internal" href="manual.html#histogram-of-edge-lengths" id="id190">6.3.4&nbsp;&nbsp;&nbsp;Histogram of edge lengths</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#convert-nmesh-h5-to-nmesh-file-and-back" id="id191">6.4&nbsp;&nbsp;&nbsp;Convert nmesh.h5 to nmesh file (and back)</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#nmeshmirror" id="id192">6.4.1&nbsp;&nbsp;&nbsp;nmeshmirror</a></li>
<li><a class="reference internal" href="manual.html#nmeshsort" id="id193">6.4.2&nbsp;&nbsp;&nbsp;nmeshsort</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#nmeshimport" id="id194">6.5&nbsp;&nbsp;&nbsp;nmeshimport</a></li>
<li><a class="reference internal" href="manual.html#nsim" id="id195">6.6&nbsp;&nbsp;&nbsp;nsim</a></li>
<li><a class="reference internal" href="manual.html#nsimversion" id="id196">6.7&nbsp;&nbsp;&nbsp;nsimversion</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#files-and-file-names" id="id197">7&nbsp;&nbsp;&nbsp;Files and file names</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#mesh-files-nmesh-nmesh-h5" id="id198">7.1&nbsp;&nbsp;&nbsp;mesh files (<tt class="docutils literal"><span class="pre">.nmesh</span></tt>, <tt class="docutils literal"><span class="pre">.nmesh.h5</span></tt>)</a></li>
<li><a class="reference internal" href="manual.html#simulation-scripts-py" id="id199">7.2&nbsp;&nbsp;&nbsp;Simulation scripts (<tt class="docutils literal"><span class="pre">.py</span></tt>)</a></li>
<li><a class="reference internal" href="manual.html#data-files-ndt" id="id200">7.3&nbsp;&nbsp;&nbsp;Data files (<tt class="docutils literal"><span class="pre">.ndt</span></tt>)</a></li>
<li><a class="reference internal" href="manual.html#data-files-h5" id="id201">7.4&nbsp;&nbsp;&nbsp;Data files (<tt class="docutils literal"><span class="pre">.h5</span></tt>)</a></li>
<li><a class="reference internal" href="manual.html#file-names-for-data-files" id="id202">7.5&nbsp;&nbsp;&nbsp;File names for data files</a></li>
<li><a class="reference internal" href="manual.html#file-names-for-log-files" id="id203">7.6&nbsp;&nbsp;&nbsp;File names for log files</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#frequently-asked-questions" id="id204">8&nbsp;&nbsp;&nbsp;Frequently Asked Questions</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#what-is-the-difference-between-the-oommf-and-nmag-approach" id="id205">8.1&nbsp;&nbsp;&nbsp;What is the difference between the OOMMF and nmag approach?</a></li>
<li><a class="reference internal" href="manual.html#so-this-means-the-major-difference-is-cubes-vs-tetrahedra" id="id206">8.2&nbsp;&nbsp;&nbsp;...So, this means the major difference is &quot;cubes&quot; vs. &quot;tetrahedra&quot;?</a></li>
<li><a class="reference internal" href="manual.html#why-do-you-have-your-own-python-interpreter-nsim" id="id207">8.3&nbsp;&nbsp;&nbsp;Why do you have your own Python interpreter (=``nsim``)?</a></li>
<li><a class="reference internal" href="manual.html#what-is-nsim-i-thought-the-package-is-called-nmag" id="id208">8.4&nbsp;&nbsp;&nbsp;What is nsim - I thought the package is called nmag?</a></li>
<li><a class="reference internal" href="manual.html#how-fast-is-nmag-in-comparison-to-magpar" id="id209">8.5&nbsp;&nbsp;&nbsp;How fast is nmag in comparison to magpar?</a></li>
<li><a class="reference internal" href="manual.html#how-do-i-start-a-time-consuming-nmag-run-in-the-background" id="id210">8.6&nbsp;&nbsp;&nbsp;How do I start a time-consuming nmag run in the background?</a></li>
<li><a class="reference internal" href="manual.html#nmag-claims-to-support-mpi-so-can-i-run-simulation-jobs-on-multiple-processors" id="id211">8.7&nbsp;&nbsp;&nbsp;nmag claims to support MPI. So, can I run simulation jobs on multiple processors?</a></li>
<li><a class="reference internal" href="manual.html#how-should-i-cite-nmag" id="id212">8.8&nbsp;&nbsp;&nbsp;How should I cite nmag?</a></li>
<li><a class="reference internal" href="manual.html#why-can-you-not-use-the-step-as-a-unique-identifier" id="id213">8.9&nbsp;&nbsp;&nbsp;Why can you not use the step as a unique identifier?</a></li>
<li><a class="reference internal" href="manual.html#how-to-generate-a-mesh-with-more-than-one-region-using-gmsh" id="id214">8.10&nbsp;&nbsp;&nbsp;How to generate a mesh with more than one region using GMSH?</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#useful-tools" id="id215">9&nbsp;&nbsp;&nbsp;Useful tools</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#vtk" id="id216">9.1&nbsp;&nbsp;&nbsp;vtk</a></li>
<li><a class="reference internal" href="manual.html#mayavi" id="id217">9.2&nbsp;&nbsp;&nbsp;MayaVi</a></li>
<li><a class="reference internal" href="manual.html#numpy" id="id218">9.3&nbsp;&nbsp;&nbsp;NumPy</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#contact" id="id219">10&nbsp;&nbsp;&nbsp;Contact</a></li>
<li><a class="reference internal" href="manual.html#mini-tutorial-micromagnetic-modelling" id="id220">11&nbsp;&nbsp;&nbsp;Mini tutorial micromagnetic modelling</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#introduction-micromagnetic-modelling" id="id221">11.1&nbsp;&nbsp;&nbsp;Introduction micromagnetic modelling</a></li>
<li><a class="reference internal" href="manual.html#what-is-better-finite-differences-or-finite-elements" id="id222">11.2&nbsp;&nbsp;&nbsp;What is better: finite differences or finite elements?</a></li>
<li><a class="reference internal" href="manual.html#what-size-of-the-cells-fd-and-tetrahedra-fe-should-i-choose" id="id223">11.3&nbsp;&nbsp;&nbsp;What size of the cells (FD) and tetrahedra (FE) should I choose?</a><ul class="auto-toc">
<li><a class="reference internal" href="manual.html#exchange-length" id="id224">11.3.1&nbsp;&nbsp;&nbsp;Exchange length</a></li>
<li><a class="reference internal" href="manual.html#further-reading" id="id225">11.3.2&nbsp;&nbsp;&nbsp;Further reading</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#micromagnetic-packages" id="id226">11.4&nbsp;&nbsp;&nbsp;Micromagnetic packages</a></li>
<li><a class="reference internal" href="manual.html#summary" id="id227">11.5&nbsp;&nbsp;&nbsp;Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="manual.html#acknowledgements" id="id228">12&nbsp;&nbsp;&nbsp;Acknowledgements</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="manual.html#id26">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<p>Nmag is a flexible finite element micromagnetic simulation
package with an user interface based on the
<a class="reference external" href="http://www.python.org/">Python</a> programming language.</p>
<div class="section" id="nmag-philosophy">
<h2><a class="toc-backref" href="manual.html#id27">1.1&nbsp;&nbsp;&nbsp;Nmag Philosophy</a></h2>
<p>The majority of specialized simulation codes used in research today
consists of a highly specialized core application which initially was
written to simulate the behaviour of some very specific
system. Usually, the core application then evolved into a more broadly
applicable tool through the introduction of additional
parameters. Some simulation codes reach a point where it becomes
evident that they need an amount of flexibility that can only be
provided by including some script programming capabilities.</p>
<p>The approach underlying Nmag turns this very common pattern of
software evolution (which we also have seen in web browsers, CAD
software, word processors, etc) on its head: rather than gradually
providing more and more flexibility in an ad-hoc manner through adding
configuration parameters, slowly evolving into an extensive
specialized programming language, Nmag starts out as an extension to
a widely used programming language (<a class="reference external" href="http://www.python.org">Python</a>) from which it gains all its
flexibility and evolves towards more specialized notions to
conveniently define and study the properties of very specific physical
systems <a class="footnote-reference" href="manual.html#id3" id="id1">[1]</a>.</p>
<p>The main advantage of this approach is two-fold: first, we do not
gradually evolve another ad-hoc (and potentially badly implemented)
special purpose programming language. Second, by drawing upon the
capabilities of a well supported existing framework for flexibility,
we get a lot of additional power for free: the user can employ readily
available and well supported Python libraries for tasks such as data
post-processing and analysis, e.g. generating images for web pages
etc. In addition to this, some users may benefit from the capability
to use Nmag interactively from a command prompt, which can be very
helpful during the development phase of an involved simulation script <a class="footnote-reference" href="manual.html#id4" id="id2">[2]</a>.</p>
<p>The disadvantage is of course that a novice user may be confronted
with much more freedom than he can handle. We try to cope with this
issue by providing a collection of example scripts (in the <a class="reference internal" href="manual.html#guided-tour">Guided
tour</a>) for the most common applications that only need very slight
modification for basic use (e.g. changing of the mesh filename or
material parameters).</p>
<p>At present, Nmag is based on the Python programming language. This
seems to be a somewhat reasonable choice at present, as Python is
especially friendly towards casual users who do not want to be forced
to first become expert programmers before they can produce any useful
results. Furthermore, Python is quite widespread and widely supported
these days.</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id1">[1]</a></td><td>Thomas Fischbacher, Matteo Franchin, Giuliano Bordignon,, Hans Fangohr, <em>A Systematic Approach to Multiphysics Extensions of Finite-Element-Based Micromagnetic Simulations: Nmag</em>, IEEE Transactions on Magnetics <strong>43</strong>, 6, 2896-2898 (2007), online at <a class="reference external" href="http://eprints.soton.ac.uk/46725/">http://eprints.soton.ac.uk/46725/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id2">[2]</a></td><td>Thomas Fischbacher, Matteo Franchin, Giuliano Bordignon, Andreas Knittel, Hans Fangohr, <em>Parallel execution and scriptability in micromagnetic simulations</em>, Journal of Applied Physics <strong>105</strong>, 07D527 (2009), online at <a class="reference external" href="http://link.aip.org/link/?JAPIAU/105/07D527/1">http://link.aip.org/link/?JAPIAU/105/07D527/1</a></td></tr>
</tbody>
</table>
<!-- comment:

As most of the underlying field theoretical foundations
used by |Nmag| are derived from the low level |Nsim| multiphysics
simulator which is not closely tied to Python, it would be possible to
provide support for other scripting languages in the future should the
need arise (e.g. in case Python should become unpopular over the
years). -->
</div>
<div class="section" id="how-to-read-this-document">
<h2><a class="toc-backref" href="manual.html#id28">1.2&nbsp;&nbsp;&nbsp;How to read this document</a></h2>
<p>We suggest you follow the <a class="reference internal" href="manual.html#guided-tour">Guided Tour</a> through a number of examples
to get a quick overview of what nmag looks like in real use, and to
see examples that can be used to carry out typical simulations. We
provide a number of skeletons that are easily adapted to specific
systems which show how to compute hysteresis loops, do energy
minimisation, or compute time evolution.</p>
<p>The <a class="reference internal" href="manual.html#command-reference">Command Reference</a> section explains the relevant commands
provided by Nmag in full detail. This should be especially useful to
advanced users who want to design sophisticated simulation scripts in
Python.</p>
<p>If you are new to micromagnetic modelling, you may want to start with
the <a class="reference internal" href="manual.html#mini-tutorial-micromagnetic-modelling">mini tutorial micromagnetic modelling</a>.</p>
</div>
<div class="section" id="development-status">
<h2><a class="toc-backref" href="manual.html#id29">1.3&nbsp;&nbsp;&nbsp;Development status</a></h2>
<p>Nmag is a relatively young piece of software. It almost certainly
contains many bugs and we encourage users to report these to the
<a class="reference internal" href="manual.html#nmag-team">nmag team</a>, so they can be document and fixed.</p>
<p>It is also very likely that parts of the user interface will change
over time.  We will try to make changes backward compatible where this
is feasible and acceptable.</p>
<p>Some features do exist that have not been documented in the manual
yet. This may be (i) because the nmag team has not found the time yet
to create the documentation. However, it is also possible that (ii) we
are still testing how a feature and its interface <em>feels</em> when being
used, and we hesitate to document an interface if we consider it
likely that it might be changed in the near future. Finally, (iii) we
will not rush to publish any new functionality if we are not aware of
any users who would be interested in this feature. For this reason, we
do encourage users to contact the <a class="reference internal" href="manual.html#nmag-team">nmag team</a> to suggest features
that would be relevant to them. We are also interested in generic
feedback (good and bad; ideally constructive).</p>
<p>While we have only limited resources for the development and
maintenance of the code and will therefore not be able to react
immediately (or at all) to requests and suggestions, it is important
that we maintain an up-to-date understanding of the requirements of
the community.</p>
</div>
<div class="section" id="mailing-list">
<h2><a class="toc-backref" href="manual.html#id30">1.4&nbsp;&nbsp;&nbsp;Mailing list</a></h2>
<p>If you are using nmag, we recommend that you subscribe to at least
one of these following two lists to be aware of any major bugs or
improvements. If you have a question about how to use the software, we
suggest you subscribe to <a class="reference internal" href="manual.html#nmag-users">nmag-users</a>, and post it there. (If you
prefer to contact only the devolpers, see <a class="reference internal" href="manual.html#nmag-team">nmag team</a>.)</p>
<div class="section" id="nmag-announce">
<h3><a class="toc-backref" href="manual.html#id31">1.4.1&nbsp;&nbsp;&nbsp;nmag-announce</a></h3>
<p><strong>nmag-announce&#64;lists.soton.ac.uk</strong> is a low traffic read-only mailing
list which will broadcast updates of nmag and any other relevant news.</p>
<p>To subscribe to this list, send an email to
<a class="reference external" href="mailto:nmag-announce-request&#64;lists.soton.ac.uk">nmag-announce-request&#64;lists.soton.ac.uk</a> with an empty
subject and the word <tt class="docutils literal"><span class="pre">subscribe</span></tt> in the body of the email.</p>
<p>The <strong>archives</strong> can be found and searched at
<a class="reference external" href="http://groups.google.com/group/nmag-announce">http://groups.google.com/group/nmag-announce</a>.</p>
</div>
<div class="section" id="nmag-users">
<h3><a class="toc-backref" href="manual.html#id32">1.4.2&nbsp;&nbsp;&nbsp;nmag-users</a></h3>
<p><strong>nmag-users&#64;lists.soton.ac.uk</strong> is a mailing list to discuss the use of
nmag. Any announcements to <tt class="docutils literal"><span class="pre">nmag-announce</span></tt> will also be sent to this
mailing list.</p>
<p>To subscribe to this list, send an email to
<a class="reference external" href="mailto:nmag-users-request&#64;lists.soton.ac.uk">nmag-users-request&#64;lists.soton.ac.uk</a> with an empty subject
and the word <tt class="docutils literal"><span class="pre">subscribe</span></tt> in the body of the email.</p>
<p>Information about how to unsubscribe are provided with the welcome
message once you have subscribed.</p>
<p>The <strong>archives</strong> can be found and searched at
<a class="reference external" href="http://groups.google.com/group/nmag-users">http://groups.google.com/group/nmag-users</a>.</p>
</div>
</div>
<div class="section" id="support">
<h2><a class="toc-backref" href="manual.html#id33">1.5&nbsp;&nbsp;&nbsp;Support</a></h2>
<p>Support will be provided within our limited resources. After
consulting the manual, please feel free to use the <a class="reference internal" href="manual.html#mailing-list">mailing list</a>
<tt class="docutils literal"><span class="pre">nmag-users&#64;lists.soton.ac.uk</span></tt> to seek advice, or contact the <a class="reference internal" href="manual.html#nmag-team">nmag
team</a> directly.</p>
</div>
<div class="section" id="license-and-disclaimer">
<h2><a class="toc-backref" href="manual.html#id34">1.6&nbsp;&nbsp;&nbsp;License and Disclaimer</a></h2>
<p>This software was developed at the University of Southampton, United
Kingdom. It is released under the GNU General Public License (<a class="reference external" href="http://www.gnu.org/licenses/gpl2.txt">GPL</a>) as
published by the Free Software Foundation; either version 2, or (at
your option) any later version.</p>
<p>Nmag is an experimental system. Neither the University of
Southampton nor the authors assume any responsibility whatsoever for
its use by other parties, and makes no guarantees, expressed or
implied, about its quality, reliability, or any other characteristic.</p>
</div>
</div>
<div class="section" id="guided-tour">
<h1><a class="toc-backref" href="manual.html#id35">2&nbsp;&nbsp;&nbsp;Guided Tour</a></h1>
<p>We present a number of worked out examples that are explained in
detail and should cover most of the usual applications.</p>
<div class="section" id="id5">
<span id="example-demag-field-in-uniformly-magnetised-sphere"></span><span id="example-1"></span><h2><a class="toc-backref" href="manual.html#id36">2.1&nbsp;&nbsp;&nbsp;Example: Demag field in uniformly magnetised sphere</a></h2>
<p>This is the most basic example that computes the demagnetisation field
in an uniformly magnetised sphere. For this simple system, the exact
result is known analytically: the demag field vector has to be equal
to minus one-third of the magnetisation vector, everywhere.</p>
<p>When using finite element calculations, a crucial (and non-trivial)
part of the work is the <a class="reference internal" href="manual.html#finite-element-mesh-generation">finite element mesh generation</a>. We provide
a very small mesh for this example (<a class="reference external" href="../example1/sphere1.nmesh.h5">sphere1.nmesh.h5</a>) which was generated with <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a>
(from this <a class="reference external" href="../example1/sphere1.geo">geometry file</a>). This gives us
a sphere of radius 10nm.</p>
<div align="center" class="align-center"><img alt="../example1/spheremesh.png" class="align-center" src="../example1/spheremesh.png" /></div>
<p>We can then use the following nmag script <a class="reference external" href="../example1/sphere1.py">sphere1.py</a>:</p>
<blockquote>
<pre class="literal-block">
import sys
sys.argv.append('--clean')

import nmag
from nmag import SI

#create simulation object
sim = nmag.Simulation()

# define magnetic material
Py = nmag.MagMaterial(name = 'Py',
                      Ms = SI(1e6, 'A/m'),
                      exchange_coupling = SI(13.0e-12, 'J/m'))

# load mesh
sim.load_mesh('sphere1.nmesh.h5',
              [('sphere', Py)],
              unit_length = SI(1e-9, 'm'))

# set initial magnetisation
sim.set_m([1,0,0])

# set external field
sim.set_H_ext([0,0,0], SI('A/m'))

# Save and display data in a variety of ways
sim.save_data(fields='all') # save all fields spatially resolved
                            # together with average data

# sample demag field through sphere
for i in range(-10,11):
    x = i*1e-9                      #position in metres
    H_demag = sim.probe_subfield_siv('H_demag', [x,0,0])
    print &quot;x =&quot;, x, &quot;: H_demag = &quot;, H_demag


</pre>
</blockquote>
<p>To execute this script, we have to give its name to the <a class="reference internal" href="manual.html#nsim">nsim</a>
executable, for example (on linux):</p>
<pre class="literal-block">
$ nsim sphere1.py
</pre>
<p>Some simulations produce output files which nsim will refuse to
overwrite when run for a second time. The rationale is that big
simulations may have to run for a long time and so, there should be a
safeguard against accidental destruction of data.</p>
<p>In order to re-run a simulation, removing all old output data files,
the extra option --clean should be given, as in:</p>
<pre class="literal-block">
$ nsim sphere1.py --clean
</pre>
<p>Let us discuss the <tt class="docutils literal"><span class="pre">sphere1.py</span></tt> script step by step.</p>
<div class="section" id="importing-nmag">
<h3><a class="toc-backref" href="manual.html#id37">2.1.1&nbsp;&nbsp;&nbsp;Importing nmag</a></h3>
<p>First we need to import the nmag module, and any subpackages of nmag
that we want to use. (In this basic example, this is just the SI
module for dimensionful physical quantities).</p>
<pre class="literal-block">
import nmag
from nmag import SI
</pre>
</div>
<div class="section" id="creating-the-simulation-object">
<h3><a class="toc-backref" href="manual.html#id38">2.1.2&nbsp;&nbsp;&nbsp;Creating the simulation object</a></h3>
<p>Next, we need to create a simulation object. This will contain and
provide information about our physical system.</p>
<pre class="literal-block">
sim = nmag.Simulation()
</pre>
</div>
<div class="section" id="defining-magnetic-materials">
<h3><a class="toc-backref" href="manual.html#id39">2.1.3&nbsp;&nbsp;&nbsp;Defining (magnetic) materials</a></h3>
<p>After importing the nmag module into Python's workspace and creating
the simulation object <tt class="docutils literal"><span class="pre">sim</span></tt>, we need to define a material using
<tt class="docutils literal"><span class="pre">nmag.MagMaterial</span></tt>. We give it a name (as a Python string) which in
this case we choose to be <tt class="docutils literal"><span class="pre">&quot;Py&quot;</span></tt> (a common abbreviation for
PermAlloy) and we assign a saturation magnetisation and an exchange
coupling strength.</p>
<pre class="literal-block">
Py = nmag.MagMaterial(name = 'Py',
                      Ms = SI(1e6, 'A/m',
                      exchange_coupling = SI(13.0e-12, 'J/m'))
</pre>
<p>The name of the material is important, as we may want to simulate
systems made up of multiple different materials, and the material name
will be used as a postfix to the name of some <a class="reference internal" href="manual.html#fields-and-subfields">Fields and Subfields</a>.
The output files will also use that name to label output data. Names
must be alphanumeric (i.e. formed exclusively out of the characters in
the set 0-9_a-zA-Z) here.</p>
<p>Rather than representing dimensionful physical quantities as numbers,
nmag uses a special object class, the &quot;SI object&quot;. The underlying
rationale is that this allows automated detection of mismatches of
physical dimensions. If some physical parameter is given to nmag in a
dimension different from the expected one, nmag will detect this and
report an error. Also, any nmag output [e.g. a three-dimensional VTK
visualisation file] will provide a sufficient amount of contextual
information to clarify the physical meaning (i.e. dimensions) of
numerical data.</p>
<p>We thus express the saturation magnetisation in Ampere per meter (<tt class="docutils literal"><span class="pre">Ms</span>
<span class="pre">=</span> <span class="pre">SI(1e6,&quot;A/m&quot;)</span></tt>) and the exchange coupling constant (often called A
in micromagnetism) in Joules per meter (<tt class="docutils literal"><span class="pre">exchange_coupling</span> <span class="pre">=</span>
<span class="pre">SI(13.0e-12,</span> <span class="pre">&quot;J/m&quot;)</span></tt>). (Note that these are not the true physical
parameters of PermAlloy, but have been chosen ad hoc for the sake
of providing a simple example!)</p>
</div>
<div class="section" id="loading-the-mesh">
<h3><a class="toc-backref" href="manual.html#id40">2.1.4&nbsp;&nbsp;&nbsp;Loading the mesh</a></h3>
<p>The next step is to load the mesh.</p>
<pre class="literal-block">
sim.load_mesh('sphere1.nmesh.h5',
              [('sphere', Py)],
              unit_length = SI(1e-9, 'm'))
</pre>
<p>The first argument is the file name (<tt class="docutils literal"><span class="pre">&quot;sphere1.nmesh.h5&quot;</span></tt>). The
second argument is a list of tuples which describe the domains (also
called regions) within the mesh. In this example we have a one-element
list containing the 2-tuple <tt class="docutils literal"><span class="pre">(&quot;sphere&quot;,</span> <span class="pre">Py)</span></tt>. The left element of
this pair, <tt class="docutils literal"><span class="pre">&quot;sphere&quot;</span></tt>, is a string (of the user's choice) and this
is the name given to mesh region 1 (i.e. the space occupied by all
simplices that have the region id 1 in the mesh file).</p>
<p>[This information is currently only used for debugging purposes (such
as when printing the simulation object).]</p>
<p>The second part of the tuple is the <tt class="docutils literal"><span class="pre">MagMaterial</span></tt> object that has
been created in <a class="reference internal" href="manual.html#defining-magnetic-materials">Defining (magnetic) materials</a> and bound to the
variable <tt class="docutils literal"><span class="pre">Py</span></tt>. This object determines the material properties of the
material in this domain; in this example, we have specified the
properties of PermAlloy.</p>
<p>The third argument to <a class="reference internal" href="manual.html#load-mesh">load_mesh</a> is an <a class="reference internal" href="manual.html#si-object">SI object</a> which defines what
physical distance should be associated with the length 1.0 as given in
the mesh file. In this example, the mesh has been created in
nanometers, i.e. the distance 1.0 in the mesh file should correspond
to 1 nanometer in the real world. We thus use a SI object representing
1 nm.</p>
</div>
<div class="section" id="setting-the-initial-magnetisation">
<h3><a class="toc-backref" href="manual.html#id41">2.1.5&nbsp;&nbsp;&nbsp;Setting the initial magnetisation</a></h3>
<p>To set the initial magnetisation, we use the <a class="reference internal" href="manual.html#set-m">set_m</a> method.</p>
<pre class="literal-block">
sim.set_m([1,0,0])
</pre>
<p>The field <tt class="docutils literal"><span class="pre">m</span></tt> describes the direction of magnetisation (as a
field of normalised vectors) whereas the
field <tt class="docutils literal"><span class="pre">M</span></tt> contains the magnetisation with its proper magnitude.
So, <tt class="docutils literal"><span class="pre">|M|</span></tt> is the saturation magnetisation (in Amperes per meter),
whereas <tt class="docutils literal"><span class="pre">m</span></tt> is dimensionless with <tt class="docutils literal"><span class="pre">|m|=1.0</span></tt>. There are different
ways to set a particular magnetisation, in the simplest case of a
homogeneously magnetised body, it is sufficient to provide the
magnetisation vector. So, in this example, we provide a unit vector
pointing in positive x-direction. (We could provide a vector with
non-normalised magnitude, which would be normalised
automatically. This is convenient for, say, setting an initial
magnetisation in the x-y-plane with a 45 degree angle towards
the x axis by specifying <tt class="docutils literal"><span class="pre">[1,1,0]</span></tt>).</p>
</div>
<div class="section" id="setting-the-external-field">
<h3><a class="toc-backref" href="manual.html#id42">2.1.6&nbsp;&nbsp;&nbsp;Setting the external field</a></h3>
<p>We can set the external field using the <a class="reference internal" href="manual.html#set-h-ext">set_H_ext</a> command</p>
<pre class="literal-block">
sim.set_H_ext([0,0,0], SI('A/m'))
</pre>
<p>In contrast to <a class="reference internal" href="manual.html#set-m">set_m</a>, this method takes two arguments. The first
defines numerical values for the direction and magnitude of the
external field. The second determines the meaning of these numerical
values using an SI object. Suppose we would like an external field of
1e6 A/m acting in the y-direction, then the command would read:
<tt class="docutils literal"><span class="pre">sim.set_H_ext([0,1e6,0],SI(1,&quot;A/m&quot;))</span></tt>. However, we could also use
<tt class="docutils literal"><span class="pre">sim.set_H_ext([0,1,0],SI(1e6,&quot;A/m&quot;))</span></tt>.</p>
<p>The default value for the external field is [0,0,0] A/m, so for this
example, we could have omitted the <a class="reference internal" href="manual.html#set-h-ext">set_H_ext</a> command altogether.</p>
</div>
<div class="section" id="extracting-and-saving-data">
<h3><a class="toc-backref" href="manual.html#id43">2.1.7&nbsp;&nbsp;&nbsp;Extracting and saving data</a></h3>
<p>We have three different ways of extracting data from the simulation:</p>
<ol class="arabic simple">
<li>saving averaged values of fields (which can be analysed later)</li>
<li>saving spatially resolved fields (which can be analysed later)</li>
<li>extracting field values at arbitrary positions from within the
running program</li>
</ol>
<p>In this basic example, we demonstrate the use of all three methods:</p>
<div class="section" id="saving-averaged-data">
<h4>2.1.7.1&nbsp;&nbsp;&nbsp;Saving averaged data</h4>
<pre class="literal-block">
sim.save_data()
</pre>
<p>The <a class="reference internal" href="manual.html#save-data">save_data</a> method writes (spatial) averages of all fields (see
<a class="reference internal" href="manual.html#fields-and-subfields">Fields and subfields</a>) into a text file (which will be named
<tt class="docutils literal"><span class="pre">sphere1_dat.ndt</span></tt>, see below). This file is best analysed using the
<a class="reference internal" href="manual.html#ncol">ncol</a> tool but can also just be read with a text editor. The format
follows OOMMF's <tt class="docutils literal"><span class="pre">odt</span></tt> file format: every row corresponds to one
snapshot of the system (see <a class="reference internal" href="manual.html#save-data">save_data</a>).</p>
<p>The function can also be called with parameters to save spatially
resolved field data (see <a class="reference internal" href="manual.html#saving-spatially-resolved-data">Saving spatially resolved data</a>).</p>
<p>The first and second line in the data file are headers that explain
(by column) the physical quantities (and their dimensions).</p>
<p>The <a class="reference internal" href="manual.html#ncol">ncol</a> tool allows to extract particular columns easily so that
these can be plotted later (useful for hysteresis loop studies). In
this example we have only one &quot;timestep&quot;: there only is one row of
data in this file. We will therefore discuss this in more detail in a
subsequent example.</p>
</div>
<div class="section" id="extracting-arbitrary-data-from-the-running-program">
<h4>2.1.7.2&nbsp;&nbsp;&nbsp;Extracting arbitrary data from the running program</h4>
<p>The line</p>
<pre class="literal-block">
H_demag = sim.probe_subfield_siv( 'H_demag', [x,0,0] )
</pre>
<p>obtains the demagnetisation field (see <a class="reference internal" href="manual.html#fields-and-subfields-in-nmag">Fields and subfields in
nmag</a>) at position (x,0,0). The suffix &quot;_siv&quot; to this function means
that both positions and return values will be given as SI values.</p>
<p>The for-loop in the program (which iterates <tt class="docutils literal"><span class="pre">x</span></tt> in the range from
-10*1e-9 to 10*1e-9 in steps of 1e-9) produces the following output</p>
<pre class="literal-block">
x = -1e-08 : H_demag =  None
x = -9e-09 : H_demag =  [-329655.76203912671, 130.62999726469423, 194.84338557811344]
x = -8e-09 : H_demag =  [-329781.46587966662, 66.963624669268853, 137.47161381890737]
x = -7e-09 : H_demag =  [-329838.57852402801, 181.46249265908259, 160.61298054099865]
x = -6e-09 : H_demag =  [-329899.63327447395, 131.06488858715838, 71.383139326493094]
x = -5e-09 : H_demag =  [-329967.79622912291, 82.209856975234786, -16.893046828024836]
x = -4e-09 : H_demag =  [-329994.67306536058, 61.622521557150371, -34.433041910642359]
x = -3e-09 : H_demag =  [-329997.62759666931, 23.222244635691535, -65.991127111463769]
x = -2e-09 : H_demag =  [-330013.90370482224, 10.11035370824321, -61.358763616681067]
x = -1e-09 : H_demag =  [-330023.50844056415, -6.9714476825652287, -54.900260456937708]
x = 0.0   : H_demag =  [-330030.98847923806, -26.808832466764223, -48.465748009067141]
x = 1e-09 : H_demag =  [-330062.38479507214, -38.660812022013424, -42.83439139610747]
x = 2e-09 : H_demag =  [-330093.78111090627, -50.512791577262625, -37.2030347831478]
x = 3e-09 : H_demag =  [-330150.72580001026, -64.552170478617398, -23.120555702674721]
x = 4e-09 : H_demag =  [-330226.19050178828, -77.236085707456397, -5.5373829923226916]
x = 5e-09 : H_demag =  [-330304.59300913941, -90.584413821813229, 14.090609104026118]
x = 6e-09 : H_demag =  [-330380.1392610991, -115.83746059068679, 37.072085708324757]
x = 7e-09 : H_demag =  [-330418.85831447819, -122.47512022500726, 62.379121138009992]
x = 8e-09 : H_demag =  [-330476.40747455234, -110.84257225592108, 108.06217226524763]
x = 9e-09 : H_demag =  [-330500.20126762061, -68.175725285038382, 162.46166752217249]
x = 1e-08 : H_demag =  [-330517.86675206106, -24.351273685146875, 214.40344001233677]
</pre>
<p>At position -1e-8, there is no field defined (this point lies just
outside our sphere-mesh) and therefore the value <tt class="docutils literal"><span class="pre">None</span></tt> is returned.</p>
<p>We can see how the demagnetisation field varies slightly throughout
the sphere. The x-component is approximately a third of the
magnetisation, and the y- and z-components are close to zero (as would
be expected for a perfectly round sphere).</p>
<p>We mention for completeness that most fields (such as magnetisation,
exchange field, anisotropy field etc) are only defined within the
region(s) occupied by magnetic material. However, there is a special
function <a class="reference internal" href="manual.html#probe-h-demag-siv">probe_H_demag_siv</a> to probe the demagnetisation field
anywhere in space.</p>
</div>
<div class="section" id="saving-spatially-resolved-data">
<h4>2.1.7.3&nbsp;&nbsp;&nbsp;Saving spatially resolved data</h4>
<p>The command</p>
<pre class="literal-block">
sim.save_data(fields='all')
</pre>
<p>will save full spatially resolved data on all fields (see <a class="reference internal" href="manual.html#fields-and-subfields">Fields and
subfields</a>) for the current configuration into a file with name
<tt class="docutils literal"><span class="pre">sphere1_dat.h5</span></tt>. (It will also save the spatially averaged values
as described in <a class="reference internal" href="manual.html#saving-averaged-data">Saving averaged data</a>.) Whenever the <a class="reference internal" href="manual.html#save-data">save_data</a>
function is called, it will write the averaged field values into the
<a class="reference internal" href="manual.html#ndt">ndt</a> file. This name is, by default, based on the name of the
simulation script, but can be overridden with an optional argument to
the <a class="reference internal" href="manual.html#simulation">Simulation</a> constructor. The data in this file are kept in some
compressed binary format (built on the <a class="reference external" href="http://www.hdfgroup.org/">hdf5</a> standard) and can be
extracted and converted later using the <a class="reference internal" href="manual.html#nmagpp">nmagpp</a> tool.</p>
<p>For example, we can extract the magnetisation field from this file
with the command:</p>
<pre class="literal-block">
$ nmagpp --dump sphere1
</pre>
<p>However, here we are interested in creating a <a class="reference internal" href="manual.html#vtk">vtk</a> from the saved data
file for visualisation. We use:</p>
<pre class="literal-block">
$ nmagpp --vtk sphere1.vtk sphere1
</pre>
<p>where <tt class="docutils literal"><span class="pre">sphere1.vtk</span></tt> is the base name of the vtk file that is to be
generated.</p>
<p>In this manual, we use <a class="reference internal" href="manual.html#mayavi">MayaVi</a> as the visualisation tool for vtk files
but there are others available (see <a class="reference internal" href="manual.html#vtk">vtk</a>).</p>
<p>Starting MayaVi with the command <tt class="docutils literal"><span class="pre">mayavi</span> <span class="pre">-d</span> <span class="pre">sphere1-000000.vtk</span></tt> will load
our simulation data. Using the pull-down menu Visualize -&gt; Modules -&gt;
VelocityVector will then tell MayaVi to display the magnetisation
vector field. (Likewise, we can use Visualize -&gt; Modules -&gt; Axes to
add a 3d coordinate system to the visualization):</p>
<div align="center" class="align-center"><img alt="../example1/sphere1_h5_m.png" class="align-center" src="../example1/sphere1_h5_m.png" /></div>
<p>The magnetisation is pointing in positive x-direction because we
initialised the magnetisation in this orientation by issuing the
command <tt class="docutils literal"><span class="pre">sim.set_m([1,0,0])</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">Configure</span> <span class="pre">Data</span></tt> button in the DataVizManager section of
MayaVi's user interface allows to select:</p>
<ul class="simple">
<li>a vector field and</li>
<li>a scalar field</li>
</ul>
<p>which provide the data that is used for subsequent visualisation
modules. Above, we have used the <tt class="docutils literal"><span class="pre">m_Py</span></tt> vector field.</p>
<p>The demagnetisation field should point in the opposite direction of
the magnetisation. However, let's first create a colour-coded plot of
the scalar magnetic potential, phi, from which the demag field is
computed (by taking its negative gradient):</p>
<div align="center" class="align-center"><img alt="../example1/sphere1_h5_phi.png" class="align-center" src="../example1/sphere1_h5_phi.png" /></div>
<p>We first need to select <tt class="docutils literal"><span class="pre">phi</span></tt> as the data source for 'scalar'
visualisation modules: Through clicking on the <tt class="docutils literal"><span class="pre">Configure</span> <span class="pre">Data</span></tt>
button in the DataVizManager section of MayaVi's user interface, we
can select <tt class="docutils literal"><span class="pre">phi&lt;A&gt;</span></tt> as the data source for scalar
visualisations. (The <tt class="docutils literal"><span class="pre">&lt;A&gt;</span></tt> simply indicates that the units of the
potential are Ampere).</p>
<p>To show the scalar potential, we use the
<tt class="docutils literal"><span class="pre">Visualize-&gt;Module-&gt;SurfaceMap</span></tt> module.</p>
<p>We can see that the potential varies along the x-direction. The legend
at the bottom of the figure shows the colour code used. We can also
see from the legend title that the physical dimension of the potential
phi is Ampere (this is the <tt class="docutils literal"><span class="pre">&lt;A&gt;</span></tt>).</p>
<p>Unless the user specifies a particular request for physical dimensions,
the following rules apply for vtk files:</p>
<ul class="simple">
<li>position are given in the same coordinates as the mesh coordinates
(that is why in this example, the x, y and z axis have values going
from -10 to 10).</li>
<li>all field data are given in SI units.</li>
</ul>
<p>The next plot shows the demag field (the vectors) together with
isosurfaces of the magnetic potential:</p>
<div align="center" class="align-center"><img alt="../example1/sphere1_h5_demag.png" class="align-center" src="../example1/sphere1_h5_demag.png" /></div>
<p>It can be seen that the isosurfaces are completely flat planes
(i.e. the potential is changing only along x) and the demagnetisation
field is perpendicular to the isosurfaces. The color bar on the left
refers to the magnitude of the demagnetisation field which is
expressed in Ampere per meter, as can be seen from the label
<tt class="docutils literal"><span class="pre">&lt;A/m&gt;</span></tt>. (Note that all the <tt class="docutils literal"><span class="pre">H_demag</span></tt> arrows are colored red
as they have identical length.)</p>
</div>
</div>
</div>
<div class="section" id="example-2-computing-the-time-development-of-a-system">
<span id="example-2"></span><h2><a class="toc-backref" href="manual.html#id44">2.2&nbsp;&nbsp;&nbsp;Example 2: Computing the time development of a system</a></h2>
<p>This example computes the time development of the magnetisation in a
bar with (x,y,z) dimensions 30 nm x 30 nm x 100 nm. The initial
magnetisation is pointing in the [1,0,1] direction, i.e. 45 degrees
away from the x axis in the direction of the (long) z-axis. We first
show the simulation code and then discuss it in more detail.</p>
<div class="section" id="mesh-generation">
<h3><a class="toc-backref" href="manual.html#id45">2.2.1&nbsp;&nbsp;&nbsp;Mesh generation</a></h3>
<p>While it is down to the mesh generation software (see also <a class="reference internal" href="manual.html#finite-element-mesh-generation">Finite
element mesh generation</a>) to explain how to generate finite element
meshes, we briefly summarize the steps necessary to create a mesh for
this example in <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a>, and how to convert it into an <tt class="docutils literal"><span class="pre">nmesh</span></tt> mesh.</p>
<ol class="arabic">
<li><p class="first">The finite element method requires the domain of interest to be
broken down into small regions. Such a subdivision of space is
known as a mesh or grid. We use <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> to create this mesh.
Netgen reads a <a class="reference external" href="../example2/bar30_30_100.geo">geometry file</a> describing the
three-dimensional structure. To create the mesh used here,
we can start Netgen and load the geometry file by using the menu:
<tt class="docutils literal"><span class="pre">File-&gt;</span> <span class="pre">Load</span> <span class="pre">Geometry</span></tt>. We then tell Netgen that we like the edge
length to be shorter than 3 by going to <tt class="docutils literal"><span class="pre">Mesh-&gt;Meshing</span> <span class="pre">Options-&gt;Mesh</span> <span class="pre">Size</span></tt>
and enter <tt class="docutils literal"><span class="pre">3.0</span></tt> in the <tt class="docutils literal"><span class="pre">max</span> <span class="pre">mesh-size</span></tt> box. Then a click on the
<tt class="docutils literal"><span class="pre">Generate</span> <span class="pre">Mesh</span></tt> button will generate the mesh. Finally, using
<tt class="docutils literal"><span class="pre">File-&gt;Export</span></tt> will save the mesh as a &quot;<em>neutral</em>&quot; file
(this is the default) under the name <tt class="docutils literal"><span class="pre">bar30_30_100.neutral</span></tt>.
(We provide a <a class="reference external" href="http://nmag.soton.ac.uk/nmag/0.1/manual/example2/bar30_30_100.neutral.gz">gzipped version of this file</a>
for completeness.)</p>
</li>
<li><p class="first">This neutral file needs to be converted into a nmesh file. We do
this using the command:</p>
<pre class="literal-block">
$ nmeshimport --netgen bar30_30_100.neutral bar30_30_100.nmesh.h5
</pre>
<p>By providing the <tt class="docutils literal"><span class="pre">.h5</span></tt> extension, we tell nmeshimport to write a
compressed mesh file which is significantly smaller than an ascii
file (see <a class="reference internal" href="manual.html#mesh-file-size">mesh file size</a>).</p>
</li>
</ol>
<p>The generated mesh looks like this:</p>
<div align="center" class="align-center"><img alt="../example2/bar30_30_100.png" class="align-center" src="../example2/bar30_30_100.png" /></div>
<p>We can examine the mesh using <a class="reference internal" href="manual.html#nmeshpp">nmeshpp</a> to obtain information about
mesh quality, the statistical distribution of edge lengths, the
overall number of points and elements etc.</p>
</div>
<div class="section" id="the-simulation">
<h3><a class="toc-backref" href="manual.html#id46">2.2.2&nbsp;&nbsp;&nbsp;The simulation</a></h3>
<p>Having obtained the mesh file <a class="reference external" href="../example2/bar30_30_100.nmesh.h5">bar30_30_100.nmesh.h5</a>, we can use the
program <a class="reference external" href="../example2/bar30_30_100.py">bar30_30_100.py</a>
to run the simulation:</p>
<blockquote>
<pre class="literal-block">
import nmag
from nmag import SI

mat_Py = nmag.MagMaterial(name=&quot;Py&quot;,
                          Ms=SI(0.86e6,&quot;A/m&quot;),
                          exchange_coupling=SI(13.0e-12, &quot;J/m&quot;),
                          llg_damping=0.5)

sim = nmag.Simulation(&quot;bar&quot;)

sim.load_mesh(&quot;bar30_30_100.nmesh.h5&quot;,
              [(&quot;Py&quot;, mat_Py)],
              unit_length=SI(1e-9,&quot;m&quot;))

sim.set_m([1,0,1])

dt = SI(5e-12, &quot;s&quot;) 

for i in range(0, 61):
    sim.advance_time(dt*i)                  #compute time development

    if i % 10 == 0:			    #every 10 loop iterations, 
        sim.save_data(fields='all')         #save averages and all
                                            #fields spatially resolved
    else:
        sim.save_data()                     #otherwise just save averages


</pre>
</blockquote>
<p>As in <a class="reference internal" href="manual.html#example-demag-field-in-uniformly-magnetised-sphere">Example demag field in uniformly magnetised sphere</a>, we start
by importing nmag and creating the material object.</p>
<pre class="literal-block">
import nmag
from nmag import SI

mat_Py = nmag.MagMaterial(name=&quot;Py&quot;,
                          Ms=SI(0.86e6,&quot;A/m&quot;),
                          exchange_coupling=SI(13.0e-12, &quot;J/m&quot;),
                          llg_damping=0.5)
</pre>
<p>We set the <tt class="docutils literal"><span class="pre">llg_damping</span></tt> parameter to 0.5. As this is a
dimensionless parameter, we can pass a number. Alternatively, we may
give it as <tt class="docutils literal"><span class="pre">SI(0.5)</span></tt>. (Note that in this example, we give the
appropriate physical value for the saturisation magnetisation of
PermAlloy.)</p>
<p>The next line creates the simulation object:</p>
<pre class="literal-block">
sim = nmag.Simulation(&quot;bar&quot;)
</pre>
<p>Here, we provide a name for the simulation, which is <tt class="docutils literal"><span class="pre">bar</span></tt>. This
will be used as the stem of the name of any data files that are being
written. If this name is not specified (as in <a class="reference internal" href="manual.html#example-demag-field-in-uniformly-magnetised-sphere">Example demag field in
uniformly magnetised sphere</a>), it defaults to the name of the file
that contains the script (but without the <tt class="docutils literal"><span class="pre">.py</span></tt> extension).</p>
<p>Next, we load the mesh file, and set the initial (normalised)
magnetisation to point in the <tt class="docutils literal"><span class="pre">[1,0,1]</span></tt> direction, i.e. to have
equal magnitude in the x- and z-direction and 0 in the
y-direction.</p>
<pre class="literal-block">
sim.load_mesh(&quot;bar30_30_100.nmesh.h5&quot;,
              [(&quot;Py&quot;, mat_Py)],
              unit_length=SI(1e-9,&quot;m&quot;))

sim.set_m([1,0,1])
</pre>
<p>This vector will automatically be normalised within nmag, so that
<tt class="docutils literal"><span class="pre">[1,0,1]</span></tt> is equivalent to the normalised vector
<tt class="docutils literal"><span class="pre">[0.70710678,0,0.70710678]</span></tt>.</p>
<p>In this example, we would like to study a dynamic process and will ask
nmag to compute the time development over a certain amount of time
<tt class="docutils literal"><span class="pre">dt</span></tt>. The line:</p>
<pre class="literal-block">
dt = SI(5e-12, &quot;s&quot;)
</pre>
<p>simply creates a <a class="reference internal" href="manual.html#si-object">SI object</a> which represents our timescale.</p>
<p>We then have a Python <tt class="docutils literal"><span class="pre">for</span></tt>-loop in which <tt class="docutils literal"><span class="pre">i</span></tt> will take integer
values ranging from 0 to 60 for subsequent iterations. All indented
lines are the body of the for-loop. (In the Python programming
language, scoping is expressed through indentation rather than braces
or other types of parentheses. Text editors such as Emacs come with
built-in support for properly indenting Python code [by pressing the
<tt class="docutils literal"><span class="pre">Tab</span></tt> key on a line to be indented].)</p>
<pre class="literal-block">
for i in range(0, 61):
    sim.advance_time(dt*i)

    if i % 10 == 0:
        sim.save_data(fields='all')
    else:
        sim.save_data()
</pre>
<p>In each iteration, we first call <tt class="docutils literal"><span class="pre">sim.advance_time(i*dt)</span></tt> which
instructs nmag to carry on time integration up to the time
<tt class="docutils literal"><span class="pre">i*dt</span></tt>.</p>
<p>The call to <a class="reference internal" href="manual.html#save-data">save_data</a> will save the average data into the
<tt class="docutils literal"><span class="pre">bar_dat.ndt</span></tt> file.</p>
<p>The last four lines contain an <tt class="docutils literal"><span class="pre">if</span></tt> statement which is used to save
spatially resolved data every ten time steps only, and averaged data
every time step. The percent operator <tt class="docutils literal"><span class="pre">%</span></tt> computes <tt class="docutils literal"><span class="pre">i</span></tt> modulo
10. This will be 0 when <tt class="docutils literal"><span class="pre">i</span></tt> takes values 0, 10, 20, 30, ... In this
case, we call:</p>
<pre class="literal-block">
sim.save_data(fields='all')
</pre>
<p>which will save the (spatial) averages of all <a class="reference internal" href="manual.html#fields">fields</a> (going into the
<tt class="docutils literal"><span class="pre">bar_dat.ndt</span></tt> file), <em>and</em> the spatially resolved data for all
fields (that are saved to <tt class="docutils literal"><span class="pre">bar_dat.h5</span></tt>).</p>
<p>If <tt class="docutils literal"><span class="pre">i</span></tt> is not an integer multiple of 10, then the command:</p>
<pre class="literal-block">
sim.save_data()
</pre>
<p>is called, which only saves spatially averaged data.</p>
</div>
<div class="section" id="analysing-the-data">
<h3><a class="toc-backref" href="manual.html#id47">2.2.3&nbsp;&nbsp;&nbsp;Analysing the data</a></h3>
<div class="section" id="time-dependent-averages">
<h4>2.2.3.1&nbsp;&nbsp;&nbsp;Time dependent averages</h4>
<p>We first plot the average magnetisation vector against time. To
see what data is available, we call <a class="reference internal" href="manual.html#ncol">ncol</a> with just the name of the
simulation (which here is <tt class="docutils literal"><span class="pre">bar</span></tt>):</p>
<pre class="literal-block">
$ ncol bar
 0:         #time           #&lt;s&gt;              0
 1:            id             &lt;&gt;              1
 2:          step             &lt;&gt;              0
 3:    stage_time            &lt;s&gt;              0
 4:    stage_step             &lt;&gt;              0
 5:         stage             &lt;&gt;              0
 6:    E_total_Py      &lt;kg/ms^2&gt;  -0.2603465789714
 7:           phi            &lt;A&gt;  0.0002507410390772
 8:      E_ext_Py      &lt;kg/ms^2&gt;              0
 9:     H_demag_0          &lt;A/m&gt;  -263661.6680783
10:     H_demag_1          &lt;A/m&gt;  -8.218106743355
11:     H_demag_2          &lt;A/m&gt;  -77027.641984
12:     dmdt_Py_0         &lt;A/ms&gt;  -8.250904652583e+15
13:     dmdt_Py_1         &lt;A/ms&gt;  2.333344983225e+16
14:     dmdt_Py_2         &lt;A/ms&gt;  8.250904652583e+15
15:   H_anis_Py_0          &lt;A/m&gt;              0
16:   H_anis_Py_1          &lt;A/m&gt;              0
17:   H_anis_Py_2          &lt;A/m&gt;              0
18:        m_Py_0             &lt;&gt;  0.7071067811865
19:        m_Py_1             &lt;&gt;              0
20:        m_Py_2             &lt;&gt;  0.7071067811865
21:        M_Py_0          &lt;A/m&gt;  608111.8318204
22:        M_Py_1          &lt;A/m&gt;              0
23:        M_Py_2          &lt;A/m&gt;  608111.8318204
24:     E_anis_Py      &lt;kg/ms^2&gt;              0
25:     E_exch_Py      &lt;kg/ms^2&gt;  5.046530179037e-17
26:           rho        &lt;A/m^2&gt;  0.03469702141876
27:       H_ext_0          &lt;A/m&gt;              0
28:       H_ext_1          &lt;A/m&gt;              0
29:       H_ext_2          &lt;A/m&gt;              0
30:  H_total_Py_0          &lt;A/m&gt;  -263661.6680783
31:  H_total_Py_1          &lt;A/m&gt;  -8.218106743352
32:  H_total_Py_2          &lt;A/m&gt;  -77027.641984
33:    E_demag_Py      &lt;kg/ms^2&gt;  -0.2603465789714
34:   H_exch_Py_0          &lt;A/m&gt;  3.301942533099e-11
35:   H_exch_Py_1          &lt;A/m&gt;              0
36:   H_exch_Py_2          &lt;A/m&gt;  3.301942533099e-11
37: maxangle_m_Py          &lt;deg&gt;              0
38:     localtime             &lt;&gt;  2007/08/15-11:16:19
39:      unixtime            &lt;s&gt;   1187172979.6
</pre>
<p>The meaning of the various entries is discussed in detail in section
<a class="reference internal" href="manual.html#ncol">ncol</a>. Here, we simply note that the column indices (given by the
number at the beginning of every line) we are most interested in are:</p>
<ul class="simple">
<li>0 for the <tt class="docutils literal"><span class="pre">time</span></tt>,</li>
<li>21 for <tt class="docutils literal"><span class="pre">M_Py_0</span></tt> which is the x-component of the magnetisation of
the Py material,</li>
<li>22 for <tt class="docutils literal"><span class="pre">M_Py_1</span></tt> which is the y-component of the magnetisation of
the Py material, and</li>
<li>23 for <tt class="docutils literal"><span class="pre">M_Py_2</span></tt> which is the z-component of the magnetisation of
the Py material,</li>
</ul>
<p>We can use <a class="reference internal" href="manual.html#ncol">ncol</a> to extract this data into a file <tt class="docutils literal"><span class="pre">data_M.dat</span></tt> which
has the time for each time step in the first column and the x, y and z
component of the magnetisation in columns 2, 3 and 4, respectively:</p>
<pre class="literal-block">
$ ncol bar 0 21 22 23 &gt; data_M.txt
</pre>
<p>This creates a text file <a class="reference external" href="../example2/data_M.txt">data_M.txt</a> that
can be read by other applications to create a plot.</p>
<p>Note, however, that the order of the entries in the ndt file is not
guaranteed, i.e. the numbers corresponding to fields may change with
different versions of the software, or different simulations (for
example, the user may add extra fields). Therefore, the recommended
approach is to directly specify the names of the columns that are to be
extracted (i.e. <tt class="docutils literal"><span class="pre">time</span> <span class="pre">M_Py_0</span> <span class="pre">M_Py_1</span> <span class="pre">M_Py_2</span></tt>):</p>
<pre class="literal-block">
$ ncol bar time M_Py_0 M_Py_1 M_Py_2 &gt; data_M.txt
</pre>
<p>We use the <a class="reference external" href="http://plasma-gate.weizmann.ac.il/Grace/">xmgrace</a> command:</p>
<pre class="literal-block">
xmgrace -nxy data_M.txt
</pre>
<p>to create the following plot (manually adding the legend and axis labels):</p>
<div align="center" class="align-center"><img alt="../example2/data_M.png" class="align-center" src="../example2/data_M.png" /></div>
</div>
<div class="section" id="comparison-with-oommf-and-magpar">
<h4>2.2.3.2&nbsp;&nbsp;&nbsp;Comparison with OOMMF and Magpar</h4>
<p>We have carried out the same simulation with <a class="reference external" href="http://magnet.atp.tuwien.ac.at/scholz/magpar/">Magpar</a> and <a class="reference external" href="http://math.nist.gov/oommf/">OOMMF</a>. The
following plot shows the corresponding OOMMF-curves (as spheres)
together with nmag's results. (The Magpar curve, which is not shown
here, follows the nmag data very closely.)</p>
<div align="center" class="align-center"><img alt="../example2/data_M_OOMMF.png" class="align-center" src="../example2/data_M_OOMMF.png" /></div>
</div>
<div class="section" id="spatially-resolved-fields">
<h4>2.2.3.3&nbsp;&nbsp;&nbsp;Spatially resolved fields</h4>
<p>The command <tt class="docutils literal"><span class="pre">sim.save_data(fields='all')</span></tt> saves all <a class="reference internal" href="manual.html#fields">fields</a> into the
file <tt class="docutils literal"><span class="pre">bar_dat.h5</span></tt> (as explained, the filename is composed of the name
of the simulation [here <tt class="docutils literal"><span class="pre">bar</span></tt>] and the extension <tt class="docutils literal"><span class="pre">_dat.h5</span></tt>). The
code <tt class="docutils literal"><span class="pre">bar30_30_100.py</span></tt> above calls the <a class="reference internal" href="manual.html#save-data">save_data</a> command every 10
iterations. As every <tt class="docutils literal"><span class="pre">dt</span></tt> corresponds to 0.5 picoseconds, the
data hence is saved every 5 picoseconds.</p>
<p>We can confirm this by using the <a class="reference internal" href="manual.html#nmagpp">nmagpp</a> command:</p>
<pre class="literal-block">
$ nmagpp --idlist bar
</pre>
<p>which produces the following output:</p>
<pre class="literal-block">
 id   stage   step      time  fields
 0-&gt;    1      0         0 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
10-&gt;    1    312     5e-11 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
20-&gt;    1    495     1e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
30-&gt;    1    603   1.5e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
40-&gt;    1    678     2e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
50-&gt;    1    726   2.5e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
60-&gt;    1    762     3e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
</pre>
<p>The first column is a <a class="reference internal" href="manual.html#unique-identifier-id">unique identifier id</a>  for a configuration of the
system. We can use the <tt class="docutils literal"><span class="pre">--range</span></tt> argument to select entries for
further processing. The <tt class="docutils literal"><span class="pre">stage</span></tt> is only relevant for calculations of
hysteresis curves (see <a class="reference internal" href="manual.html#hysteresis-example">hysteresis example</a>). The <tt class="docutils literal"><span class="pre">step</span></tt> is the
time-stepper iteration counter for this calculation. The time is given
in seconds (<tt class="docutils literal"><span class="pre">&lt;s&gt;</span></tt>). (Note the 5 pico-second interval between
entries.) The stage, step and time data is provided for
convenience. What follows is a list of fields that have been saved for
each of these configurations.</p>
<p>We convert the first saved time step into a vtk file
with base name <tt class="docutils literal"><span class="pre">bar_initial.vtk</span></tt> using</p>
<pre class="literal-block">
$ nmagpp --range 0 --vtk bar_initial.vtk bar
</pre>
<p>and we also convert the last saved time step at 300 picoseconds to a
vtk file with base name <tt class="docutils literal"><span class="pre">bar_final.vtk</span></tt> using:</p>
<pre class="literal-block">
$ nmagpp --range 60 --vtk bar_final.vtk bar
</pre>
<p>The actual file names that are created by these two commands are
<tt class="docutils literal"><span class="pre">bar_initial-000000.vtk</span></tt> and <tt class="docutils literal"><span class="pre">bar_final-000060.vtk</span></tt>. The appended number
is the <tt class="docutils literal"><span class="pre">id</span></tt> of the saved configuration. This is useful if one wants to create vtk files for all saved configurations. For example:</p>
<pre class="literal-block">
$ nmagpp --vtk bar.vtk bar
</pre>
<p>will create the files:</p>
<pre class="literal-block">
bar-000000.vtk
bar-000010.vtk
bar-000020.vtk
bar-000030.vtk
bar-000040.vtk
bar-000050.vtk
bar-000060.vtk
</pre>
<p>Using <a class="reference internal" href="manual.html#mayavi">MayaVi</a>, we can display this data in a variety of ways. Remember
that all field values are shown in SI units by default (see <a class="reference internal" href="manual.html#nmagpp">nmagpp</a>),
and positions are as provided in the mesh file. In this case,
positions are expressed in nanometers (this comes from the
<tt class="docutils literal"><span class="pre">unit_length=SI(1e-9,&quot;m&quot;)</span></tt> expression in the <tt class="docutils literal"><span class="pre">sim.load_mesh()</span></tt>
command.</p>
<p>This is the initial configuration with magnetisation pointing in the
[1,0,1] direction:</p>
<div align="center" class="align-center"><img alt="../example2/bar_initial_M.png" class="align-center" src="../example2/bar_initial_M.png" /></div>
<p>The &quot;final&quot; configuration shows that the magnetisation aligns along
the z-direction. The coloured surface shows the x-component of the
magnetisation (and the colorbar provides the scale). It can be seen
that the magnetisation at position z=100 nm goes into a flower state
to minimise the overall energy. (Note that, strictly speaking, this
system is not yet in a meta-stable state after 300 ps -- but already
quite close.):</p>
<div align="center" class="align-center"><img alt="../example2/bar_final_M.png" class="align-center" src="../example2/bar_final_M.png" /></div>
<p>Because we have saved all fields (not just the magnetisation), we can
also study other properties. For example, the following image shows
the demagnetisation field as vectors (and the legend refers to the
magnitude of the vectors), as well as the magnetic scalar potential
(as a stack of isosurfaces). Because the demagnetisation field is the
(negative) gradient of the scalar potential, the vectors are
perpendicular on the isosurfaces:</p>
<div align="center" class="align-center"><img alt="../example2/bar_final_demag.png" class="align-center" src="../example2/bar_final_demag.png" /></div>
</div>
</div>
<div class="section" id="higher-level-functions">
<h3><a class="toc-backref" href="manual.html#id48">2.2.4&nbsp;&nbsp;&nbsp;Higher level functions</a></h3>
<p>We now have seen an overview over the fundamental commands used to set
up a micromagnetic simulation and demonstrate how to advance the
configuration of the system through time. In principle, this is all
one would need to know to compute hysteresis loops and carry out most
micromagnetic computations. However, there are more advanced functions
that simplify and automatise the most frequent tasks, such as
computing a hysteresis loop.</p>
</div>
<div class="section" id="relaxing-the-system">
<h3><a class="toc-backref" href="manual.html#id49">2.2.5&nbsp;&nbsp;&nbsp;&quot;Relaxing&quot; the system</a></h3>
<p>The <a class="reference internal" href="manual.html#relax">relax</a> command takes the current magnetisation configuration of a
simulation and computes the time development until the torque on each
mesh site is smaller than a certain threshold. This is useful for this
particular example as we do not know for how long we need to integrate
the system until it stops in a local energy minimum configuration. We
can adjust the code of this example to make use of the <tt class="docutils literal"><span class="pre">relax</span></tt>
command (<a class="reference external" href="../example2/bar_relax.py">modified source code</a>):</p>
<pre class="literal-block">
import nmag
from nmag import SI, every, at

mat_Py = nmag.MagMaterial( name=&quot;Py&quot;,
                           Ms=SI(0.86e6, &quot;A/m&quot;),
                           exchange_coupling=SI(13.0e-12, &quot;J/m&quot;),
                           llg_damping=0.5)


sim = nmag.Simulation(&quot;bar_relax&quot;)

sim.load_mesh(&quot;bar30_30_100.nmesh.h5&quot;, [(&quot;Py&quot;, mat_Py)],
              unit_length=SI(1e-9, &quot;m&quot;))

sim.set_m([1, 0, 1])

ps = SI(1e-12,&quot;s&quot;)
sim.relax(save = [('averages', every('time', 5*ps)),
                  ('fields', at('convergence'))])

</pre>
<p>(Note the additions to the <tt class="docutils literal"><span class="pre">import</span></tt> statement!)</p>
<p>The particular <tt class="docutils literal"><span class="pre">relax</span></tt> command employed here:</p>
<pre class="literal-block">
sim.relax(save = [('averages', every('time',5*ps)),
                  ('fields', at('convergence'))])
</pre>
<p>works as follows:</p>
<p>The argument <tt class="docutils literal"><span class="pre">save</span> <span class="pre">=</span> <span class="pre">[</span> <span class="pre">]</span></tt> tells <tt class="docutils literal"><span class="pre">relax</span></tt> to save data according to
the instructions given in the form of a python list (i.e. enclosed by
square brackets). The first relax instruction is this tuple:</p>
<pre class="literal-block">
('averages', every('time',5*ps)
</pre>
<p>and means that the <em>averages</em> should be saved <em>every 50 picoseconds</em>.
The syntax used here breaks down into the following parts:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">'averages'</span></tt> is just the keyword (a string) to say that the
average data should be saved.</li>
<li><tt class="docutils literal"><span class="pre">every(...)</span></tt> is a special object which takes two parameters. They are here:<ul>
<li><tt class="docutils literal"><span class="pre">'time'</span></tt> to indicate that something should be done every time a certain
amount of simulated time has passed, and</li>
<li><tt class="docutils literal"><span class="pre">5*ps</span></tt> which is the amount of time after which the data
should be saved again. This has to be a <a class="reference internal" href="manual.html#si-object">SI object</a>, which we here
obtain by multiplying a number (<tt class="docutils literal"><span class="pre">5</span></tt>) with the SI object <tt class="docutils literal"><span class="pre">ps</span></tt> which
has been defined earlier in our example program to represent a pico-second.</li>
<li>We can provide further keywords to the <tt class="docutils literal"><span class="pre">every</span></tt> object (for example
to save the data every <tt class="docutils literal"><span class="pre">n</span></tt> iteration steps we can use <tt class="docutils literal"><span class="pre">every(10,'step')</span></tt>).</li>
</ul>
</li>
</ul>
</blockquote>
<p>Internally, the <a class="reference internal" href="manual.html#relax">relax</a> command uses the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> command, so the documentation of
<a class="reference internal" href="manual.html#hysteresis">hysteresis</a> should be consulted for a more detailed explanation of parameters.</p>
<p>The second relax instruction is:</p>
<pre class="literal-block">
('fields', at('convergence'))
</pre>
<p>which means that the <em>fields</em> should be saved <em>at convergence</em>,
i.e. when the relaxation process has finished and the magnetisation
has converged to its (meta)stable configuration:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">'fields'</span></tt> is a string that indicates that we would like to save
all the defined fields.</li>
<li><tt class="docutils literal"><span class="pre">at('convergence')</span></tt> is a special object that indicates that this
should happen exactly when the relaxation process has converged.</li>
</ul>
</blockquote>
<p>After running this program, we can use the <a class="reference internal" href="manual.html#ncol">ncol</a> tool to look at
the averages saved:</p>
<pre class="literal-block">
$ ncol bar_relax step time
</pre>
<p>gives output which starts like this:</p>
<pre class="literal-block">
  0              0
 82          5e-12
120          1e-11
146        1.5e-11
176          2e-11
201        2.5e-11
227          3e-11
248        3.5e-11
</pre>
<p>Here, we see the iterations on the left and the simulated time (in
seconds) on the right. As requested, there is one data entry
(i.e. line) every 5 picoseconds.</p>
<p>Note that it may happen that the system saves the data not exactly at
the requested time, i.e.:</p>
<pre class="literal-block">
532        6.5e-11
580  7.047908066945e-11
620        7.5e-11
</pre>
<p>The middle line shows that the data has been saved when the simulated
time was approximately 7.05e-11 seconds whereas we requested 7e-11
seconds. Such small deviations are tolerated by the system to improve
performance <a class="footnote-reference" href="manual.html#id7" id="id6">[3]</a>.</p>
<p>From the data saved, we can obtain the following plot:</p>
<div align="center" class="align-center"><img alt="../example2/bar_relax_data_M.png" class="align-center" src="../example2/bar_relax_data_M.png" /></div>
<p>In summary, the <a class="reference internal" href="manual.html#relax">relax</a> function is useful to obtain a meta-stable
configuration of the system. In particular, it will carry out the time
integration until the remaining torque at any point in the system has
dropped below a certain threshold.</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id6">[3]</a></td><td>The time integrator (here, <a class="reference external" href="http://www.llnl.gov/CASC/sundials/">Sundials</a> CVODE) would have to do an
extra step to get to the requested time. If the current time is
very close to the requested time, it will simply report this value.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="relaxing-the-system-faster">
<h3><a class="toc-backref" href="manual.html#id50">2.2.6&nbsp;&nbsp;&nbsp;&quot;Relaxing&quot; the system faster</a></h3>
<p>If we are only interested in the final (meta-stable) configuration of
a run, we can switch off the precession term in the Laundau Lifshitz
and Gilbert equation. The MagMaterial definition in the following
example shows how to do this:</p>
<pre class="literal-block">
import nmag
from nmag import SI, every, at

mat_Py = nmag.MagMaterial( name=&quot;Py&quot;,
                           Ms=SI(0.86e6, &quot;A/m&quot;),
                           exchange_coupling=SI(13.0e-12, &quot;J/m&quot;),
                           llg_damping=0.5,
                           do_precession=False )


sim = nmag.Simulation(&quot;bar_relax2&quot;)

sim.load_mesh(&quot;bar30_30_100.nmesh.h5&quot;, [(&quot;Py&quot;, mat_Py)],
              unit_length=SI(1e-9, &quot;m&quot;))

sim.set_m([1, 0, 1])

ps = SI(1e-12,&quot;s&quot;)
sim.relax(save = [('averages', every('time', 5*ps)),
                  ('fields', at('convergence'))])

</pre>
<p>The new option is <tt class="docutils literal"><span class="pre">do_precession=False</span></tt> in the constructor of the
PermAlloy material <tt class="docutils literal"><span class="pre">mat_Py</span></tt>. As a result, there will be no
precession term in the equation of motion:</p>
<div align="center" class="align-center"><img alt="../example2/bar_relax2_data_M.png" class="align-center" src="../example2/bar_relax2_data_M.png" /></div>
<p>While the time-development of the system happens at the same time
scale as for the system with the precession term (see <a class="reference internal" href="manual.html#relaxing-the-system">&quot;Relaxing&quot; the
system</a>), the computation of the system without the precession is
significantly faster (for this example, we needed about 3500
iterations with the precession term and 1500 without it, and the
computation time scales similarly).</p>
<p>Note, that the ''dynamics'' shown here are of course artificial and
only used to obtain a meta-stable physical configuration more
efficiently!</p>
</div>
<div class="section" id="decreasing-execution-time">
<h3><a class="toc-backref" href="manual.html#id51">2.2.7&nbsp;&nbsp;&nbsp;Decreasing execution time</a></h3>
<p>Note that the execution time can generally be reduced significantly by
decreasing the tolerances for the time integrator. In short, one has
to use the <a class="reference internal" href="manual.html#set-params">set_params</a> function (after <a class="reference internal" href="manual.html#set-m">set_m</a> has been called).
Decreasing the requested accuracy will of course make the simulation
results less accurate but this is often acceptable. An example of how
to use the <a class="reference internal" href="manual.html#set-m">set_m</a> function and detailed discussion of the
micromagnetic example shown in this section for a variety of tolerance
values is given in the section <a class="reference internal" href="manual.html#example-timestepper-tolerances">Example timestepper tolerances</a>.</p>
</div>
</div>
<div class="section" id="example-simple-hysteresis-loop">
<span id="hysteresis-example"></span><h2><a class="toc-backref" href="manual.html#id52">2.3&nbsp;&nbsp;&nbsp;Example: Simple hysteresis loop</a></h2>
<p>This example computes the hysteresis loop of an ellipsoidal magnetic
object. We use an ellipsoid whose x,y,z semi-axes
have lengths 30 nm, 10 nm and 10 nm, respectively. (The mesh is contained
in <a class="reference external" href="../example_stoner_wohlfarth/ellipsoid.nmesh.h5">ellipsoid.nmesh.h5</a>
and produced with <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> from <a class="reference external" href="../example_hysteresis_ellipsoid/ellipsoid.geo">ellipsoid.geo</a>):</p>
<div align="center" class="align-center"><img alt="../example_hysteresis_ellipsoid/mesh.png" class="align-center" src="../example_hysteresis_ellipsoid/mesh.png" /></div>
<p>This picture has been obtained by converting the mesh to a <a class="reference internal" href="manual.html#vtk">vtk</a> file using:</p>
<pre class="literal-block">
$ nmeshpp --vtk ellipsoid.nmesh.h5 mesh.vtk
</pre>
<p>and subsequent visualisation with <a class="reference internal" href="manual.html#mayavi">Mayavi</a>:</p>
<pre class="literal-block">
$ mayavi -d mesh.vtk -m SurfaceMap
</pre>
<p>We have further added the axes within MayaVi
(Visualize-&gt;Modules-&gt;Axes), and changed the display color from blue to
red (Double lick on <tt class="docutils literal"><span class="pre">SurfaceMap</span></tt> in the selected Modules list, then
uncheck the <tt class="docutils literal"><span class="pre">Scalar</span> <span class="pre">Coloring</span></tt> box, click on <tt class="docutils literal"><span class="pre">Change</span> <span class="pre">Object</span> <span class="pre">Color</span></tt>
and select a suitable color).</p>
<p>We provide the mayavi file <a class="reference external" href="../example_hysteresis_ellipsoid/mesh.mv">mesh.mv</a> that shows the
visulisation as in the figure above. (If you want to load this file
into MayaVi, just use <tt class="docutils literal"><span class="pre">$</span> <span class="pre">mayavi</span> <span class="pre">mesh.mv</span></tt> but make sure that
<tt class="docutils literal"><span class="pre">mesh.vtk</span></tt> is in the same directory as mayavi will need to read
this.)</p>
<div class="section" id="hysteresis-simulation-script">
<h3><a class="toc-backref" href="manual.html#id53">2.3.1&nbsp;&nbsp;&nbsp;Hysteresis simulation script</a></h3>
<p>To compute the hysteresis loop for the ellipsoid, we use the
script <a class="reference external" href="../example_hysteresis_ellipsoid/ellipsoid.py">ellipsoid.py</a>:</p>
<pre class="literal-block">
import nmag
from nmag import SI, at

#create simulation object
sim = nmag.Simulation()

# define magnetic material
Py = nmag.MagMaterial(name=&quot;Py&quot;,
                      Ms=SI(1e6,&quot;A/m&quot;),
                      exchange_coupling=SI(13.0e-12, &quot;J/m&quot;))

# load mesh: the mesh dimensions are scaled by 0.5 nm
sim.load_mesh(&quot;ellipsoid.nmesh.h5&quot;,
              [(&quot;ellipsoid&quot;, Py)],
              unit_length=SI(1e-9,&quot;m&quot;))

# set initial magnetisation
sim.set_m([1.,0.,0.])

Hs = nmag.vector_set(direction=[1.,0.01,0],
                     norm_list=[ 1.00,  0.95, [], -1.00,
                                -0.95, -0.90, [],  1.00],
                     units=1e6*SI('A/m'))

# loop over the applied fields Hs
sim.hysteresis(Hs, save=[('restart','fields', at('convergence'))])


</pre>
<p>As in the previous examples, we first need to import the modules
necessary for the simulatiofgn. <tt class="docutils literal"><span class="pre">at('convergence')</span></tt> allows us to save
the fields and the averages whenever convergence is reached.
We then define the material of the magnetic object, load the mesh and set
the initial configuration of the magnetisation as well as the
external field.</p>
</div>
<div class="section" id="hysteresis-loop-computation">
<h3><a class="toc-backref" href="manual.html#id54">2.3.2&nbsp;&nbsp;&nbsp;Hysteresis loop computation</a></h3>
<p>We apply the external magnetic fields in the x-direction with range of
1e6 A/m down to -1e6 A/m in steps of <tt class="docutils literal"><span class="pre">0.05e6</span> <span class="pre">A/m</span></tt>.</p>
<p>To convey this information efficiently to nmag, we use:</p>
<ol class="arabic simple">
<li>a direction for the applied field (here just <tt class="docutils literal"><span class="pre">[1,0.01,0]</span></tt>), (note
that we have a small y-component of 1% in the applied field to break
the symmetry)</li>
<li>a list of magnitudes of the field that will be multiplied with the
direction vector,</li>
<li>another multiplier that defines the physical dimension of the applied fields
(here <tt class="docutils literal"><span class="pre">1000kA/m</span></tt>, given as <tt class="docutils literal"><span class="pre">1e6*SI('A/m')</span></tt>).</li>
</ol>
<p>Putting all this together, we obtain this command:</p>
<pre class="literal-block">
Hs = nmag.vector_set(direction=[1., 0.01, 0],
                     norm_list=[ 1.00,  0.95, [], -1.00,
                                -0.95, -0.90, [],  1.00],
                     units=1e6*SI('A/m'))
</pre>
<p>which computes a list of vectors <tt class="docutils literal"><span class="pre">Hs</span></tt>. Each entry in the list
corresponds to one applied field.</p>
<p>The <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> command takes this list of applied fields <tt class="docutils literal"><span class="pre">Hs</span></tt> as
one input parameter, and computes the hysteresis loop for these
fields:</p>
<pre class="literal-block">
sim.hysteresis(Hs, save=[('restart', 'fields', at('convergence'))])
</pre>
<p>The <tt class="docutils literal"><span class="pre">save</span></tt> parameter is used to tell the hysteresis command what
data to save, and how often. We have come across this notation when
explaining the <tt class="docutils literal"><span class="pre">relax</span></tt> command in the section <a class="reference internal" href="manual.html#relaxing-the-system">&quot;Relaxing&quot; the
system</a> of the previous example. In the example shown here, we
request that the <em>fields</em> and the <em>restart</em> data should be saved <em>at</em>
the point in time where we reach <em>convergence</em>. (The spatially
averaged data is saved automatically to the <a class="reference internal" href="manual.html#ndt">ndt</a> file when the
<em>fields</em> are saved.) This is done in a compact notation shown above
which is equivalent to this more explicit version:</p>
<pre class="literal-block">
sim.hysteresis(Hs,
               save=[('restart', at('convergence')),
                     ('fields',   at('convergence'))])
</pre>
<p>The compact notation can be used because here we want to save
<em>fields</em> and <em>restart</em> data at the same time.</p>
<p>The <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> command computes the time development of the system
for one applied field until a convergence criterion is met. It then
proceeds to the next external field value provided in <tt class="docutils literal"><span class="pre">Hs</span></tt>.</p>
<p>We run the simulation as usual using:</p>
<pre class="literal-block">
$ nsim ellipsoid.py
</pre>
<p>If you have run the simulation before, we need to use the <tt class="docutils literal"><span class="pre">--clean</span></tt>
switch to enforce overriding of existing data files:</p>
<pre class="literal-block">
$ nsim ellipsoid.py --clean
</pre>
<p>The simulation should take only a few minutes (for example 3 minutes
on an Athlon64 3800+), and needs about 75MB of RAM.</p>
<p>If the simulation has been interrupted, it can be continued using</p>
<blockquote>
$ nsim ellipsoid.py --restart</blockquote>
</div>
<div class="section" id="obtaining-the-hysteresis-loop-data">
<h3><a class="toc-backref" href="manual.html#id55">2.3.3&nbsp;&nbsp;&nbsp;Obtaining the hysteresis loop data</a></h3>
<p>Once the calculation has finished, we can plot the graph of the
magnetisation (projected along the direction of the applied field) as a
function of the applied field.</p>
<p>We use the <a class="reference internal" href="manual.html#ncol">ncol</a> command to extract the data into a text file named <a class="reference external" href="../example_hysteresis_ellipsoid/plot.dat">plot.dat</a>:</p>
<pre class="literal-block">
$ ncol ellipsoid H_ext_0 m_Py_0 &gt; plot.dat
</pre>
</div>
<div class="section" id="plotting-the-hysteresis-loop-with-gnuplot">
<h3><a class="toc-backref" href="manual.html#id56">2.3.4&nbsp;&nbsp;&nbsp;Plotting the hysteresis loop with Gnuplot</a></h3>
<p>In this example, rather than using <a class="reference external" href="http://plasma-gate.weizmann.ac.il/Grace/">xmgrace</a>, we show how to plot data
using <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a>:</p>
<pre class="literal-block">
$ gnuplot make_plot.gnu
</pre>
<p>The contents of the gnuplot script <a class="reference external" href="../example_hysteresis_ellipsoid/make_plot.gnu">make_plot.gnu</a> are:</p>
<pre class="literal-block">
set term postscript eps enhanced color
set out 'hysteresis.eps'
set xlabel 'Applied field H_x 	(A/m)'
set ylabel 'M_x / M_s'
set xrange [-1050000:1050000]
set yrange [-1.2:1.2]
plot 'plot.dat' u 1:2 ti 'ellipsoid example' w lp 3
</pre>
<p>which generates the following hysteresis loop graph:</p>
<div align="center" class="align-center"><img alt="../example_hysteresis_ellipsoid/hysteresis.png" class="align-center" src="../example_hysteresis_ellipsoid/hysteresis.png" /></div>
</div>
</div>
<div class="section" id="example-hysteresis-loop-for-stoner-wohlfarth-particle">
<span id="stoner-wohlfarth-example"></span><h2><a class="toc-backref" href="manual.html#id57">2.4&nbsp;&nbsp;&nbsp;Example: Hysteresis loop for Stoner-Wohlfarth particle</a></h2>
<p>This example is very similar to <a class="reference internal" href="manual.html#example-simple-hysteresis-loop">Example: Simple hysteresis loop</a> but
computes the hysteresis loop of a smaller ellipsoidal magnetic
object. This allows to compare the results with the analytical
solution given by the Stoner-Wohlfarth model.  We use an ellipsoid
whose x,y,z semi-axes have lengths 9 nm, 3 nm and 3 nm,
respectively. (The mesh is contained in <a class="reference external" href="../example_stoner_wohlfarth/ellipsoid.nmesh.h5">ellipsoid.nmesh.h5</a> and produced with
<a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> from <a class="reference external" href="../example_stoner_wohlfarth/ellipsoid.geo">ellipsoid.geo</a>):</p>
<div align="center" class="align-center"><img alt="../example_stoner_wohlfarth/ellipsoid_mesh.png" class="align-center" src="../example_stoner_wohlfarth/ellipsoid_mesh.png" /></div>
<p>To compute the hysteresis loop for the ellipsoid, we use the
script <a class="reference external" href="../example_stoner_wohlfarth/ellipsoid.py">ellipsoid.py</a>:</p>
<pre class="literal-block">
import nmag
from nmag import SI, at

#create simulation object
sim = nmag.Simulation()

# define magnetic material
Py = nmag.MagMaterial(name=&quot;Py&quot;,
                      Ms=SI(1e6,&quot;A/m&quot;),
                      exchange_coupling=SI(13.0e-12, &quot;J/m&quot;))

# load mesh: the mesh dimensions are scaled by 0.5 nm
sim.load_mesh(&quot;ellipsoid.nmesh.h5&quot;,
              [(&quot;ellipsoid&quot;, Py)],
              unit_length=SI(1e-9,&quot;m&quot;))

# set initial magnetisation
sim.set_m([1.,1.,0.])

Hs = nmag.vector_set(direction=[1.,1.,0.],
                     norm_list=[1.0, 0.995, [], -1.0,
		                -0.995, -0.990, [], 1.0],
                     units=1e6*SI('A/m'))

# loop over the applied fields Hs
sim.hysteresis(Hs, save=[('averages', at('convergence'))])


</pre>
<p>We apply external magnetic fields in [110] direction (i.e. 45 degrees
between the x and the y-axis) to this system, with strengths in the
range of 1000 kA/m down to -1000 kA/m in steps of <tt class="docutils literal"><span class="pre">5</span> <span class="pre">kA/m</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">save</span></tt> parameter is used to tell the hysteresis command what
data to save, and how often. Here, we are only interested in saving
the spatially averaged magnetisation values for every stage (i.e.
meta-stable equilibrium before the applied field is changed).</p>
<div class="section" id="plotting-the-hysteresis-loop">
<h3><a class="toc-backref" href="manual.html#id58">2.4.1&nbsp;&nbsp;&nbsp;Plotting the hysteresis loop</a></h3>
<p>To extract the data needed for plotting the hysteresis loop
we proceed as explained in the previous
example <a class="reference internal" href="manual.html#example-simple-hysteresis-loop">Example: Simple hysteresis loop</a>.
We use the <a class="reference internal" href="manual.html#ncol">ncol</a> command and extract the data into a text file
named <a class="reference external" href="../example_stoner_wohlfarth/plot.dat">plot.dat</a>:</p>
<pre class="literal-block">
$ ncol ellipsoid H_ext_0 H_ext_1 H_ext_2 m_Py_0 m_Py_1 m_Py_2 &gt; plot.dat
</pre>
<p>We then use <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> to plot the loop:</p>
<pre class="literal-block">
$ gnuplot make_plot.gnu
</pre>
<p>The gnuplot script <a class="reference external" href="../example_stoner_wohlfarth/make_plot.gnu">make_plot.gnu</a> is:</p>
<pre class="literal-block">
set term postscript eps enhanced color
set out 'hysteresis.eps'
set xlabel 'Applied field (kA/m)'
set ylabel 'M / Ms'
versor_x = 1/sqrt(2)
versor_y = 1/sqrt(2)
versor_z = 0.0
scalar_prod(x1,x2,x3) = x1*versor_x + x2*versor_y + x3*versor_z

set mxtics 5            # minor tics and grid
set ytics 1
set mytics 5
set grid xtics ytics mxtics mytics lt -1 lw 0.5, lt 0
plot [-1050:1050] [-1.2:1.2] \
  'plot.dat' u (scalar_prod($1,$2,$3)/1000):(scalar_prod($4,$5,$6)) t 'Stoner-Wohlfarth' w lp 4


</pre>
<p>Note that within the gnuplot file, we project the magnetisation data
in the <tt class="docutils literal"><span class="pre">[1,1,0]</span></tt> direction because the applied field was acting
in this direction. We obtain this hysteresis loop:</p>
<div align="center" class="align-center"><img alt="../example_stoner_wohlfarth/hysteresis.png" class="align-center" src="../example_stoner_wohlfarth/hysteresis.png" /></div>
<p>The coercive field, which is located somewhere between 165 and 170
kA/m, can now be compared with the analytically known result for this
particular system. To compute it, we need the demagnetizing factors
Nx, Ny, Nz of the particle along the main axes. Since we deal with a
prolate ellipsoid where two of the axes have the same dimension (y and
z in this case), it is sufficient to compute the factor along the
longest axis (x axis). The other two are easily derived from the
relation Nx + Ny + Nz = 1.  The expression to compute Nx is</p>
<div align="center" class="figure">
<img alt="../example_stoner_wohlfarth/demag_nz.png" src="../example_stoner_wohlfarth/demag_nz.png" />
</div>
<p>where we call the length of the x semi-axis <tt class="docutils literal"><span class="pre">a</span></tt>, the length of the y
(or z) semi-axis <tt class="docutils literal"><span class="pre">c</span></tt>, and take <tt class="docutils literal"><span class="pre">m</span></tt> to be the ratio
<tt class="docutils literal"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">a/c</span></tt>. Here, the value of Nx is therefore 0.1087, so we have
Ny = Nz = 0.4456. With these values the shape anisotropy is easily
computed according to the expression:</p>
<div align="center" class="figure">
<img alt="../example_stoner_wohlfarth/Ha.png" src="../example_stoner_wohlfarth/Ha.png" />
</div>
<p>This gives Ha = 337 kA/m in the case of Ms = 1000 kA/m.  The final
step is to compute the coercive field hc using this analytical
(Stoner-Wohlfarth) result:</p>
<div align="center" class="figure">
<img alt="../example_stoner_wohlfarth/hc.png" src="../example_stoner_wohlfarth/hc.png" />
</div>
<p>Here, theta_0 is the angle between the easy-axis of the particle
(x-axis in our case) and the direction of the applied
field. Substituting theta_0 = 45 (degrees) in the formula, we obtain
hc = 0.5, that is Hc = 0.5 * Ha = 168 kA/m.  As we have seen before,
the simulated hysteresis loop gives a value between 165 and 170 kA/m,
which is in agreement with the analytical solution.</p>
<p>Note that this simulation is relatively slow due to a number of
constraints: to get good Stoner-Wolfarth behaviour, we need to
describe the shape of the ellipsoid well, and thus need a small
edgelength when we generate the mesh. We further need uniform
behaviour of the magnetisation, which limits the overall size of the
ellipsoid. A general property of micromagnetic simulations is that the
associated differential equations get stiffer if the edge lengths (or
more generally: distances between neighbouring degrees of freedom)
become smaller. Stiffer systems of differential equations are harder
to intergrate, and thus take more time.</p>
</div>
</div>
<div class="section" id="example-hysteresis-loop-for-thin-disk">
<span id="hysteresis-loop-for-thin-disk-example"></span><h2><a class="toc-backref" href="manual.html#id59">2.5&nbsp;&nbsp;&nbsp;Example: Hysteresis loop for thin disk</a></h2>
<p>This example computes the hysteresis loop of a flat disc magnetised
along a direction orthogonal to the main axis. In comparison to the
previous <a class="reference internal" href="manual.html#stoner-wohlfarth-example">Stoner-Wohlfarth example</a>, it demonstrates the use of a
more complex sequence of applied fields.</p>
<p>We use a disc 20 nm thick and 200 nm in diameter for this example (the
mesh is contained in <a class="reference external" href="../example_hysteresis_disk/nanodot1.nmesh.h5">nanodot1.nmesh.h5</a>
which is created from <a class="reference external" href="../example_hysteresis_disk/the_nanodot.geo">the_nanodot.geo</a> with <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a>):</p>
<div align="center" class="align-center"><img alt="../example_hysteresis_disk/nanodot1_mesh.png" class="align-center" src="../example_hysteresis_disk/nanodot1_mesh.png" /></div>
<p>To compute the hysteresis loop for the disc, we use the script
<a class="reference external" href="../example_hysteresis_disk/nanodot1.py">nanodot1.py</a>:</p>
<pre class="literal-block">
import nmag
from nmag import SI, at

#create simulation object
sim = nmag.Simulation()

# define magnetic material
Py = nmag.MagMaterial( name=&quot;Py&quot;,
                       Ms=SI(795774,&quot;A/m&quot;),
                       exchange_coupling=SI(13.0e-12, &quot;J/m&quot;)
                     )

# load mesh: the mesh dimensions are scaled by 100nm
sim.load_mesh( &quot;nanodot1.nmesh.h5&quot;,
               [(&quot;cylinder&quot;, Py)],
               unit_length=SI(100e-9,&quot;m&quot;)
             )

# set initial magnetisation
sim.set_m([1.,0.,0.])

Hs = nmag.vector_set( direction=[1.,0.,0.],
                      norm_list=[1000.0, 900.0, [],
                                 95.0, 90.0, [],
                                 -100.0, -200.0, [],
                                 -1000.0, -900.0, [],
                                 -95.0, -90.0, [],
                                 100.0, 200.0, [], 1000.0],
                      units=1e3*SI('A/m')
                    )


# loop over the applied fields Hs
sim.hysteresis(Hs,
               save=[('averages', 'fields', 'restart', at('convergence'))]
               )


</pre>
<p>We assume that the previous example have been sufficiently instructive
to explain the basic steps such as importing nmag, creating a
simulation object, defining the material and leading the mesh. Here,
we focus on the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> command:</p>
<p>We would like to apply fields ranging from <tt class="docutils literal"><span class="pre">[1e6,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt> to
<tt class="docutils literal"><span class="pre">[100e3,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt> in steps of <tt class="docutils literal"><span class="pre">100e3</span> <span class="pre">A/m</span></tt>. Then, from <tt class="docutils literal"><span class="pre">[95e3,</span>
<span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt> to <tt class="docutils literal"><span class="pre">[-95e3,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt> we would like to use a smaller
step size of <tt class="docutils literal"><span class="pre">5e3</span> <span class="pre">A/m</span></tt> (to resolve this applied field range better).</p>
<p>This will take us through zero applied field (<tt class="docutils literal"><span class="pre">[0,0,0]</span> <span class="pre">A/m</span></tt>). Now,
symmetrically to the positive field values, we would like to use a
step size of <tt class="docutils literal"><span class="pre">100e3</span> <span class="pre">A/m</span></tt> again to go from <tt class="docutils literal"><span class="pre">[-100e3,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt> to
<tt class="docutils literal"><span class="pre">[-1e6,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt>. At this point, we would like to reverse the whole
sequence (to sweep the field back to the initial value).</p>
<p>The information we need for the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> command includes:</p>
<ol class="arabic">
<li><p class="first">a direction for the applied field (here just <tt class="docutils literal"><span class="pre">[1,0,0]</span></tt>),</p>
</li>
<li><p class="first">a list of magnitudes of the field (this is the <tt class="docutils literal"><span class="pre">norm_list</span></tt>) that
will be interpreted, and then multiplied with the direction vector,</p>
<p>As in the <a class="reference internal" href="manual.html#example-simple-hysteresis-loop">Example: Simple hysteresis loop</a> and in the
<a class="reference internal" href="manual.html#stoner-wohlfarth-example">Stoner-Wohlfarth example</a>, we employ a special notation for
ranges of field strengths understood by <tt class="docutils literal"><span class="pre">nmag.vector_set</span></tt>.  The
expression:</p>
<pre class="literal-block">
[1000.0, 900.0, [], 95.0]
</pre>
<p>means that we start with a magnitude of 1000, the next magnitude is
900. The empty brackets (<tt class="docutils literal"><span class="pre">[]</span></tt>) indicate that this sequence should
be continued (i.e. 800, 700, 600, 500, 400, 300, 200, 100) up to but
not beyond the next value given (i.e. 95).</p>
</li>
<li><p class="first">another multiplier that defines the strength of the applied fields
(here, <tt class="docutils literal"><span class="pre">1e3*SI('A/m')</span></tt>).</p>
</li>
</ol>
<p>The corresponding command is:</p>
<pre class="literal-block">
Hs = nmag.vector_set( direction=[1,0,0],
                      norm_list=[1000.0, 900.0, [],
                                   95.0, 90.0, [],
                                 -100.0, -200.0, [],
                                 -1000.0, -900.0, [],
                                 -95.0, -90.0, [],
                                 100.0, 200.0, [], 1000.0],
                      units=1e6*SI('A/m')
                    )
</pre>
<p>which computes a list of vectors <tt class="docutils literal"><span class="pre">Hs</span></tt>. The <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> command takes
this list of applied fields <tt class="docutils literal"><span class="pre">Hs</span></tt> as one input parameter, and will
compute the hysteresis loop for these fields:</p>
<pre class="literal-block">
sim.hysteresis(Hs,
               save=[('averages', 'fields', 'restart', at('convergence'))]
              )
</pre>
<p>Again, the second parameter (<tt class="docutils literal"><span class="pre">save</span></tt>) is used to tell the hysteresis
command what data to save, and how often. We request that the
<em>averages</em> of the fields, the <em>fields</em> and the <em>restart</em> data
should be saved <em>at</em> those points in time where we reach <em>convergence</em>.
(See also <a class="reference internal" href="manual.html#restart-example">restart example</a>).</p>
<div class="section" id="thin-disk-hysteresis-loop">
<h3><a class="toc-backref" href="manual.html#id60">2.5.1&nbsp;&nbsp;&nbsp;Thin disk hysteresis loop</a></h3>
<p>Once the calculation has finished, we can plot the hysteresis loop,
i.e. the graph of the magnetisation computed along the direction of
the applied field as a function of the applied field strength.</p>
<p>We use the <a class="reference internal" href="manual.html#ncol">ncol</a> command to extract the data into a text file <a class="reference external" href="../example_hysteresis_disk/plot.dat">plot.dat</a>:</p>
<pre class="literal-block">
$ ncol nanodot1 H_ext_0 m_Py_0 &gt; plot.dat
</pre>
<p>This file starts as follows:</p>
<pre class="literal-block">
      1000000  0.9995058139817 
      1000000  0.9995058139817 
       900000  0.9994226410102 
       900000  0.9994226410102 
       800000  0.9993139080655 

</pre>
<p>We use <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> to plot the hysteresis loop:</p>
<pre class="literal-block">
$ gnuplot make_plot.gnu
</pre>
<p>using the gnuplot script <a class="reference external" href="../example_hysteresis_disk/make_plot.gnu">make_plot.gnu</a>:</p>
<pre class="literal-block">
set term postscript eps enhanced color
set out 'nanodot_hyst.eps'
set xlabel 'Applied field (A/m)'
set ylabel 'M / Ms'
set xrange [-1.2e6:1.2e6]
set yrange [-1.2:1.2]
plot 'plot.dat' u 1:2 ti 'nmag' with linespoints lw 3 pt 5

</pre>
<p>The resulting graph is:</p>
<div align="center" class="align-center"><img alt="../example_hysteresis_disk/nanodot_hyst.png" class="align-center" src="../example_hysteresis_disk/nanodot_hyst.png" /></div>
<p>and the comparison with the <a class="reference external" href="http://magnet.atp.tuwien.ac.at/scholz/magpar/">Magpar</a> data, obtained with the
script <a class="reference external" href="../example_hysteresis_disk/make_comparison_plot.gnu">make_comparison_plot.gnu</a>:</p>
<pre class="literal-block">
set term postscript eps enhanced color
set out 'nanodot_comparison_hyst.eps'
set xlabel 'Applied field (kA/m)'
set ylabel 'M / Ms'
set xrange [-0.2e3:0.2e3]
set yrange [-1.2:1.2]
plot 'plot.dat' u ($1/1000):2  ti 'nmag' w lp 3, 'magpar.dat' u 1:2  ti 'magpar' w p 4

</pre>
<p>is shown here (note that the <a class="reference external" href="http://magnet.atp.tuwien.ac.at/scholz/magpar/">Magpar</a> computation only shows half of
the hysteresis loop.):</p>
<div align="center" class="align-center"><img alt="../example_hysteresis_disk/nanodot_comparison_hyst.png" class="align-center" src="../example_hysteresis_disk/nanodot_comparison_hyst.png" /></div>
<p>Here we can see a slight difference between nmag and <a class="reference external" href="http://magnet.atp.tuwien.ac.at/scholz/magpar/">Magpar</a> in the
location of the switching point, probably due to different tolerances
in both programs when determining time integrator convergence.</p>
<!-- comment:
.. _`example vortex`: -->
</div>
</div>
<div class="section" id="example-vortex-formation-and-propagation-in-disk">
<h2><a class="toc-backref" href="manual.html#id61">2.6&nbsp;&nbsp;&nbsp;Example: Vortex formation and propagation in disk</a></h2>
<p>This example computes the evolution of a vortex in a flat cylinder
magnetised along a direction orthogonal to the main axis.</p>
<p>We use the same geometry as in the <a class="reference internal" href="manual.html#hysteresis-loop-for-thin-disk-example">Hysteresis loop for thin
disk example</a>: a flat cylinder, 20 nm thick and 200 nm in diameter (the mesh
is contained in <a class="reference external" href="../example_vortex/nanodot.nmesh.h5">nanodot.nmesh.h5</a>):</p>
<div align="center" class="align-center"><img alt="../example_vortex/nanodot_mesh.png" class="align-center" src="../example_vortex/nanodot_mesh.png" style="width: 15cm;" /></div>
<p>To simulate the magnetised disc, we use the following
script (<a class="reference external" href="../example_vortex/nanodot.py">nanodot.py</a>):</p>
<pre class="literal-block">
import nmag
from nmag import SI, at

#create simulation object
sim = nmag.Simulation()

# define magnetic material
Py = nmag.MagMaterial( name=&quot;Py&quot;,
                       Ms=SI(795774,&quot;A/m&quot;),
                       exchange_coupling=SI(13.0e-12, &quot;J/m&quot;)
                     )

# load mesh: the mesh dimensions are scaled by 100nm
sim.load_mesh( &quot;../example_vortex/nanodot.nmesh.h5&quot;,
               [(&quot;cylinder&quot;, Py)],
               unit_length=SI(100e-9,&quot;m&quot;)
             )

# set initial magnetisation
sim.set_m([1.,0.,0.])

Hs = nmag.vector_set( direction=[1.,0.,0.],
                      norm_list=[12.0, 7.0, [], -200.0],
                      units=1e3*SI('A/m')
                    )


# loop over the applied fields Hs
sim.hysteresis(Hs,
               save=[('averages', at('convergence')),
                     ('fields',   at('convergence')),
		     ('restart',  at('convergence')) 
                    ]
               )


</pre>
<p>We would like to compute the magnetisation behaviour in the applied
fields ranging from <tt class="docutils literal"><span class="pre">[12e3,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt> to <tt class="docutils literal"><span class="pre">[-200e3,</span> <span class="pre">0,</span> <span class="pre">0]</span> <span class="pre">A/m</span></tt> in
steps of <tt class="docutils literal"><span class="pre">-5e3</span> <span class="pre">A/m</span></tt>. The command for this is:</p>
<pre class="literal-block">
Hs = nmag.vector_set( direction=[1,0,0],
                      norm_list=[12.0, 7.0, [], -200.0],
                      units=1e3*SI('A/m')
                    )

sim.hysteresis(Hs,
               save=[('averages', at('convergence')),
                     ('fields',   at('convergence')),
                     ('restart',  at('convergence'))
                    ]
              )
</pre>
<p>The <a class="reference internal" href="manual.html#ncol">ncol</a> command allows us to extract the data and we redirect it to
a text file with name <a class="reference external" href="../example_vortex/nmag.dat">nmag.dat</a>:</p>
<pre class="literal-block">
$ ncol nanodot H_ext_0 m_Py_0 &gt; nmag.dat
</pre>
<p>Plotting the data with <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a>:</p>
<pre class="literal-block">
$ gnuplot make_comparison_plot.gnu
</pre>
<p>which uses the script in <a class="reference external" href="../example_vortex/make_comparison_plot.gnu">make_comparison_plot.gnu</a>:</p>
<pre class="literal-block">
set term postscript eps enhanced color	
set out 'nanodot_evo.eps'
set xlabel 'Applied field (kA/m)'
set ylabel 'M / M_s'
plot [-250:50] [-1.2:1.2] 'magpar.dat' u 2:3 ti 'magpar' w lp 4 , 'nmag.dat' u ($1/1000):2  ti 'nmag' w lp 3


</pre>
<p>The resulting graph is shown here:</p>
<div align="center" class="align-center"><img alt="../example_vortex/nanodot_evo.png" class="align-center" src="../example_vortex/nanodot_evo.png" /></div>
<p>and we can see that the results from <a class="reference internal" href="manual.html#nsim">nsim</a> match those from <a class="reference external" href="http://magnet.atp.tuwien.ac.at/scholz/magpar/">magpar</a>
. The magnetisation configurations during the switching process are
shown in the following snapshots:</p>
<div align="center" class="figure">
<img alt="nanodot-1" src="../example_vortex/nanodot-1.png" />
<p class="caption">Magnetisation configuration for a decreasing applied field of 20 kA/m. The x-axis is increasing from left to right for this and the subsequent plots.</p>
</div>
<div align="center" class="figure">
<img alt="nanodot-2" src="../example_vortex/nanodot-2.png" />
<p class="caption">Magnetisation configuration for a decreasing applied field of 15 kA/m.</p>
</div>
<div align="center" class="figure">
<img alt="nanodot-3" src="../example_vortex/nanodot-3.png" />
<p class="caption">Magnetisation configuration for a decreasing applied field of 10 kA/m.</p>
</div>
<div align="center" class="figure">
<img alt="nanodot-4" src="../example_vortex/nanodot-4.png" />
<p class="caption">Magnetisation configuration for a decreasing applied field of -30 kA/m.</p>
</div>
<div align="center" class="figure">
<img alt="nanodot-5" src="../example_vortex/nanodot-5.png" />
<p class="caption">Magnetisation configuration for a decreasing applied field of -95 kA/m.</p>
</div>
<div align="center" class="figure">
<img alt="nanodot-6" src="../example_vortex/nanodot-6.png" />
<p class="caption">Magnetisation configuration for a decreasing applied field of -100 kA/m.</p>
</div>
<p>We see that during magnetisation reversal a vortex nucleates on the
boundary of the disc when the field is sufficiently decreased from its
saturation value. As the field direction is aligned with the x-axis,
the vortex appears in the disc region with the largest y component,
and it moves downwards towards the centre along the y-axis. With a
further decrease of the applied field the vortex moves towards the
opposite side of the disc with respect to the nucleation position, and
it is eventually expelled when the magnetisation aligns with the field
direction over all the disc.</p>
<!-- comment:
.. _`Example manipulating magnetisation`: -->
</div>
<div class="section" id="example-manipulating-magnetisation">
<h2><a class="toc-backref" href="manual.html#id62">2.7&nbsp;&nbsp;&nbsp;Example: Manipulating magnetisation</a></h2>
<p>There are two basic techniques to modify the magnetisation: on the one
hand, we can use the <a class="reference internal" href="manual.html#set-m">set_m</a> method to replace the current
magnetisation configuration with a new one. We can use <a class="reference internal" href="manual.html#set-m">set_m</a> to specify
both homogeneous (see <a class="reference internal" href="manual.html#setting-the-initial-magnetisation">Setting the initial magnetisation</a>)
and non-homogeneous magnetisations (see the <a class="reference internal" href="manual.html#spin-waves-example">Spin-waves example</a>).
Alternatively, we can selectively change magnetic moments at individual mesh sites.
This example demonstrates how to use the latter technique.</p>
<p>The basics of this system are as in <a class="reference internal" href="manual.html#id5">Example: Demag field in uniformly
magnetised sphere</a>: we study a ferromagnetic sphere with initially
homogeneous magnetisation. The corresponding script file is
<a class="reference external" href="../example_manipulate/sphere_manipulate.py">sphere_manipulate.py</a></p>
<pre class="literal-block">
import nmag
from nmag import SI

# Create simulation object
sim = nmag.Simulation()

# Define magnetic material
Py = nmag.MagMaterial(name=&quot;Py&quot;,
                      Ms=SI(1e6, &quot;A/m&quot;),
                      exchange_coupling=SI(13.0e-12, &quot;J/m&quot;))

# Load mesh
sim.load_mesh(&quot;sphere1.nmesh.h5&quot;, [(&quot;sphere&quot;, Py)], unit_length=SI(1e-9, &quot;m&quot;))

# Set initial magnetisation
sim.set_m([1, 0, 0])

# Set external field
sim.set_H_ext([0, 0, 0], SI(&quot;A/m&quot;))

# Save and display data in a variety of ways
# Step 1: save all fields spatially resolved

sim.save_data(fields='all')

# Step 2: sample demag field through sphere
for i in range(-10, 11):
    x = i*1e-9                      # position in metres
    H_demag = sim.probe_subfield_siv('H_demag', [x, 0, 0])
    print &quot;x =&quot;, x, &quot;: H_demag = &quot;, H_demag

# Step 3: sample exchange field through sphere
for i in range(-10, 11):
    x = i*1e-9                      # position in metres
    H_exch_Py = sim.probe_subfield_siv('H_exch_Py', [x, 0, 0])
    print &quot;x =&quot;, x, &quot;: H_exch_Py = &quot;, H_exch_Py


# Now modify the magnetisation at position (0,0,0) (this happens to be
# node 0 in the mesh) in steps 4 to 6:

# Step 4: request a vector with the magnetisation of all sites in the mesh
myM = sim.get_subfield('m_Py')

# Step 5:  We modify the first entry:
myM[0] = [0, 1, 0]

# Step 6: Set the magnetisation to the new (modified) values
sim.set_m(myM)

# Step 7: saving the fields again (so that we can later plot the demag
# and exchange field)
sim.save_data(fields='all') 

# Step 8: sample demag field through sphere (as step 2)
for i in range(-10, 11):
    x = i*1e-9                      # position in metres
    H_demag = sim.probe_subfield_siv('H_demag', [x, 0, 0])
    print &quot;x =&quot;, x, &quot;: H_demag = &quot;, H_demag

# Step 9: sample exchange field through sphere (as step 3)
for i in range(-10, 11):
    x = i*1e-9                      # position in metres
    H_exch_Py = sim.probe_subfield_siv('H_exch_Py', [x, 0, 0])
    print &quot;x =&quot;, x, &quot;: H_exch_Py = &quot;, H_exch_Py

</pre>
<p>To execute this script, we have to give its name to the <a class="reference internal" href="manual.html#nsim">nsim</a>
executable, for example (on linux):</p>
<pre class="literal-block">
$ nsim sphere_manipulate.py
</pre>
<p>After having created the simulation object, defined the material,
loaded the mesh, set the initial magnetisation and the external field,
we save the data the first time (Step 1).</p>
<p>We could visualise the magnetisation and all other fields as described
in <a class="reference internal" href="manual.html#id5">Example: Demag field in uniformly magnetised sphere</a>, and would
obtain the same figures as shown in section
<a class="reference internal" href="manual.html#saving-spatially-resolved-data">Saving spatially resolved data</a>.</p>
<p>In step 2, we probe the demag field at positions along a line going
from [-10,0,0]nm to [10,0,0]nm, and then print the values. This
produces the following output:</p>
<pre class="literal-block">
x = -1e-08 : H_demag =  None
x = -9e-09 : H_demag =  [-329656.18892701436, 131.69946810517845, 197.13873034397167]
x = -8e-09 : H_demag =  [-329783.31649797881, 68.617197264295427, 140.00328871543459]
x = -7e-09 : H_demag =  [-329842.17628131888, 183.37401011699876, 163.01612229436262]
x = -6e-09 : H_demag =  [-329904.84956877632, 133.62473797637142, 74.090532749764847]
x = -5e-09 : H_demag =  [-329974.43178624194, 85.517390832982983, -13.956465964930704]
x = -4e-09 : H_demag =  [-330002.69224229571, 64.187663119270084, -30.832135394870004]
x = -3e-09 : H_demag =  [-330006.79488959321, 25.479055440690821, -61.958073893954818]
x = -2e-09 : H_demag =  [-330020.18327401817, 11.70722487517595, -58.143562276077219]
x = -1e-09 : H_demag =  [-330025.52325345919, -5.7120648683347452, -52.237341988696294]
x = 0.0    : H_demag =  [-330028.67095553532, -25.707310077918752, -46.346108473560378]
x = 1e-09  : H_demag =  [-330058.98559210222, -37.699378078580203, -41.167364094137213]
x = 2e-09  : H_demag =  [-330089.30022866925, -49.691446079241658, -35.988619714714041]
x = 3e-09  : H_demag =  [-330145.36618529289, -63.819285767062581, -22.213920341440794]
x = 4e-09  : H_demag =  [-330220.13307247689, -76.54950394725968, -5.0509172407556262]
x = 5e-09  : H_demag =  [-330298.69089200837, -90.534514175273259, 13.57279800234617]
x = 6e-09  : H_demag =  [-330375.34327985492, -117.01128011426778, 35.262477275758371]
x = 7e-09  : H_demag =  [-330415.38940687838, -123.68558207391983, 60.580352625726341]
x = 8e-09  : H_demag =  [-330474.37719032855, -112.22952205433305, 106.13032196062491]
x = 9e-09  : H_demag =  [-330499.64039893239, -69.97070465326442, 160.41688110297264]
x = 1e-08  : H_demag =  [-330518.649930441, -26.536490670368085, 212.32392103651733]
</pre>
<p>The data is approximately 1/3 Ms = 333333 (A/m) in the direction of the
magnetisation, and approximately zero in the other directions, as we
would expect in a homogeneously magnetised sphere. The deviations we
see are due to (i) the shape of the sphere not being perfectly
resolved (<em>ie</em> we actually look at the demag field of a polyhedron)
and (ii) numerical errors.</p>
<p>In step 3, we probe the exchange field along the same line. The
exchange field is effectively zero because the magnetisation is
pointing everywhere in the same direction:</p>
<pre class="literal-block">
x = -1e-08 : H_exch_Py =  None
x = -9e-09 : H_exch_Py =  [-1.264324643856989e-09, 0.0, 0.0]
x = -8e-09 : H_exch_Py =  [-2.0419540595507732e-10, 0.0, 0.0]
x = -7e-09 : H_exch_Py =  [-1.4334754136843496e-09, 0.0, 0.0]
x = -6e-09 : H_exch_Py =  [-2.7214181426130964e-10, 0.0, 0.0]
x = -5e-09 : H_exch_Py =  [1.6323042074911775e-09, 0.0, 0.0]
x = -4e-09 : H_exch_Py =  [-1.6243345875473033e-09, 0.0, 0.0]
x = -3e-09 : H_exch_Py =  [-5.6526341264934703e-09, 0.0, 0.0]
x = -2e-09 : H_exch_Py =  [-6.1145979552370084e-09, 0.0, 0.0]
x = -1e-09 : H_exch_Py =  [-3.0929969691649876e-09, 0.0, 0.0]
x = 0.0    : H_exch_Py =  [9.2633407053741312e-10, 0.0, 0.0]
x = 1e-09  : H_exch_Py =  [1.9476821552904271e-09, 0.0, 0.0]
x = 2e-09  : H_exch_Py =  [2.9690302400434413e-09, 0.0, 0.0]
x = 3e-09  : H_exch_Py =  [2.6077357277001043e-09, 0.0, 0.0]
x = 4e-09  : H_exch_Py =  [1.5836815585162886e-09, 0.0, 0.0]
x = 5e-09  : H_exch_Py =  [1.6602158583197139e-09, 0.0, 0.0]
x = 6e-09  : H_exch_Py =  [1.8844573960991853e-09, 0.0, 0.0]
x = 7e-09  : H_exch_Py =  [-6.2460015649740799e-09, 0.0, 0.0]
x = 8e-09  : H_exch_Py =  [-1.1231714572170603e-08, 0.0, 0.0]
x = 9e-09  : H_exch_Py =  [-7.3643182171284044e-09, 0.0, 0.0]
x = 1e-08  : H_exch_Py =  [-3.4351784609779937e-09, 0.0, 0.0]
</pre>
<p>Note that the subfield name we are probing for the exchange field is
<tt class="docutils literal"><span class="pre">H_exch_Py</span></tt> whereas the subfield name we used to probe the demag
field is <tt class="docutils literal"><span class="pre">H_demag</span></tt> (without the extension <tt class="docutils literal"><span class="pre">_Py</span></tt>. The reason for
this is that the exchange field is a something that is associated with
a particular material (here Py) whereas there is only one demag field
that is experienced by all materials (see also <a class="reference internal" href="manual.html#fields-and-subfields">Fields and subfields</a>).</p>
<div class="section" id="modifying-the-magnetisation">
<h3><a class="toc-backref" href="manual.html#id63">2.7.1&nbsp;&nbsp;&nbsp;Modifying the magnetisation</a></h3>
<p>In step 4, we use the <a class="reference internal" href="manual.html#get-subfield">get_subfield</a> command. This will return a
(<a class="reference internal" href="manual.html#numpy">numpy</a>) array that contains one 3d vector for every <a class="reference internal" href="manual.html#site">site</a> of the
finite element mesh.</p>
<p>In step 5, we modify the first entry in this array (which has index
0), and set its value to <tt class="docutils literal"><span class="pre">[0,1,0]</span></tt>. Whereas the magnetisation is
pointing everywhere in [1,0,0] (because we have used the <a class="reference internal" href="manual.html#set-m">set_m</a>
command in the very beginning of the program, it is now pointing in
the [0,1,0] at site 0.</p>
<p>The information, which site corresponds to which entry in the data
vector, that we have obtained using <a class="reference internal" href="manual.html#get-subfield">get_subfield</a>, can be retrieved from
<a class="reference internal" href="manual.html#get-subfield-sites">get_subfield_sites</a>. Correspondingly, the position of the sites can be
obtained using <a class="reference internal" href="manual.html#get-subfield-positions">get_subfield_positions</a>.</p>
<p>We now need to set this modified magnetisation vector (Step 6) using
the <a class="reference internal" href="manual.html#set-m">set_m</a> command.</p>
<p>If we save the data again to the file (Step 7), we can subsequently
convert this to a vtk file (using, for example, <tt class="docutils literal"><span class="pre">nmagpp</span> <span class="pre">--vtk</span> <span class="pre">data</span>
<span class="pre">sphere_manipulate</span></tt>) and visualise with <a class="reference internal" href="manual.html#mayavi">mayavi</a>:</p>
<div align="center" class="align-center"><img alt="../example_manipulate/step7.png" class="align-center" src="../example_manipulate/step7.png" /></div>
<p>We can see one blue cone in the centre of the sphere - this is the
one site that he have modified to point in the y-direction (whereas all
other cones point in the x-direction).</p>
<p>As before, we can probe the fields along a line through the center of
the sphere (Step 8). For the demag field we obtain:</p>
<pre class="literal-block">
x = -1e-08 : H_demag =  None
x = -9e-09 : H_demag =  [-333816.99138074159, -1884.643376396662, 16.665519199152595]
x = -8e-09 : H_demag =  [-334670.87148225965, -2293.608410913705, -102.38526828192296]
x = -7e-09 : H_demag =  [-335258.77403632947, -3061.1708540342884, -532.73877752122235]
x = -6e-09 : H_demag =  [-339506.72150998382, -5316.1506383768137, -969.36630578549921]
x = -5e-09 : H_demag =  [-344177.83909963415, -8732.9787600552572, -1610.433091871927]
x = -4e-09 : H_demag =  [-344725.75257842313, -16708.164927667149, -5224.2484897904633]
x = -3e-09 : H_demag =  [-337963.49070659198, -24567.078937669514, -3321.016613832679]
x = -2e-09 : H_demag =  [-321612.85117992124, -30613.873989917105, -1385.6383061516099]
x = -1e-09 : H_demag =  [-298312.3363571504, -41265.117003123923, 636.60703829516081]
x = 0.0    : H_demag =  [-273449.78240732534, -52534.176864875568, 2793.5027588779139]
x = 1e-09  : H_demag =  [-293644.21931918303, -39844.049389551074, 4310.6449471266505]
x = 2e-09  : H_demag =  [-313838.65623104072, -27153.921914226579, 5827.7871353753881]
x = 3e-09  : H_demag =  [-330296.09687372146, -21814.293451835449, 5525.7290665358933]
x = 4e-09  : H_demag =  [-343611.94111195666, -18185.932406317523, 4931.5464761658959]
x = 5e-09  : H_demag =  [-348062.40814087034, -11029.603829202088, 3781.8263522408147]
x = 6e-09  : H_demag =  [-342272.36888512014, -6604.210117819096, 50.151907623841332]
x = 7e-09  : H_demag =  [-338716.66400897497, -3860.7761876767272, 485.90273674867018]
x = 8e-09  : H_demag =  [-335656.89887674141, -2610.0345208853882, 586.74812908870092]
x = 9e-09  : H_demag =  [-334985.59512328985, -2169.9546280837162, 542.76746044672041]
x = 1e-08  : H_demag =  [-334441.59096545313, -1634.8337299563193, 627.17874011463311]
</pre>
<p>The change of the magnetisation at position [0,0,0] from [1,0,0] to
[0,1,0] has reduced the x-component of the demag field somewhat around
x=0, and has introduced a significant demag field in the -y direction
around x=0.</p>
<p>Looking at the exchange field (Step 9):</p>
<pre class="literal-block">
x = -1e-08 : H_exch_Py =  None
x = -9e-09 : H_exch_Py =  [-1.264324643856989e-09, 0.0, 0.0]
x = -8e-09 : H_exch_Py =  [-2.0419540595507732e-10, 0.0, 0.0]
x = -7e-09 : H_exch_Py =  [-1.4334754136843496e-09, 0.0, 0.0]
x = -6e-09 : H_exch_Py =  [-2.7214181426130964e-10, 0.0, 0.0]
x = -5e-09 : H_exch_Py =  [1.6323042074911775e-09, 0.0, 0.0]
x = -4e-09 : H_exch_Py =  [-153858.81305452777, 153858.81305452611, 0.0]
x = -3e-09 : H_exch_Py =  [-972420.67935341748, 972420.67935341166, 0.0]
x = -2e-09 : H_exch_Py =  [-2445371.8369108676, 2445371.8369108611, 0.0]
x = -1e-09 : H_exch_Py =  [5283169.701234119, -5283169.7012341227, 0.0]
x = 0.0    : H_exch_Py =  [15888993.991894867, -15888993.991894867, 0.0]
x = 1e-09 :  H_exch_Py =  [8434471.7912872285, -8434471.7912872266, 0.0]
x = 2e-09 :  H_exch_Py =  [979949.59067958547, -979949.59067958279, 0.0]
x = 3e-09 :  H_exch_Py =  [-1112837.3087986181, 1112837.3087986207, 0.0]
x = 4e-09 :  H_exch_Py =  [-193877.66176242317, 193877.6617624248, 0.0]
x = 5e-09 :  H_exch_Py =  [1.6602158583197139e-09, 0.0, 0.0]
x = 6e-09 :  H_exch_Py =  [1.8844573960991853e-09, 0.0, 0.0]
x = 7e-09 :  H_exch_Py =  [-6.2460015649740799e-09, 0.0, 0.0]
x = 8e-09 :  H_exch_Py =  [-1.1231714572170603e-08, 0.0, 0.0]
x = 9e-09 :  H_exch_Py =  [-7.3643182171284044e-09, 0.0, 0.0]
x = 1e-08 :  H_exch_Py =  [-3.4351784609779937e-09, 0.0, 0.0]
</pre>
<p>We can see that the exchange field is indeed very large around x=0.</p>
<p>Note that one of the fundamental problem of micromagnetic simulations
is that the magnetisation must not vary significantly from one site to
another. In this example, we have manually violated this requirement
<em>only to demonstrate</em> how the magnetisation can be modified, and to see that
this is reflected in the dependant fields (such as demag and exchange)
immediately.</p>
<!-- comment:
.. _`Example ipython`: -->
</div>
</div>
<div class="section" id="example-ipython">
<h2><a class="toc-backref" href="manual.html#id64">2.8&nbsp;&nbsp;&nbsp;Example: IPython</a></h2>
<p>The basics of this file are as in <a class="reference internal" href="manual.html#id5">Example: Demag field in uniformly
magnetised sphere</a>: a ferromagnetic sphere is studied, and initially
configured to have homogeneous magnetisation.</p>
<p>Here is the source code of <a class="reference external" href="../example_ipython/sphere_ipython.py">sphere_ipython.py</a></p>
<pre class="literal-block">
import nmag
from nmag import SI

# Create simulation object
sim = nmag.Simulation()

# Define magnetic material
Py = nmag.MagMaterial(name=&quot;Py&quot;,
                      Ms=SI(1e6,&quot;A/m&quot;),
                      exchange_coupling=SI(13.0e-12, &quot;J/m&quot;))

# Load mesh
sim.load_mesh(&quot;sphere1.nmesh.h5&quot;, [(&quot;sphere&quot;, Py)], unit_length=SI(1e-9,&quot;m&quot;))

# Set initial magnetisation
sim.set_m([1, 0, 0])

# Activate interactive python session
nmag.ipython()

print &quot;Back in main code&quot;

</pre>
<p>To execute this script, we have to give its name to the <a class="reference internal" href="manual.html#nsim">nsim</a>
executable, for example (on linux):</p>
<pre class="literal-block">
$ nsim sphere_ipython.py
</pre>
<p>The new command appearing here is:</p>
<pre class="literal-block">
nmag.ipython()
</pre>
<p>This calls an interactive python interpreter (this is like the
standard <tt class="docutils literal"><span class="pre">ipython</span></tt> interpreter called from the command prompt).</p>
<p>Once we are &quot;inside&quot; this ipython interpreter, we can interactively work with
the simulation object. We demonstrate this with the transcript of such
a session:</p>
<pre class="literal-block">
$ nsim sphere_ipython.py

&lt;snip&gt;


In [1]: sim.get_subfield(&quot;H_demag&quot;)
Out[1]:
array([[ -3.30028671e+05,  -2.57073101e+01,  -4.63461085e+01],
       [ -3.30518650e+05,  -2.65364907e+01,   2.12323921e+02],
       [ -3.30380750e+05,  -1.34382835e+02,   1.94635283e+01],
       ...,
       [ -3.30063839e+05,   4.56312711e+01,  -1.31204248e+02],
       [ -3.30056243e+05,  -3.23341645e+01,  -2.26732582e+02],
       [ -3.29950815e+05,   4.44150291e+01,  -5.41700794e+01]])

In [2]: sim.set_m([0,0,1])

In [3]: sim.get_subfield(&quot;H_demag&quot;)
Out[3]:
array([[ -6.86773473e+01,   4.44496808e+01,  -3.30084368e+05],
       [ -2.83792944e+02,   1.78935681e+02,  -3.30268314e+05],
       [ -2.04396266e+02,   2.48374212e+02,  -3.30180923e+05],
       ...,
       [ -1.02055030e+02,  -9.53215211e+01,  -3.30239401e+05],
       [  1.94875407e+02,   1.22757584e+02,  -3.29771010e+05],
       [  6.16259262e+01,   1.66071597e+02,  -3.29848851e+05]])
</pre>
<p>Note that within ipython, one can just press the TAB key to
autocomplete object names, functions and commands.</p>
<p>You can leave the ipython environment by pressing CTRL+D. For the
script shown here, this will print <tt class="docutils literal"><span class="pre">Back</span> <span class="pre">in</span> <span class="pre">main</span> <span class="pre">code</span></tt> before the
end of the script is reached. The <tt class="docutils literal"><span class="pre">ipython()</span></tt> command is
occasionally a handy debugging feature: in order to investigate the
behaviour of the system &quot;on the spot&quot;, one can insert an <tt class="docutils literal"><span class="pre">ipython</span></tt> call
into the script which will open an interactive command line.</p>
</div>
<div class="section" id="example-pinning-magnetisation">
<h2><a class="toc-backref" href="manual.html#id65">2.9&nbsp;&nbsp;&nbsp;Example: Pinning Magnetisation</a></h2>
<p>In this example we show how to pin (<em>i.e.</em> fix) magnetisation
in certain parts of a material.</p>
<div class="section" id="pinning-simulation-script">
<h3><a class="toc-backref" href="manual.html#id66">2.9.1&nbsp;&nbsp;&nbsp;Pinning simulation script</a></h3>
<pre class="literal-block">
import nmag
from nmag import SI, si

# Create simulation object
sim = nmag.Simulation()

# Define magnetic material: PermAlloy
Py = nmag.MagMaterial(name=&quot;Py&quot;,
                      Ms=SI(0.86e6, &quot;A/m&quot;),
                      exchange_coupling=SI(13.0e-12, &quot;J/m&quot;))

# Load mesh
sim.load_mesh(&quot;sphere1.nmesh.h5&quot;, [(&quot;sphere&quot;, Py)], unit_length=SI(1e-9, &quot;m&quot;))

# Set initial magnetisation to +x direction
sim.set_m([1, 0, 0])

# Pin magnetisation at center in radius of 4e-9m
def pin_at_center((x, y, z)):
  if (x*x + y*y + z*z) &lt; (4e-9)*(4e-9):
    return 0.0 # Inside the 4nm sphere -&gt; pin
  else:
    return 1.0 # Outside -&gt; do not pin

sim.set_pinning(pin_at_center)

# Apply external field in +y direction
unit = 0.5*si.Tesla/si.mu0 # 500mT in A/m
sim.set_H_ext([0*unit, 1*unit, 0*unit])

# Relax the magnetisation
sim.relax()

</pre>
</div>
<div class="section" id="pinning-magnetisation">
<h3><a class="toc-backref" href="manual.html#id67">2.9.2&nbsp;&nbsp;&nbsp;Pinning magnetisation</a></h3>
<p>In order to allow the user to fix the magnetisation, nmag provides a
scalar field, the so-called <em>pinning field</em>: its value at each site is
used as a scale factor for <tt class="docutils literal"><span class="pre">dm/dt</span></tt>, hence by setting it to 0 at
certain locations of the mesh we can force magnetisation to remain
constant at these locations for the entire simulation.</p>
<p>We set the pinning field using <a class="reference internal" href="manual.html#set-pinning">set_pinning</a> (which is used like
<a class="reference internal" href="manual.html#set-m">set_m</a> and <a class="reference internal" href="manual.html#set-h-ext">set_H_ext</a>, except that it is a scalar field whereas the
latter are vector fields) such that magnetisation is fixed at sites
with distance less than 4 nm from the sphere's center. First we define
a Python function which we decide to call <tt class="docutils literal"><span class="pre">pin_at_center</span></tt>:</p>
<pre class="literal-block">
def pin_at_center((x, y, z)):
  if (x*x + y*y + z*z) &lt; (4e-9)*(4e-9):
    return 0.0
  else:
    return 1.0
</pre>
<p>The function is called for each site of the mesh
and receives the site position as an argument,
a 3-tuple <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></tt> containing the three
components <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">y</span></tt> and <tt class="docutils literal"><span class="pre">z</span></tt> (three floating point numbers),
given in metres.
The function returns either 0.0 (which means the magnetisation
at this position is pinned) or 1.0 (in which case there is no pinning),
for the given position vector.</p>
<p>The formula in the <tt class="docutils literal"><span class="pre">if</span></tt> statement simply evaluates the magnitude
of the vector <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></tt> by squaring each component.
This number is then compared against (4nm)^2.
As a result, the magnetisation is pinned at all the mesh nodes that are
located within a sphere with center <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></tt> and radius 4 nm.
All the nodes that are located outside this sphere can change
their magnetisation as usual.</p>
<p>Second, we need to tell nmag that it should use this function to
decide where the magnetisation should be pinned:</p>
<pre class="literal-block">
sim.set_pinning(pin_at_center)
</pre>
<p>Note the slightly counterintuitive fact that value 1 means &quot;no pinning&quot;.</p>
<p>Finally we apply an external field of 0.5 T in +y direction, and use
<a class="reference internal" href="manual.html#relax">relax</a> to compute the equilibrium configuration.</p>
<p>The <a class="reference internal" href="manual.html#relax">relax</a> command:</p>
<pre class="literal-block">
sim.relax()
</pre>
<p>will save the fields and averages at convergence (this is the default
of the <a class="reference internal" href="manual.html#relax">relax</a> command).</p>
</div>
<div class="section" id="visualisation">
<h3><a class="toc-backref" href="manual.html#id68">2.9.3&nbsp;&nbsp;&nbsp;Visualisation</a></h3>
<p>After running the example via <tt class="docutils literal"><span class="pre">nsim</span> <span class="pre">sphere.py</span></tt> we convert the equilibrium
data to VTK format:</p>
<pre class="literal-block">
$ nmagpp --vtk=sphere.vtk sphere
</pre>
<p>We would first like to verify that the pinning field has been set up
properly.  Hence we use <a class="reference internal" href="manual.html#mayavi">MayaVi</a> to visualise it by showing an
isosurface of the pinning field (shown in blue), together with the
magnetisation vector field.</p>
<div align="center" class="align-center"><img alt="../example_pinning/pinned_core.png" class="align-center" src="../example_pinning/pinned_core.png" /></div>
<p>The blue blob in the center of the sphere is the collection of those
tetrahedra that have corners just inside the 4nm sphere. Because we
have not generated the mesh to have nodes coinciding with the 4nm
sphere, the shape of the blue region is not particularly spherical.</p>
<p>In the above diagram, we also see the magnetisation vectors of the
final configuration. Their colour corresponds to the pinning field at
their location. It can be seen that the blue magnetisation vectors
emerging from the central region of the sphere are all pointing
(strictly) in the x-direction. The magnetisation vectors outside the
blue sphere are coloured red. The applied field drives these vectors
to point into the y-direction. However, the magnetisation in the
centre is pinned and the exchange interaction requires a gradual
spatial change of magnetisation. This explains the spatial variation
of the magnetisation.</p>
<p>The next figure shows the same data as the last figure but in addition a
<tt class="docutils literal"><span class="pre">ScalarCutPlane</span></tt> (in MayaVi terminology) has been introduced which
is coloured according to the x-component of the magnetisation. Red
corresponds to 1.0 and blue corresponds to 0.73 (we have not shown the
legend to provide a larger main plot). This demonstrates the gradual
change from the pinned magnetisation in the centre to the outside.</p>
<div align="center" class="align-center"><img alt="../example_pinning/magnetisation.png" class="align-center" src="../example_pinning/magnetisation.png" /></div>
</div>
</div>
<div class="section" id="example-uniaxial-anisotropy">
<h2><a class="toc-backref" href="manual.html#id69">2.10&nbsp;&nbsp;&nbsp;Example: Uniaxial anisotropy</a></h2>
<p>In this example we would like to simulate the development of a Bloch type
domain wall on a thin cobalt bar of dimension 504 x 1 x 1 nm
(<a class="reference external" href="../example_uniaxial_anis/bar.nmesh.h5">bar.nmesh.h5</a>) due to uniaxial
anisotropy.</p>
<div class="section" id="uniaxial-anisotropy-simulation-script">
<h3><a class="toc-backref" href="manual.html#id70">2.10.1&nbsp;&nbsp;&nbsp;Uniaxial anisotropy simulation script</a></h3>
<pre class="literal-block">
import nmag
from nmag import SI, every, at
from numpy import array
import math

# Create simulation object (no demag field!)
sim = nmag.Simulation(do_demag=False)

# Define magnetic material (data from OOMMF materials file)
Co = nmag.MagMaterial(name=&quot;Co&quot;,
                      Ms=SI(1400e3, &quot;A/m&quot;),
                      exchange_coupling=SI(30e-12, &quot;J/m&quot;),
                      anisotropy=nmag.uniaxial_anisotropy(axis=[0, 0, 1], K1=SI(520e3, &quot;J/m^3&quot;)))

# Load the mesh
sim.load_mesh(&quot;bar.nmesh.h5&quot;, [(&quot;bar&quot;, Co)], unit_length=SI(1e-9,&quot;m&quot;) )

# Our bar is subdivided into 3 regions:
# - region A: for x &lt; offset;
# - region B: for x between offset and offset+length
# - region C: for x &gt; offset+length;
# The magnetisation is defined over all the three regions,
# but is pinned in region A and C.
offset = 2e-9   # m (meters)
length = 500e-9 # m

# Set initial magnetisation
def sample_m0((x, y, z)):
  # relative_position goes linearly from -1 to +1 in region B
  relative_position = -2*(x - offset)/length + 1
  mz = min(1.0, max(-1.0, relative_position))
  return [0, math.sqrt(1 - mz*mz), mz]

sim.set_m(sample_m0)

# Pin magnetisation outside region B
def sample_pinning((x, y, z)):
  return x &gt;= offset and x &lt;= offset + length

sim.set_pinning(sample_pinning)

# Save the magnetisation along the x-axis
def save_magnetisation_along_x(sim):
  f = open('bar_mag_x.dat', 'w')
  for i in range(0, 504):
    x = array([i+0.5, 0.5, 0.5]) * 1e-9
    M = sim.probe_subfield_siv('M_Co', x)
    print &gt;&gt;f, x[0], M[0], M[1], M[2]

# Relax the system
sim.relax(save=[(save_magnetisation_along_x, at('convergence'))])

</pre>
<p>We shall now discuss the <a class="reference external" href="../example_uniaxial_anis/bar.py">bar.py</a>  script
step-by-step:</p>
<p>In this particular example we are solely interested in energy terms resulting
from exchange interaction and anisotropy. Hence we disable the demagnetisation
field as follows:</p>
<pre class="literal-block">
sim = nmag.Simulation(do_demag=False)
</pre>
<p>We then create the material <tt class="docutils literal"><span class="pre">Co</span></tt> used for the bar, cobalt in this case, which exhibits uniaxial
anisotropy in z direction with phenomenological anisotropy constant
<tt class="docutils literal"><span class="pre">K1</span> <span class="pre">=</span> <span class="pre">SI(520e3,</span> <span class="pre">&quot;J/m^3&quot;)</span></tt>:</p>
<pre class="literal-block">
Co = nmag.MagMaterial(name=&quot;Co&quot;,
                      Ms=SI(1400e3, &quot;A/m&quot;),
                      exchange_coupling=SI(30e-12, &quot;J/m&quot;),
                      anisotropy=nmag.uniaxial_anisotropy(axis=[0, 0, 1], K1=SI(520e3, &quot;J/m^3&quot;)))
</pre>
<p>After loading the mesh, we set the initial magnetisation direction such that
it rotates from +z to -z while staying in the plane normal to x direction
(hence suggesting the development of a Bloch type domain wall):</p>
<pre class="literal-block">
def sample_m0((x, y, z)):
  # relative_position goes linearly from -1 to +1 in region B
  relative_position = -2*(x - offset)/length + 1
  mz = min(1.0, max(-1.0, relative_position))
  return [0, math.sqrt(1 - mz*mz), mz]
</pre>
<p>We further pin the magnetisation at the very left (x &lt; offset = 2 nm)
and right (x &gt; offset + length = 502 nm) of the bar
(note that the pinning function may also just return a python truth
value rather than the number 0.0 or 1.0):</p>
<pre class="literal-block">
def sample_pinning((x, y, z)):
  return x &gt;= offset and x &lt;= offset + length

sim.set_pinning(sample_pinning)
</pre>
<p>Finally, we relax the system to find the equilibrium magnetisation
configuration, which is saved to the file <tt class="docutils literal"><span class="pre">bar_mag_x.dat</span></tt> in a format
understandable by <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a>.</p>
</div>
<div class="section" id="visualization">
<h3><a class="toc-backref" href="manual.html#id71">2.10.2&nbsp;&nbsp;&nbsp;Visualization</a></h3>
<p>We can then use the following <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> script to visualize
the equilibrium magnetisation:</p>
<pre class="literal-block">
set term png giant size 800, 600
set out 'bar_mag_x.png'
set xlabel 'x (nm)'
set ylabel 'M.z (millions of A/m)'

plot [0:504] [-1.5:1.5] \
  1.4 t &quot;&quot; w l 0, -1.4 t &quot;&quot; w l 0, \
  'bar_mag_x.dat' u ($1/1e-9):($4/1e6) t 'nmag' w l 2

</pre>
<p>The resulting plot clearly shows that a Bloch type domain wall has developed:</p>
<div align="center" class="align-center"><img alt="../example_uniaxial_anis/bar_mag_x.png" class="align-center" src="../example_uniaxial_anis/bar_mag_x.png" /></div>
<p>The figure shows also that the Bloch domain wall is well localized at the center
of the bar, in the region where x goes from 200 to 300 nm.</p>
</div>
<div class="section" id="comparison">
<h3><a class="toc-backref" href="manual.html#id72">2.10.3&nbsp;&nbsp;&nbsp;Comparison</a></h3>
<p>After simulating the same scenario with
OOMMF (see <a class="reference external" href="../example_uniaxial_anis/oommf/bar.mif">oommf/bar.mif</a>),
we can compare results using another <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> script:</p>
<pre class="literal-block">
#set term postscript enhanced eps color
set term png giant size 800, 600
set out 'bar_mag_x_compared.png'

set xlabel 'x (nm)'
set ylabel 'M.z (millions of A/m)'

Mz(x) = 1400e3 * cos(pi/2 + atan(sinh((x - 252e-9)/sqrt(30e-12/520e3))))

plot [220:280] [-1.5:1.5] \
  1.4 t &quot;&quot; w l 0, -1.4 t &quot;&quot; w l 0, \
  'bar_mag_x.dat' u ($1/1e-9):($4/1e6) t 'nmag' w lp 2, \
  'oommf/bar_mag_x.txt'u ($1/1e-9):($4/1e6) t 'oommf' w lp 1, \
  Mz(x*1e-9)/1e6 ti 'analytical' w l 3

</pre>
<p>which generates the following plot showing good agreement of both systems:</p>
<div align="center" class="align-center"><img alt="../example_uniaxial_anis/bar_mag_x_compared.png" class="align-center" src="../example_uniaxial_anis/bar_mag_x_compared.png" /></div>
<p>The plot shows also the known analytical solution:</p>
<pre class="literal-block">
Mz(x) = Ms * cos(pi/2 + atan(sinh((x - x_wall)/sqrt(A/K1))))
</pre>
<p>The plot shows only a restricted region located at the center of the bar,
thus allowing an easier comparison between the three sets of data.</p>
</div>
</div>
<div class="section" id="example-cubic-anisotropy">
<h2><a class="toc-backref" href="manual.html#id73">2.11&nbsp;&nbsp;&nbsp;Example: Cubic Anisotropy</a></h2>
<p>In this example we will study the behaviour of a 10 x 10 x 10 nm iron
cube with cubic anisotropy in an external field.</p>
<div class="section" id="cubic-anisotropy-simulation-script">
<h3><a class="toc-backref" href="manual.html#id74">2.11.1&nbsp;&nbsp;&nbsp;Cubic anisotropy simulation script</a></h3>
<pre class="literal-block">
import nmag
from nmag import SI, si

# Create the simulation object
sim = nmag.Simulation()

# Define the magnetic material (data from OOMMF materials file)
Fe = nmag.MagMaterial(name=&quot;Fe&quot;,
                      Ms=SI(1700e3, &quot;A/m&quot;),
                      exchange_coupling=SI(21e-12, &quot;J/m&quot;),
                      anisotropy=nmag.cubic_anisotropy(axis1=[1, 0, 0],
                                                       axis2=[0, 1, 0],
                                                       K1=SI(48e3, &quot;J/m^3&quot;)))

# Load the mesh
sim.load_mesh(&quot;cube.nmesh&quot;, [(&quot;cube&quot;, Fe)], unit_length=SI(1e-9, &quot;m&quot;))

# Set the initial magnetisation
sim.set_m([0, 0, 1])

# Launch the hysteresis loop
Hs = nmag.vector_set(direction=[1.0, 0, 0.0001],
                     norm_list=[0, 1, [], 19, 19.1, [], 21, 22, [], 50],
                     units=0.001*si.Tesla/si.mu0)
sim.hysteresis(Hs)

</pre>
<p>We will now discuss the <a class="reference external" href="../example_cubic_anis/cube.py">cube.py</a> script step-by-step:</p>
<p>After creating the simulation object we define a magnetic material <tt class="docutils literal"><span class="pre">Fe</span></tt>
with cubic anisotropy representing iron:</p>
<pre class="literal-block">
Fe = nmag.MagMaterial(name=&quot;Fe&quot;,
                      Ms=SI(1700e3, &quot;A/m&quot;),
                      exchange_coupling=SI(21e-12, &quot;J/m&quot;),
                      anisotropy=nmag.cubic_anisotropy(axis1=[1,0,0],
                                                       axis2=[0,1,0],
                                                       K1=SI(48e3, &quot;J/m^3&quot;)))
</pre>
<p>We load the mesh and set initial magnetisation pointing in +z direction
(that is, in a local minimum of anisotropy energy density).</p>
<p>Finally, we use <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> to apply gradually stronger fields in +x direction (up to 50 mT):</p>
<pre class="literal-block">
Hs = nmag.vector_set(direction=[1.0, 0, 0.0001],
                     norm_list=[0, 1, [], 19, 19.1, [], 21, 22, [], 50],
                     units=0.001*si.Tesla/si.mu0)
</pre>
<p>Note that we sample more often the region between 19 and 21 mT where
magnetisation direction changes rapidly due to having crossed the anisotropy
energy &quot;barrier&quot; between +z and +x (as can be seen in the graph below).</p>
</div>
<div class="section" id="analyzing-the-result">
<h3><a class="toc-backref" href="manual.html#id75">2.11.2&nbsp;&nbsp;&nbsp;Analyzing the result</a></h3>
<p>First, we extract the magnitude of the applied field and the x component of
magnetisation:</p>
<pre class="literal-block">
ncol cube H_ext_0 M_Fe_0 &gt; cube_hext_vs_m.txt
</pre>
<p>Then we compare the result with OOMMF's result (generated from the
equivalent scene description <a class="reference external" href="../example_cubic_anis/oommf/cube.mif">oommf/cube.mif</a>)
using the following <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> script:</p>
<pre class="literal-block">
set term png giant size 800,600
set out 'cube_hext_vs_m.png'
set xlabel 'H_ext.x (A/m)'
set ylabel 'M.x (A/m)'
plot 'cube_hext_vs_m.txt' t 'nmag' w l 2,\
 'oommf/cube_hext_vs_m.txt' u ($1*795.77471545947674):2 ti 'oommf' w p 1

</pre>
<p>which gives the following result:</p>
<div align="center" class="align-center"><img alt="../example_cubic_anis/cube_hext_vs_m.png" class="align-center" src="../example_cubic_anis/cube_hext_vs_m.png" /></div>
<p>Nmag provides advanced capabilities to conveniently handle
arbitrary-order anisotropy energy functions. Details can be found in
the documentation of the <a class="reference internal" href="manual.html#magmaterial">MagMaterial</a> class.</p>
</div>
</div>
<div class="section" id="example-arbitrary-anisotropy">
<h2><a class="toc-backref" href="manual.html#id76">2.12&nbsp;&nbsp;&nbsp;Example: Arbitrary Anisotropy</a></h2>
<p>In this example we discuss
the script <a class="reference external" href="../example_user_anis/coin.py">coin.py</a>
which shows how the user can include in his simulations
a customised magnetic anisotropy.</p>
<div class="section" id="arbitrary-anisotropy-simulation-script">
<h3><a class="toc-backref" href="manual.html#id77">2.12.1&nbsp;&nbsp;&nbsp;Arbitrary anisotropy simulation script</a></h3>
<pre class="literal-block">
import nmag
from nmag import SI, every, at
from nsim.si_units import si
import math

# Create simulation object (no demag field!)
sim = nmag.Simulation(do_demag=False)

# Function to compute the scalar product of the vectors a and b
def scalar_product(a, b): return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]

# Here we define a function which returns the energy for a uniaxial
# anisotropy of order 4.
K1 = SI(43e3, &quot;J/m^3&quot;)
K2 = SI(21e3, &quot;J/m^3&quot;)
axis = [0, 0, 1]        # The (normalised) axis
def my_anisotropy(m):
    a = scalar_product(axis, m)
    return -K1*a**2 - K2*a**4

my_material = nmag.MagMaterial(name=&quot;MyMat&quot;,
                               Ms=SI(1e6, &quot;A/m&quot;),
                               exchange_coupling=SI(10e-12, &quot;J/m&quot;),
                               anisotropy=my_anisotropy,
                               anisotropy_order=4)

# Load the mesh
sim.load_mesh(&quot;coin.nmesh.h5&quot;, [(&quot;coin&quot;, my_material)], unit_length=SI(1e-9, &quot;m&quot;))

# Set the magnetization
sim.set_m([-1, 0, 0])

# Compute the hysteresis loop
Hs = nmag.vector_set(direction=[1.0, 0, 0.0001],
                     norm_list=[-0.4, -0.35, [], 0, 0.005, [], 0.15, 0.2, [], 0.4],
                     units=si.Tesla/si.mu0)

sim.hysteresis(Hs, save=[('fields', 'averages', at('convergence'))])

</pre>
<p>We simulate the hysteresis loop for a ferromagnetic thin disc,
where the field is applied orthogonal to the axis of disc.
This script includes one main element of novelty, which concerns the way
the magnetic anisotropy is specified.
In previous examples we found lines such as:</p>
<pre class="literal-block">
my_material = nmag.MagMaterial(name=&quot;MyMat&quot;,
                               Ms=SI(1e6, &quot;A/m&quot;),
                               exchange_coupling=SI(10e-12, &quot;J/m&quot;),
                               anisotropy=nmag.uniaxial_anisotropy(axis=[0, 0, 1],
                                                                   K1=SI(43e3, &quot;J/m^3&quot;),
                                                                   K2=SI(21e3, &quot;J/m^3&quot;)))
</pre>
<p>where the material anisotropy was specified using the provided functions
<tt class="docutils literal"><span class="pre">nmag.uniaxial_anisotropy</span></tt> (<a class="reference internal" href="manual.html#uniaxial-anisotropy">uniaxial_anisotropy</a>) and <tt class="docutils literal"><span class="pre">nmag.cubic_anisotropy</span></tt> (<a class="reference internal" href="manual.html#cubic-anisotropy">cubic_anisotropy</a>).
In this example we are using a different approach to define the anisotropy.
First we define the function <tt class="docutils literal"><span class="pre">my_anisotropy</span></tt>, which returns the energy density
for the magnetic anisotropy:</p>
<pre class="literal-block">
# Here we define a function which returns the energy for a uniaxial
# anisotropy of order 4.
K1 = SI(43e3, &quot;J/m^3&quot;)
K2 = SI(21e3, &quot;J/m^3&quot;)
axis = [0, 0, 1]        # The (normalised) axis
def my_anisotropy(m):
    a = scalar_product(axis, m)
    return -K1*a**2 - K2*a**4
</pre>
<p>Note that the function returns a SI object with units &quot;J/m^3&quot; (energy density).
The reader may have recognised the familiar expression for the uniaxial anisotropy:
in fact the two code snippets we just presented are defining exactly the same
anisotropy, they are just doing it in different ways.
The function <tt class="docutils literal"><span class="pre">scalar_product</span></tt>, which we have used in the second code snippet
just returns the scalar product of two three dimensional vectors <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt>
and is defined in the line above:</p>
<pre class="literal-block">
def scalar_product(a, b): return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]
</pre>
<p>The function <tt class="docutils literal"><span class="pre">my_anisotropy</span></tt> has to be specified in the material definition:
instead of passing <tt class="docutils literal"><span class="pre">anisotropy=nmag.uniaxial_anisotropy(...)</span></tt>
we just pass <tt class="docutils literal"><span class="pre">anisotropy=my_anisotropy</span></tt> to the material constructor:</p>
<pre class="literal-block">
my_material = nmag.MagMaterial(name=&quot;MyMat&quot;,
                               Ms=SI(1e6, &quot;A/m&quot;),
                               exchange_coupling=SI(10e-12, &quot;J/m&quot;),
                               anisotropy=my_anisotropy,
                               anisotropy_order=4)
</pre>
<p>An important point to notice is that here we also provide an anisotropy order.
To understand what this number is, we have to explain briefly what is going on
behind the scenes. nsim calculates the values of the user provided function
for an appropriately chosen set of normalised vectors,
it then finds the polynomial in <tt class="docutils literal"><span class="pre">mx</span></tt>, <tt class="docutils literal"><span class="pre">my</span></tt> and <tt class="docutils literal"><span class="pre">mz</span></tt>
(the components of the normalised magnetisation) of the specified order,
which matches the sampled values.</p>
<p>The strength of this approach stands in the fact that the user has to provide
just the energy density for the custom anisotropy.
nsim is taking care of working out the other quantities which
are needed for the simulation, such as the magnetic field resulting
from the provided anisotropy energy, which would require a differentiation
of the energy with respect to the normalised magnetisation.</p>
<p>However the user must be sure that the provided function can be expressed
by a polynomial of the specified order in <tt class="docutils literal"><span class="pre">mx</span></tt>, <tt class="docutils literal"><span class="pre">my</span></tt> and <tt class="docutils literal"><span class="pre">mz</span></tt>.
In the present case we are specifying <tt class="docutils literal"><span class="pre">anisotropy_order=4</span></tt> because the energy
for the uniaxial anisotropy can be expressed as a 4th-order polynomial
in <tt class="docutils literal"><span class="pre">mx</span></tt>, <tt class="docutils literal"><span class="pre">my</span></tt> and <tt class="docutils literal"><span class="pre">mz</span></tt>.</p>
<p>In some cases the user may find useful to know that the functions
<tt class="docutils literal"><span class="pre">nmag.uniaxial_anisotropy</span></tt> and <tt class="docutils literal"><span class="pre">nmag.cubic_anisotropy</span></tt>
can be added: the resulting anisotropy will have as energy
the sum of the energies of the original anisotropies.</p>
</div>
<div class="section" id="the-result">
<h3><a class="toc-backref" href="manual.html#id78">2.12.2&nbsp;&nbsp;&nbsp;The result</a></h3>
<p>The steps involved to extract and plot the data for the simulation discussed
in the previous section should be familiar to the user at this point of the manual.
We then just show the graph obtained from the results
of the script <a class="reference external" href="../example_user_anis/coin.py">coin.py</a>.</p>
<div align="center" class="align-center"><img alt="../example_user_anis/coin.png" class="align-center" src="../example_user_anis/coin.png" /></div>
<p>During the switching the system falls into an intermediate state,
where the magnetisation is nearly aligned with the anisotropy easy axis.</p>
</div>
</div>
<div class="section" id="restart-example">
<h2><a class="toc-backref" href="manual.html#id79">2.13&nbsp;&nbsp;&nbsp;Restart example</a></h2>
<p>Micromagnetic simulations can last for many hours or even many days.
It is then important to be able to save periodically the state
of the simulation, in such a way that, if a hardware failure
or a power cut occurs, the simulation can be restarted
exactly at the point where its state was last saved.
In this example we show how an nmag script can be modified
to be &quot;restartable&quot;. The only thing the user needs to do
is to periodically save the state of the simulation in what we call
a &quot;restart file&quot;. The simulation can then be restarted
using the appropriate command line option.</p>
<p>The restart feature applies only to the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> method.</p>
<div class="section" id="saving-the-state-of-the-simulation">
<h3><a class="toc-backref" href="manual.html#id80">2.13.1&nbsp;&nbsp;&nbsp;Saving the state of the simulation</a></h3>
<p>We re-consider the cubic anisotropy example
(<a class="reference internal" href="manual.html#cubic-anisotropy-simulation-script">Cubic anisotropy simulation script</a>)
and replace the last line:</p>
<pre class="literal-block">
sim.hysteresis(Hs)

</pre>
<p>with the following lines:</p>
<pre class="literal-block">
from nmag import every, at
sim.hysteresis(Hs, save=[('averages', 'fields', at('stage_end')),
                         ('restart', at('stage_end') | every(1000, 'step'))])

</pre>
<p>The first two lines reproduce the default behaviour:
the fields and their averages are saved at the end of each stage.
The third line specifies that the restart file should be saved
at the end of each stage and also every 1000 steps.</p>
<p>For convenience the modified script <a class="reference external" href="../example_restart/cube_restartable.py">cube_restartable.py</a> is shown below:</p>
<pre class="literal-block">
import nmag
from nmag import SI, si

# Create the simulation object
sim = nmag.Simulation()

# Define the magnetic material (data from OOMMF materials file)
Fe = nmag.MagMaterial(name=&quot;Fe&quot;,
                      Ms=SI(1700e3, &quot;A/m&quot;),
                      exchange_coupling=SI(21e-12, &quot;J/m&quot;),
                      anisotropy=nmag.cubic_anisotropy(axis1=[1, 0, 0],
                                                       axis2=[0, 1, 0],
                                                       K1=SI(48e3, &quot;J/m^3&quot;)))

# Load the mesh
sim.load_mesh(&quot;cube.nmesh&quot;, [(&quot;cube&quot;, Fe)], unit_length=SI(1e-9, &quot;m&quot;))

# Set the initial magnetisation
sim.set_m([0, 0, 1])

# Launch the hysteresis loop
Hs = nmag.vector_set(direction=[1.0, 0, 0.0001],
                     norm_list=[0, 1, [], 19, 19.1, [], 21, 22, [], 50],
                     units=0.001*si.Tesla/si.mu0)
from nmag import every, at
sim.hysteresis(Hs, save=[('averages', 'fields', at('stage_end')),
                         ('restart', at('stage_end') | every(1000, 'step'))])

</pre>
</div>
<div class="section" id="starting-and-restarting-the-simulation">
<h3><a class="toc-backref" href="manual.html#id81">2.13.2&nbsp;&nbsp;&nbsp;Starting and restarting the simulation</a></h3>
<p>We will now demonstrate how the discussed nmag script can be
restarted. To do that, we will have to interrupt it artificially. We
start the simulation in the usual way:</p>
<pre class="literal-block">
$ nsim cube_restartable.py
</pre>
<p>We interrupt the execution after the hysteresis loop has started and
several stages have been computed. Do this by pressing simultaneously
the keys CTRL and C (in the same terminal window where nsim was
started), thus simulating what could have been the result of a power
cut.  We then use the command:</p>
<pre class="literal-block">
$ ncol cube_restartable stage step time
</pre>
<p>to see at what point of the hysteresis loop the simulation was interrupted.
We obtain (for this particular interruption):</p>
<pre class="literal-block">
 1            330  3.320127110062e-11
 2            480  5.042492488627e-10
 3            640  9.926580643272e-10
 4            805  1.464971830453e-09
 5            980  1.927649646634e-09
 6           1150  2.406521613682e-09
 7           1340  2.882400372552e-09
 8           1515  3.371522550051e-09
 9           1705  3.863380029345e-09
10           1920  4.365560120394e-09
11           2095  4.893234441813e-09
12           2295  5.436617525896e-09
13           2480  5.997866344586e-09
14           2680  6.570733097131e-09
15           2890  7.172534305054e-09
16           3100  7.803577637245e-09
17           3315  8.462827284047e-09
</pre>
<p>The simulation was interrupted at the seventeenth stage.
We now try to run the simulation again with the command:</p>
<pre class="literal-block">
$ nsim cube_restartable.py
</pre>
<p>obtaining the following output:</p>
<pre class="literal-block">
&lt;snip&gt;
NmagUserError: Error: Found old file ./cube_restartable_dat.ndt -- cannot proceed.
To start a simulation script with old data files present you either need
to use '--clean' (and then the old files will be deleted), or use '--restart'
in which case the run will be continued.
</pre>
<p>nsim suggests the possible alternatives. We can start the simulation from scratch with the command (but this will override any data from the previous run):</p>
<pre class="literal-block">
$ nsim cube_restartable.py --clean
</pre>
<p>or we can continue from the configuration which was last saved:</p>
<pre class="literal-block">
$ nsim cube_restartable.py --restart
</pre>
<p>Here we choose the second possibility.
After the simulation has finished we issue again
the command <tt class="docutils literal"><span class="pre">ncol</span> <span class="pre">cube_restartable</span> <span class="pre">stage</span> <span class="pre">step</span> <span class="pre">time</span></tt>, obtaining
the following output:</p>
<pre class="literal-block">
    1            330  3.320127110062e-11
    2            480  5.042492488627e-10
    3            640  9.926580643272e-10
    4            805  1.464971830453e-09
    5            980  1.927649646634e-09
    6           1150  2.406521613682e-09
    7           1340  2.882400372552e-09
    8           1515  3.371522550051e-09
    9           1705  3.863380029345e-09
   10           1920  4.365560120394e-09
   11           2095  4.893234441813e-09
   12           2295  5.436617525896e-09
   13           2480  5.997866344586e-09
   14           2680  6.570733097131e-09
   15           2890  7.172534305054e-09
   16           3100  7.803577637245e-09
   17           3315  8.462827284047e-09
stage           step          #time
   &lt;&gt;             &lt;&gt;           #&lt;s&gt;
   18           3715  8.519843629989e-09
   19           3975  9.300878866142e-09
   ...
</pre>
<p>The two lines between stage 17 and 18 stand as a reminder that the
simulation was restarted at that point. (They need to be removed
manually from the <tt class="docutils literal"><span class="pre">cube_restartable_dat.ndt</span></tt> file, before <a class="reference internal" href="manual.html#ncol">ncol</a> can
work in the usual way on the ndt file.)</p>
</div>
</div>
<div class="section" id="example-two-different-magnetic-materials">
<h2><a class="toc-backref" href="manual.html#id82">2.14&nbsp;&nbsp;&nbsp;Example: two different magnetic materials</a></h2>
<p>In this example, we study the dynamics of a simple system consisting
of two 15 nm x 15 nm x 15 nm cubes close to one another (with 2 nm
spacing along the x-axis). We take the right cube to be made of
PermAlloy and the left cube to be made of Cobalt, with the magnetic
anisotropy axis pointing in z-direction. The mesh has been generated
with <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> from the geometry file <a class="reference external" href="../example_two_materials/two_cubes.geo">two_cubes.geo</a>.</p>
<div align="center" class="align-center"><img alt="../example_two_materials/cubes.png" class="align-center" src="../example_two_materials/cubes.png" /></div>
<p>We use the <a class="reference external" href="../example_two_materials/two_cubes.py">two_cubes.py</a> script to carry out the simulation:</p>
<pre class="literal-block">
import nmag
from nmag import SI, every, at

sim = nmag.Simulation()

# define magnetic material Cobalt (data from OOMMF materials file)
Co = nmag.MagMaterial(name=&quot;Co&quot;,
                      Ms=SI(1400e3, &quot;A/m&quot;),
                      exchange_coupling=SI(30e-12, &quot;J/m&quot;),
                      anisotropy=nmag.uniaxial_anisotropy(axis=[0,0,1], K1=SI(520e3, &quot;J/m^3&quot;)))

# define magnetic material Permalley
Py = nmag.MagMaterial(name=&quot;Py&quot;,
                      Ms=SI(860e3,&quot;A/m&quot;),
                      exchange_coupling=SI(13.0e-12, &quot;J/m&quot;))

# load mesh
sim.load_mesh(&quot;two_cubes.nmesh.h5&quot;,
              [(&quot;cube1&quot;, Py),(&quot;cube2&quot;, Co)],
              unit_length=SI(1e-9,&quot;m&quot;)
              ) 

# set initial magnetisation along the 
# positive x axis for both cubes, slightly off in z-direction
sim.set_m([0.999847695156, 0, 0.01745240643731])

ns = SI(1e-9, &quot;s&quot;) # corresponds to one nanosecond

sim.relax(save = [('averages', every('time', 0.01*ns)),
                  ('fields', every('time', 0.05*ns) | at('convergence'))])


</pre>
<p>The script is very similar to the one used in <a class="reference internal" href="manual.html#example-2">example 2</a>. However,
here we have two materials. The related changes are that we define two
magnetic materials, and assign them to objects <tt class="docutils literal"><span class="pre">Co</span></tt> and <tt class="docutils literal"><span class="pre">Py</span></tt>.</p>
<p>When loading the mesh:</p>
<pre class="literal-block">
sim.load_mesh(&quot;two_cubes.nmesh.h5&quot;,
              [(&quot;cube1&quot;, Py),(&quot;cube2&quot;, Co)],
              unit_length=SI(1e-9,&quot;m&quot;)
              )
</pre>
<p>we need to assign regions 1 and 2 in the mesh file (which correspond
to the two cubes) to the materials. This is done with this list of tuples:</p>
<pre class="literal-block">
[(&quot;cube1&quot;, Py),(&quot;cube2&quot;, Co)]
</pre>
<p>The first list entry is <tt class="docutils literal"><span class="pre">(&quot;cube1&quot;,</span> <span class="pre">Py)</span></tt> and tells nmag that we would
like to refer to the region 1 as <tt class="docutils literal"><span class="pre">cube1</span></tt>, and that we would like to
assign the material <tt class="docutils literal"><span class="pre">Py</span></tt> to this region. This entry refers to region
1 because it is the <em>first</em> entry in the list.</p>
<p>The second list entry is <tt class="docutils literal"><span class="pre">(&quot;cube2&quot;,</span> <span class="pre">Co)</span></tt> and tells nmag that we
would like to refer to the region 2 as <tt class="docutils literal"><span class="pre">cube2</span></tt>, and that we would
like to assign the material <tt class="docutils literal"><span class="pre">Co</span></tt> to this region.</p>
<p>If there was a region 3 in the mesh file, we would add a third list
entry, for example (&quot;cylinder&quot;,Co) for a Co cylinder.</p>
<p>Note that at this stage of nmag, the region name (such as <tt class="docutils literal"><span class="pre">cube1</span></tt>,
<tt class="docutils literal"><span class="pre">cube2</span></tt>, etc) are not used in the simulation, apart from diagnostic
purposes in progress messages.</p>
<p>Physically, what happens in this system is that the magnetisation of
the Cobalt cube aligns rather fast with the anisotropy direction and
then slowly forces the magnetisation of the PermAlloy cube into the
opposite direction (through the action of the stray field) to minimise
total energy of the configuration.</p>
<p>The Initial magnetisation is taken to point in x-direction. As this is an
unstable equilibrium direction for the magnetisation anisotropy of the
Cobalt cube, we slightly distort the initial magnetisation by adding a
tiny component in +z-direction.</p>
<p>It is instructive to compare the <a class="reference internal" href="manual.html#field">field</a>s and <a class="reference internal" href="manual.html#subfield">subfield</a>s for this
particular example with the list of fields and subfields for a
single-material simulation. In effect, all the fields that are related
to the properties of some particular magnetic component carry multiple
subfields. In particular, there is only one <tt class="docutils literal"><span class="pre">H_ext</span></tt> field, as the
externally applied field is experienced in the same way by all
materials, but the <tt class="docutils literal"><span class="pre">M*H</span></tt> energy density associated with <tt class="docutils literal"><span class="pre">H_ext</span></tt>
has a dependency on the magnetic component (through <tt class="docutils literal"><span class="pre">M</span></tt>), so we have
two subfields <tt class="docutils literal"><span class="pre">E_ext_Py</span></tt> and <tt class="docutils literal"><span class="pre">E_ext_Co</span></tt> in the field <tt class="docutils literal"><span class="pre">E_ext</span></tt>.</p>
<p>The situation is virtually identical with <tt class="docutils literal"><span class="pre">H_demag</span></tt>/<tt class="docutils literal"><span class="pre">E_demag</span></tt> and
the related charge density <tt class="docutils literal"><span class="pre">rho</span></tt> and magnetic scalar potential
<tt class="docutils literal"><span class="pre">phi</span></tt>. All the other relevant fields in this example turn out to be
related to a particular magnetic component.</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="28%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Field</th>
<th class="head">Subfield(s)</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>m</td>
<td>m_Py, m_Co</td>
<td>normalised magnetisation</td>
</tr>
<tr><td>M</td>
<td>M_Py, M_Co</td>
<td>magnetisation</td>
</tr>
<tr><td>H_total</td>
<td>H_total_Py, H_total_Co</td>
<td>total effective field</td>
</tr>
<tr><td>H_ext</td>
<td>H_ext</td>
<td>external (applied) field (only one)</td>
</tr>
<tr><td>E_ext</td>
<td>E_ext_Py, E_ext_Co</td>
<td>energy density of Py due to external field</td>
</tr>
<tr><td>H_anis</td>
<td>H_anis_Py, H_anis_Co</td>
<td>crystal anisotropy field</td>
</tr>
<tr><td>E_anis</td>
<td>E_anis_Py, E_anis_Co</td>
<td>crystal anisotropy energy density</td>
</tr>
<tr><td>H_exch</td>
<td>H_exch_Py, H_exch_Co</td>
<td>exchange field</td>
</tr>
<tr><td>E_exch</td>
<td>E_exch_Py, E_exch_Co</td>
<td>exchange energy</td>
</tr>
<tr><td>H_demag</td>
<td>H_demag</td>
<td>demagnetisation field (only one)</td>
</tr>
<tr><td>E_demag</td>
<td>E_demag_Py, E_demag_Co</td>
<td>demagnetisation field energy density</td>
</tr>
<tr><td>phi</td>
<td>phi</td>
<td>scalar potential for H_demag</td>
</tr>
<tr><td>rho</td>
<td>rho</td>
<td>magnetic charge density (div M)</td>
</tr>
<tr><td>H_total</td>
<td>H_total_Py, H_total_Co</td>
<td>total effective field</td>
</tr>
</tbody>
</table>
<p>The issue of multiple magnetic components becomes much more
interesting when we study multi-component alloys, i.e. if we associate
more than one type of magnetisation to a single region in the
mesh. Usually, we will then also have to introduce some &quot;generalized
anisotropy energy&quot; term of the form <tt class="docutils literal"><span class="pre">E=c*M_a*M_b</span></tt> that depends on
more than a single magnetisation subfield (see <a class="reference internal" href="manual.html#more-than-one-magnetic-material-exchange-coupled">More than one magnetic
material, exchange coupled</a>).</p>
<p>Once we have run the simulation using:</p>
<pre class="literal-block">
nsim two_cubes.py
</pre>
<p>we can analyse the results. For example, we can plot the magnetisation
of the two materials against time:</p>
<div align="center" class="align-center"><img alt="../example_two_materials/results.png" class="align-center" src="../example_two_materials/results.png" /></div>
<p>The blue lines represent the (soft) permalloy and the black lines show
the (hard) cobalt. Each thick line denotes the z-component of the corresponding material.</p>
<p>This plot has been created with the following command:</p>
<pre class="literal-block">
ncol two_cubes 0 m_Co_0 m_Co_1 m_Co_2 m_Py_0 m_Py_1 m_Py_2 | xmgrace -nxy -
</pre>
<p>We can further convert the field data into vtk files:</p>
<pre class="literal-block">
nmagpp --vtk=two_cubes.vtk two_cubes_dat.h5
</pre>
<p>and visualise their content. We start with the initial configuration
(Permalloy in blue on the left, Cobalt in black on the right, only 10
percent of the actual magnetisation vectors on the mesh nodes are
shown to improve the readability of the plots):</p>
<p>Time T=0 ps:</p>
<div align="center" class="align-center"><img alt="../example_two_materials/vis1.png" class="align-center" src="../example_two_materials/vis1.png" /></div>
<p>Time T=1e-10s=0.1ns: Cobalt is already pointing up, i.e. in the
direction of the anisotropy axis, while Permalloy has just started to
rotate.</p>
<div align="center" class="align-center"><img alt="../example_two_materials/vis2.png" class="align-center" src="../example_two_materials/vis2.png" /></div>
<p>Time T=0.3ns: Cobalt has reached its final configuration (pointing up)
and Permalloy is still rotating, but already pointing down (to
minimise the interaction energy between the cubes to the
demagnetisation stray fields).</p>
<div align="center" class="align-center"><img alt="../example_two_materials/vis3.png" class="align-center" src="../example_two_materials/vis3.png" /></div>
<p>Time T=1 ns: The final configuration has been reached.</p>
<div align="center" class="align-center"><img alt="../example_two_materials/vis4.png" class="align-center" src="../example_two_materials/vis4.png" /></div>
<!-- comment:
.. _`Example Larmor precession`: -->
</div>
<div class="section" id="example-larmor-precession">
<h2><a class="toc-backref" href="manual.html#id83">2.15&nbsp;&nbsp;&nbsp;Example: Larmor precession</a></h2>
<p>This example shows how to derive the period of the Larmor precession
for the magnetisation and compare the result from simulation to the
analytical solution. It is inspired by an example from the <a class="reference external" href="http://magnet.atp.tuwien.ac.at/scholz/magpar/">magpar</a>
documentation
(<a class="reference external" href="http://magnet.atp.tuwien.ac.at/scholz/magpar/doc/html/examples.html#sphere_larmor">http://magnet.atp.tuwien.ac.at/scholz/magpar/doc/html/examples.html#sphere_larmor</a>).</p>
<p>We us the <a class="reference external" href="../example_larmor/larmor.py">larmor.py</a> script:</p>
<blockquote>
<pre class="literal-block">
import nmag
from nmag import SI, every, at, si


#create simulation object and switch off
#the computation of the demagnetising field
sim = nmag.Simulation(do_demag = False)

# define magnetic material so that Js = mu0*Ms = 1 T
Py = nmag.MagMaterial(name=&quot;Py&quot;,
                      Ms=1.0*si.Tesla/si.mu0,
                      exchange_coupling=SI(13.0e-12, &quot;J/m&quot;),
                      llg_damping = SI(0.0)
                      )
# load mesh
sim.load_mesh(&quot;sphere1.nmesh.h5&quot;,
              [(&quot;sphere&quot;, Py)],
              unit_length=SI(1e-9,&quot;m&quot;)
             )

# set initial magnetisation
sim.set_m([1,1,1])

# set external field
Hs = nmag.vector_set(direction=[0.,0.,1.],
                     norm_list=[1.0],
                     units=1e6*SI('A/m')
                    )

ps = SI(1e-12, &quot;s&quot;)  # ps corresponds to one picosecond

# let the magnetisation precess around the direction of the applied field
sim.hysteresis(Hs,
               save=[('averages', every('time', 0.1*ps))],
               do=[('exit', at('time', 300*ps))])

</pre>
</blockquote>
<p>We turn off computation of the demagnetising field:</p>
<pre class="literal-block">
sim = nmag.Simulation(do_demag = False)
</pre>
<p>and set the damping term in the LLG equation to zero:</p>
<pre class="literal-block">
llg_damping = SI(0.0)
</pre>
<p>We set saturation magnetisation to Js = 1 T (see <a class="reference internal" href="manual.html#library-of-useful-si-constants">Library of useful si
constants</a>):</p>
<pre class="literal-block">
Ms=1.0*si.Tesla/si.mu0
</pre>
<p>We use a sphere as the magnetic object and, starting from a uniform
magnetic configuration along the [1,1,1] direction:</p>
<pre class="literal-block">
sim.set_m([1,1,1])
</pre>
<p>To compute the time development in the presence of a static field pointing in the z-direction, we ''abuse'' the hysteresis command (because this way we can conveniently save the data at equidistant time intervals). To do this, we need to find the sequence of applied fields (here it is only one, of course):</p>
<pre class="literal-block">
Hs = nmag.vector_set( direction=[0.,0.,1.],
                      norm_list=[1.0],
                      units=1e6*SI('A/m')
                     )
</pre>
<p>and then use the hysteresis command:</p>
<pre class="literal-block">
sim.hysteresis(Hs,
               save=[('averages', every('time', 0.1*ps))],
               do=[('exit', at('time', 300*ps))])
</pre>
<p>The <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> command will save the averages (which is what we need
to for the fit below) every 0.1 pico seconds. Once we reach the time
of 300 pico seconds, the method will exit.</p>
<p>The dynamics of the magnetisation is driven only by the
Zeeman effect, with a torque:</p>
<div align="center" class="align-center"><img alt="../example_larmor/torque.png" class="align-center" src="../example_larmor/torque.png" /></div>
<p>acting on the magnetisation m which is orthogonal to both m and H;
thus causing the magnetisation to precess around the applied field
direction. The frequency of the precession, called f_Larmor, is given
by:</p>
<div align="center" class="align-center"><img alt="../example_larmor/frequency.png" class="align-center" src="../example_larmor/frequency.png" /></div>
<p>where the parameter gamma, called gyromagnetic ratio, is taken to
have the following value (see <a class="footnote-reference" href="manual.html#id9" id="id8">[4]</a> ):</p>
<div align="center" class="align-center"><img alt="../example_larmor/gamma.png" class="align-center" src="../example_larmor/gamma.png" /></div>
<p>so that f_Larmor = 35.176 GHz and the period T = 1/f_Larmor =
0.0284284 ns.</p>
<p>We save the average magnetisation every 0.1 ps in order to have a
sufficient number of points to compute the period T.</p>
<p>We execute the script as usual:</p>
<pre class="literal-block">
$ nsim larmor.py
</pre>
<p>and extract the (spatially averaged) magnetisation data for all save time steps:</p>
<pre class="literal-block">
$ ncol larmor time m_Py_0 m_Py_1 m_Py_2 &gt; data.txt
</pre>
<p>Using <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a>, we extract the value of the Larmor period T from the x-component of the magnetisation:</p>
<pre class="literal-block">
$ gnuplot
</pre>
<p>and the following command plots the x component of the magnetisation
as a function of the simulation time, together with a fit for a
function <tt class="docutils literal"><span class="pre">f(x)</span></tt> (where <tt class="docutils literal"><span class="pre">x</span></tt> represents time):</p>
<pre class="literal-block">
gnuplot&gt; f(x) = A*sin(2*pi*x/B + C) + D
gnuplot&gt; B = 30
gnuplot&gt; fit f(x) &quot;data.txt&quot; u  ($1/1e-12):2 via A,B,C,D
gnuplot&gt; plot &quot;data.txt&quot; u ($1/1e-12):2, f(x)
</pre>
<p>The result is the following image:</p>
<div align="center" class="align-center"><img alt="../example_larmor/larmor_plot.png" class="align-center" src="../example_larmor/larmor_plot.png" /></div>
<p>The values for B in the fit, which corresponds to the unknown period
T, is initially set to 30 in order to help <a class="reference external" href="http://www.gnuplot.info/">Gnuplot</a> fit the curve.
Such fit on T gives the value 28.4293; this value
corresponds to 0.0284293 ns when rescaled by the 10e12 factor used for
the plotting, and shows a difference starting from the 5th digit when
compared to the analytical solution of 0.0284284 ns.</p>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id8">[4]</a></td><td>see the OOMMF manual, and in Werner Scholz thesis, after (3.7), llg_gamma_G = 2.210173e5 m/(As)</td></tr>
</tbody>
</table>
<!-- comment:
.. _`example 1Dperiodicity`: -->
</div>
<div class="section" id="example-1d-periodicity">
<h2><a class="toc-backref" href="manual.html#id84">2.16&nbsp;&nbsp;&nbsp;Example: 1D periodicity</a></h2>
<div class="section" id="introduction-periodic-boundary-conditions-macro-geometry">
<h3><a class="toc-backref" href="manual.html#id85">2.16.1&nbsp;&nbsp;&nbsp;Introduction periodic boundary conditions (&quot;macro geometry&quot;)</a></h3>
<p>Concerning the simulation of periodic magnetic structures, there are a
few somewhat subtle issues to be taken into account, both with respect
to the demagnetising and the exchange field.</p>
<p>The issue with the exchange field is that we may encounter situations
where the magnetic material crosses the boundary of an elementary
cell: a periodic array of non-touching spheres in a cubic lattice is
fundamentally different from its complement, a cubic lattice made of
spherical holes, insofar as that in the latter case, it is impossible
to do a simulation using periodic boundary conditions without
identifying degrees of freedom that live on boundaries of the
simulation cell. Nmag can deal with this automatically, provided the
mesh file contains periodicity information, i.e. data on how to
identify nodes on exterior faces.</p>
<p>As for the demagnetising field, the most important problem is that one
cannot ignore the effect of the faraway boundaries of the system: a
100 nm x 100 nm x 100 nm cell made of magnetic material in the center
of a large (three-dimensional) periodic array will experience very different demagnetising
fields depending on the shape of the outer boundaries of this array.
Assuming spatially constant magnetisation, if these cells form a
&quot;macroscopic&quot; (tree-dimensional) sphere, H_demag will be -1/3 M, while for a flat box,
H_demag may be very close to -M. Nmag takes these &quot;macro-geometry&quot;
effects into account by allowing the user to provide a geometrical
layout for a finite number (say, 100-1000) of cells that approximates
the shape of the faraway outer boundary of the system.</p>
<p>The macro geometry approach is described in <a class="footnote-reference" href="manual.html#id11" id="id10">[5]</a> which may serve as a
more detailed instruction to the concept.</p>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id10">[5]</a></td><td>Hans Fangohr, Giuliano Bordignon, Matteo Franchin, Andreas Knittel, Peter A. J. de Groot, Thomas Fischbacher. <em>A new approach to (quasi) periodic boundary conditions in micromagnetics: the macro geometry</em>, Journal of Applied Physics <strong>105</strong>, 07D529 (2009), Online at <a class="reference external" href="http://link.aip.org/link/?JAP/105/07D529">http://link.aip.org/link/?JAP/105/07D529</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="d-example">
<h3><a class="toc-backref" href="manual.html#id86">2.16.2&nbsp;&nbsp;&nbsp;1d example</a></h3>
<p>In this example, we simulate a single cell in the middle of a long
one-dimensional periodic array where for the purpose of computing the
demagnetising field, we take three extra copies of this cell to the
left and three copies to the right along the x axis. (For real
applications, one would use more copies. The only effect of additional
copies are to increase the setup time needed to compute an internal
boundary/boundary interaction matrix.)</p>
<p>The next <a class="reference internal" href="manual.html#example-2d-periodicity">example 2D periodicity</a> demonstrates the macro geometry
concept for a thin film. This is followed by the <a class="reference internal" href="manual.html#spin-waves-example">Spin-waves example</a>
which includes exchange coupling between periodic copies (and is of
more practical value).</p>
<p>The mesh of the central simulation cell used is described in <a class="reference external" href="../example_1Dperiodicity/cube.geo">cube.geo</a> which reads:</p>
<pre class="literal-block">
algebraic3d

# prism
solid prism = orthobrick (-7.50, -7.50, -7.50; 7.50, 7.50, 7.50) -maxh = 1.8000;
tlo prism;


</pre>
<p>Note that the mesh is centered around the origin. This is recommended for periodic simulations. (We need to document this better.) The resulting mesh is this (the periodic copies are not shown):</p>
<div align="center" class="figure">
<img alt="../example_1Dperiodicity/mesh.png" src="../example_1Dperiodicity/mesh.png" />
</div>
<p>The script <a class="reference external" href="../example_1Dperiodicity/periodic1.py">periodic1.py</a> reads:</p>
<pre class="literal-block">
import nmag
from nmag import SI

# define magnetic material
Py = nmag.MagMaterial(name=&quot;Py&quot;,
                      Ms=SI(1e6,&quot;A/m&quot;),
                      exchange_coupling=SI(13.0e-12, &quot;J/m&quot;)
                      )

# size of simulation cell, plus extra spacing
# to avoid exchange interaction across interfaces
# between repeated copies of the simulation cell.
x_lattice = 15.01  # the spacing is 0.01
y_lattice = 0.0
z_lattice = 0.0


# list to store the lattice points where the periodic
# copies will be placed 
lattice_points = []

for xi in range(-3,4):
    lattice_points.append([xi*x_lattice,0.0*y_lattice,0.0*z_lattice])

#  create data structure pbc for this macro geometry
pbc = nmag.SetLatticePoints(vectorlist=lattice_points, scalefactor=SI(1e-9,'m'))

#create simulation object,  passing macro geometry data structure
sim = nmag.Simulation(periodic_bc=pbc.structure)

# load mesh
sim.load_mesh(&quot;cube1.nmesh.h5&quot;, [(&quot;repeated-cube-1D&quot;, Py)], unit_length=SI(1e-9,&quot;m&quot;) )

# set initial magnetisation along the periodic axis
sim.set_m([1.0,0,0])

# compute the demagnetising field
sim.advance_time(SI(0,&quot;s&quot;))

# probe demag field at the centre of the cube, function
# returns an SI-Value ('siv')
H_demag = sim.probe_subfield_siv('H_demag', [0,0,0])

print &quot;H_demag_x at centre of cube = &quot;, H_demag[0]
print &quot;H_demag_y at centre of cube = &quot;, H_demag[1]
print &quot;H_demag_z at centre of cube = &quot;, H_demag[2]


</pre>
<p>Setup can be splitted into three steps. In the first step we set the
x_lattice parameter to be slightly larger than the dimension of the
unit cell (in order not to have any overlap between the cells) and set
the y_lattice and z_lattice parameters to zero to indicate no
periodidicity along these directions</p>
<pre class="literal-block">
x_lattice = 15.01 # the spacing is 0.01
y_lattice = 0.0
z_lattice = 0.0
</pre>
<p>In the second step we define the lattice points where we want
the periodic copies to be:</p>
<pre class="literal-block">
for xi in range(-3,4):
    lattice_points.append([xi*x_lattice,0.0*y_lattice,0.0*z_lattice])
</pre>
<p>and in the third step we define the object whose structure attribute
will be used as the parameter in the definition of the simulation
object</p>
<pre class="literal-block">
pbc = nmag.SetLatticePoints(vectorlist=lattice_points, scalefactor=SI(1e-9,'m'))

#create simulation object
sim = nmag.Simulation(periodic_bc=pbc.structure)
</pre>
<p>The remaining part of the script computes the demagnetisation field at
the center of the cube. This calculation can be carried out for a
varying number of copies of the simulation cell. The next figures show
components of demagnetising field in the center of the cube as a
function of the number of periodic copies. As in the code above, we
impose an uniform magnetisation along the periodic x-axis. The first
figure shows the demagnetisation field along the x-axis, and the
second figure along the y-axis. In both figures, we have added green
crosses that have been obtained by computing the demagfield using
OOMMF (where in OOMMF we have actually made the simulation cell larger
and larger to represent the growing number of periodic copies).</p>
<div align="center" class="align-center"><img alt="../example_1Dperiodicity/periodic1_in_axis.png" class="align-center" src="../example_1Dperiodicity/periodic1_in_axis.png" /></div>
<p>Demagnetising field as a function of the number of periodic
copies with the magnetisation aligned along the periodic axis.</p>
<div align="center" class="align-center"><img alt="../example_1Dperiodicity/periodic1_out_of_axis.png" class="align-center" src="../example_1Dperiodicity/periodic1_out_of_axis.png" /></div>
<p>Demagnetising field as a function of the number of periodic
copies with the magnetisation aligned along an axis orthogonal
to the periodic one.</p>
</div>
</div>
<div class="section" id="id12">
<span id="example-2d-periodicity"></span><h2><a class="toc-backref" href="manual.html#id87">2.17&nbsp;&nbsp;&nbsp;Example: 2D periodicity</a></h2>
<p>This example is another application of the macro-geometry feature,
where we now deal with a 2D &quot;thin film&quot; system. The unit cell is a
30x10x10 nm^3 prism</p>
<div align="center" class="align-center"><img alt="../example_2Dperiodicity/mesh.png" class="align-center" src="../example_2Dperiodicity/mesh.png" /></div>
<p>where we take 10 copies in x- and 40 copies in y-direction to create
the macro geometry.</p>
<p>The script <a class="reference external" href="../example_2Dperiodicity/no_periodic.py">no_periodic.py</a> simulates behaviour of
just the unit cell of size 30x10x10 nm^3 (without any periodic
copies):</p>
<pre class="literal-block">
import nmag
from nmag import SI, every, at

# define magnetic material
Py = nmag.MagMaterial(name=&quot;Py&quot;,
                      Ms=SI(1e6,&quot;A/m&quot;),
                      exchange_coupling=SI(13.0e-12, &quot;J/m&quot;)
                      )

#create simulation object
sim = nmag.Simulation()

# load mesh
sim.load_mesh(&quot;prism.nmesh.h5&quot;, [(&quot;no-periodic&quot;, Py)], unit_length=SI(1e-9,&quot;m&quot;) )

# set initial magnetisation
sim.set_m([1.,1.,1.])

# loop over the applied field
s = SI(1,&quot;s&quot;)

sim.relax(save=[('averages','fields', every('time',5e-12*s) | at('convergence'))])


</pre>
<p>and the relaxation curves are obtained via:</p>
<pre class="literal-block">
set term postscript enhanced color
set out 'no_periodic.ps'
set xlabel 'time (s)'
set ylabel 'M / Ms'
plot 'plot_no_periodic.dat' u 1:2 ti 'Mx' w lp, \
     'plot_no_periodic.dat' u 1:3 ti 'My' w lp, \
     'plot_no_periodic.dat' u 1:4 ti $

</pre>
<p>which creates the following plot:</p>
<div align="center" class="align-center"><img alt="../example_2Dperiodicity/no_periodic.png" class="align-center" src="../example_2Dperiodicity/no_periodic.png" /></div>
<p>From this plot we can see that with using only the unit cell the
magnetisation aligns along the x-axis at equilibrium.</p>
<p>We now move to the macro geometry of a thin film with dimensions 400x300x10nm^3 which is realised in <a class="reference external" href="../example_2Dperiodicity/periodic2.py">periodic2.py</a>.</p>
<!-- comment:

Employing periodicity means to break down the number of degrees of
freedom in a complex system by introducing the extra constraint that
magnetisation will be the same within all cells.
In principle, we have
some freedom in the choice of cell whose behaviour will be
replicated. While this most often will be the central cell of our
sample, there are some situations where one may want to place this in
a different position. For the sake of providing an example, we put our
unit cell on the (-1,-1, 0) point of the lattice as shown in
`periodic2.py <../example_2Dperiodicity/periodic2.py>`__ and let the
system relax. -->
<pre class="literal-block">
import nmag
from nmag import SI, every, at

# define magnetic material
Py = nmag.MagMaterial(name=&quot;Py&quot;,
                      Ms=SI(1e6,&quot;A/m&quot;),
                      exchange_coupling=SI(13.0e-12, &quot;J/m&quot;)
                      )

# size of the simulation cell, plus extra spacing 
x_lattice = 30.01  # the spacing is 0.01 to avoid exchange coupling
y_lattice = 10.01  # between repeated copies of the simualtion cell
z_lattice = 0.0


# list to store the lattice points where the periodic
# copies of the simulation cell will be placed 
lattice_points = []

for xi in range(-4,6):
    for yi in range(-19,21):
        lattice_points.append([xi*x_lattice,yi*y_lattice,0.0*z_lattice])

# create data structure pbc for this macro geometry
pbc = nmag.SetLatticePoints(vectorlist=lattice_points, scalefactor=SI(1e-9,'m'))

#create simulation object, passing macro geometry data structure
sim = nmag.Simulation(periodic_bc=pbc.structure)


# load mesh
sim.load_mesh(&quot;prism.nmesh.h5&quot;, [(&quot;repeated-prism-2D&quot;, Py)], unit_length=SI(1e-9,&quot;m&quot;) )

# set initial magnetisation
sim.set_m([1.,1.,1.])

# loop over the applied field
s = SI(1,&quot;s&quot;)
sim.relax(save=[('averages', 'fields', every('time',5e-12*s) | at('convergence'))])


</pre>
<p>As in the previous example, we first define the three unit vectors of
the lattice, again slightly larger than the dimension of the unit cell
to avoid overlapping (and thus to eleminate any exchange coupling
across the interfaces for this demonstration of the demagnetisation effects):</p>
<pre class="literal-block">
x_lattice = 30.01  # the spacing is 0.01
y_lattice = 10.01  # the spacing is 0.01
z_lattice = 0.0
</pre>
<p>Then we define where the copies will be placed:</p>
<pre class="literal-block">
for xi in range(-4,6):
    for yi in range(-19,21):
        lattice_points.append([xi*x_lattice,yi*y_lattice,0.0*z_lattice])

# copies of the system along the x-axis
pbc = nmag.SetLatticePoints(vectorlist=lattice_points, scalefactor=SI(1e-9,'m'))
</pre>
<p>The simulation cell is (always) the one at the (0,0,0) lattice
point. The for loops therefore place 4 copies of the simulation cell
in the negative x direction [i.e. (-4,0,0), (-3,0,0), (-2,0,0), and
(-1,0,0)] and 5 in the positive the x direction [i.e. (1,0,0),
(2,0,0), (3,0,0), (4,0,0), (5,0,0)]. The translation vector (0,0,0)
corresponds to the actual simulation cell.</p>
<p>Similarly, the inner for loop places 20 copies along the positive
y-axis and 19 along the negative one.</p>
<p>We set the same initial configuration as before, with a uniform
magnetisation along [1,1,1], and let the system evolve towards the
equilibrium.</p>
<p>The outcome is shown in the following figure:</p>
<div align="center" class="align-center"><img alt="../example_2Dperiodicity/periodic2.png" class="align-center" src="../example_2Dperiodicity/periodic2.png" /></div>
<p>where we notice that the final configuration is now with the
magnetisation aligned along the (negative) y axis, and not along the x
axis as before. The alignment along the y-direction is expected, as
now the macro geometry has a total size of 300.09 nm times 400.39 nm
(30 nm x 10 copies plus spacings along the x direction times 10 nm x
40 copies plus spacings along the y direction) times 10nm (no periodic
copies along the z direction), so the longest side now is along the y
direction. The demagnetisation energy of the macro geometry drives the
alignment of the magnetisation with the y-direction.</p>
<p>Other usage examples include this study <a class="footnote-reference" href="manual.html#id14" id="id13">[6]</a> of an array of interacting triangular rings.</p>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id13">[6]</a></td><td>Giuliano Bordignon, Thomas Fischbacher, Matteo Franchin, Jurgen P. Zimmermann, Peter A. J. de Groot, Hans Fangohr, <em>Numerical studies of demagnetizing effects in triangular ring arrays</em>, Journal of Applied Physics <strong>103</strong> 07D932 (2008), online at <a class="reference external" href="http://eprints.soton.ac.uk/50995/">http://eprints.soton.ac.uk/50995/</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="example-spin-waves-in-periodic-system">
<span id="spin-waves-example"></span><h2><a class="toc-backref" href="manual.html#id88">2.18&nbsp;&nbsp;&nbsp;Example: Spin-waves in periodic system</a></h2>
<p>Starting from a magnetisation out of equilibrium, we study the time
development of the magnetisation, and track -visually- the spin waves.</p>
<p>The geometry is a thin film with dimensions 30 nm x 9 nm x 0.2 nm along
the x,y and z axes, respectively. The mesh is centered at (0,0,0)
and periodic along the x direction, so that the nodes with coordinates
(15.0,y,z) will be considered as equivalent to the nodes with coordinates (-15.0,y,z).</p>
<div align="center" class="align-center"><img alt="../example_periodic_spinwaves/periodic_mesh.png" class="align-center" src="../example_periodic_spinwaves/periodic_mesh.png" /></div>
<p>The mesh is contained in <a class="reference external" href="../example_periodic_spinwaves/periodic.nmesh">periodic.nmesh</a> and
has been produced using <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> (from  <a class="reference external" href="http://nmag.soton.ac.uk/nmag/0.1/manual/example_periodic_spinwaves/periodic.geo">periodic.geo</a>) and the <a class="reference internal" href="manual.html#nmeshmirror">nmeshmirror</a> command to create required periodic structure</p>
<pre class="literal-block">
$ nmeshmirror netgen.nmesh 1e-6 1e-6 -1,0,0 periodic.nmesh
</pre>
<div class="section" id="relaxation-script">
<h3><a class="toc-backref" href="manual.html#id89">2.18.1&nbsp;&nbsp;&nbsp;Relaxation script</a></h3>
<p>To see how the system relaxes, we use the following
script (<a class="reference external" href="../example_periodic_spinwaves/spinwaves.py">spinwaves.py</a>):</p>
<pre class="literal-block">
import nmag
from nmag import SI
import math

# define magnetic material
Py = nmag.MagMaterial(name=&quot;Py&quot;,
                      Ms=SI(1e6,&quot;A/m&quot;),
                      exchange_coupling=SI(13.0e-12, &quot;J/m&quot;),
                      llg_damping = SI(0.02,&quot;&quot;)
                      )

# lattice spacings along the main axes; 
# the value must be zero for no periodic copies,
# equal to the mesh dimension along the 
# given axis otherwise
x_lattice = 30.0
y_lattice = 0.0
z_lattice = 0.0


# list to store the lattice points where the periodic
# copies will be placed 
lattice_points = []

for xi in range(-1,2):
    lattice_points.append([xi*x_lattice,0.0*y_lattice,0.0*z_lattice])

# copies of the system along the x-axis
pbc = nmag.SetLatticePoints(vectorlist=lattice_points, scalefactor=SI(1e-9,'m'))

#create simulation object
sim = nmag.Simulation(periodic_bc=pbc.structure)

# load mesh
sim.load_mesh(&quot;periodic.nmesh&quot;, [(&quot;periodic-film&quot;, Py)], unit_length=SI(1e-9,&quot;m&quot;) )

print ocaml.mesh_plotinfo_periodic_points_indices( sim.mesh.raw_mesh )

# function to set the magnetisation 
def perturbed_magnetisation(pos):
    x,y,z = pos
    newx = x*1e9
    newy = y*1e9
    if 8&lt;newx&lt;14 and -3&lt;newy&lt;3:
        # the magnetisation is twisted a bit 
        return [1.0, 5.*(math.cos(math.pi*((newx-11)/6.)))**3 *\
                        (math.cos(math.pi*(newy/6.)))**3, 0.0]
    else:
        return [1.0, 0.0, 0.0]


# set initial magnetisation
sim.set_m(perturbed_magnetisation)

# let the system relax generating spin waves
s = SI(1,&quot;s&quot;)
from nsim.when import every, at
sim.relax(save=[('averages','fields', every('time',0.05e-12*s) | at('convergence'))])


</pre>
<p>To execute this script, we call the <a class="reference internal" href="manual.html#nsim">nsim</a> executable, for example (on linux):</p>
<pre class="literal-block">
$ nsim spinwaves.py
</pre>
<p>As in the previous examples, we first need to import the modules
necessary for the simulation, define the material of the magnetic
object, load the mesh and set the initial configuration of the
magnetisation. Here, we start from a spatially non-homogeneous
configuration in order to excite spin waves. Nmag allows us to provide a
function to be sampled on the mesh that defines a particular
magnetisation configuration.</p>
<div align="center" class="align-center"><img alt="../example_periodic_spinwaves/initial_magn.png" class="align-center" src="../example_periodic_spinwaves/initial_magn.png" /></div>
<p>In our case, we use the function</p>
<pre class="literal-block">
def perturbed_magnetisation(pos):
    x,y,z = pos
    newx = x*1e9
    newy = y*1e9
    if 8&lt;newx&lt;14 and -3&lt;newy&lt;3:
        # the magnetisation is twisted a bit
        return [1.0, 5.*(math.cos(math.pi*((newx-11)/6.)))**3 *\
                        (math.cos(math.pi*(newy/6.)))**3, 0.0]
    else:
        return [1.0, 0.0, 0.0]
</pre>
<p>which is then passed on to <a class="reference internal" href="manual.html#set-m">set_m</a></p>
<pre class="literal-block">
# set initial magnetisation
sim.set_m(perturbed_magnetisation)
</pre>
</div>
<div class="section" id="visualising-the-magnetisation-evolution">
<h3><a class="toc-backref" href="manual.html#id90">2.18.2&nbsp;&nbsp;&nbsp;Visualising the magnetisation evolution</a></h3>
<p>Once the calculation has finished, we can see how the system relaxed
by means of snapshots of the magnetisation evolution.</p>
<p>The <a class="reference internal" href="manual.html#nmagpp">nmagpp</a> command allows us to create vtk files
from the data saved with the <tt class="docutils literal"><span class="pre">save</span></tt> option in the <tt class="docutils literal"><span class="pre">relax</span></tt> command</p>
<pre class="literal-block">
nmagpp --vtk=fields spinwaves
</pre>
<p>The first few frames that show the evolution of the magnetic
configuration are shown below.</p>
<div align="center" class="figure">
<img alt="evolution-1" src="../example_periodic_spinwaves/evolution-1.png" />
<p class="caption">Initial magnetisation configuration.</p>
</div>
<div align="center" class="figure">
<img alt="evolution-2" src="../example_periodic_spinwaves/evolution-2.png" />
<p class="caption">Magnetisation configuration after 0.15 ps. It is clearly visible
that the spin waves travel from the center of the disturbance to the
right and penetrate the system immediately from the left (due to the
periodic boundary conditions in the x-direction).</p>
</div>
<div align="center" class="figure">
<img alt="evolution-3" src="../example_periodic_spinwaves/evolution-3.png" />
<p class="caption">Magnetisation configuration after 0.25 ps.</p>
</div>
<!-- comment
.. include:: example_thermal_cube/doc.txt -->
</div>
</div>
<div class="section" id="example-post-processing-of-saved-field-data">
<h2><a class="toc-backref" href="manual.html#id91">2.19&nbsp;&nbsp;&nbsp;Example: post processing of saved field data</a></h2>
<p>Suppose we have saved spatially resolved fields (as, for example, in
<a class="reference internal" href="manual.html#example-2">example 2</a>), and we would like to read those from the data file to
process the data further.</p>
<p>We can use the <a class="reference internal" href="manual.html#nmagpp">nmagpp</a> tool if it provides the required functionality.</p>
<p>Alternatively, we can write a Python script that:</p>
<ol class="arabic simple">
<li>reads the data from the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> file</li>
<li>carries out the required post processing and/or saves the data in
(another) format.</li>
</ol>
<p>The program <a class="reference external" href="../example2/read_h5.py">read_h5.py</a>
demonstrates how to read the saved configuration with id=0 of the <tt class="docutils literal"><span class="pre">m_Py</span></tt>
subfield, and to print this to the screen.</p>
<pre class="literal-block">
import nmag

#read data, positions, and sites from h5 file
m=nmag.get_subfield_from_h5file('bar_dat.h5','m_Py',id=0)
pos=nmag.get_subfield_positions_from_h5file('bar_dat.h5','m_Py')
site=nmag.get_subfield_sites_from_h5file('bar_dat.h5','m_Py')

#can carry out some sanity checks (but is not necessary)
assert m.shape == pos.shape
assert len(m) == len(site)

#print the data
for i in range(len(m)):
    print site[i], pos[i], m[i]

</pre>
<p>The functions <a class="reference internal" href="manual.html#get-subfield-from-h5file">get_subfield_from_h5file</a>,
<a class="reference internal" href="manual.html#get-subfield-positions-from-h5file">get_subfield_positions_from_h5file</a> and
<a class="reference internal" href="manual.html#get-subfield-sites-from-h5file">get_subfield_sites_from_h5file</a> allow in principle to retrieve all the
field data from the h5 files and stores this in the variables <tt class="docutils literal"><span class="pre">m</span></tt>,
<tt class="docutils literal"><span class="pre">pos</span></tt>, and <tt class="docutils literal"><span class="pre">site</span></tt>, respectively.</p>
<p>The program, when run like this:</p>
<pre class="literal-block">
$ nsim read_h5.py
</pre>
<p>in the <a class="reference internal" href="manual.html#example-2">example 2</a> directory, produces output starting as follows (assuming the <tt class="docutils literal"><span class="pre">bar_dat.h5</span></tt> file exists):</p>
<pre class="literal-block">
[0] [ 0.  0.  0.] [ 0.70710677  0.          0.70710677]
[1] [  3.00000000e-09   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[2] [  6.00000000e-09   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[3] [  9.00000000e-09   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[4] [  1.20000000e-08   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[5] [  1.50000000e-08   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[6] [  1.80000000e-08   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[7] [  2.10000000e-08   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[8] [  2.40000000e-08   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[9] [  2.70000000e-08   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[10] [  3.00000000e-08   0.00000000e+00   0.00000000e+00] [ 0.70710677  0.          0.70710677]
[11] [  3.00000000e-08   3.00000000e-08   1.00000000e-07] [ 0.70710677  0.          0.70710677]
[12] [  3.00000000e-08   2.70000000e-08   1.00000000e-07] [ 0.70710677  0.          0.70710677]
</pre>
<p>We can see that the <a class="reference internal" href="manual.html#site">site</a> index is (here) just an integer, the position
(in nanometre) is shown as a triplet of three scalars, and the normalised
magnetisation is also a vector with three components.</p>
<p>The data (in the arrays <tt class="docutils literal"><span class="pre">m</span></tt>, <tt class="docutils literal"><span class="pre">site</span></tt> and <tt class="docutils literal"><span class="pre">position</span></tt> in this
example) can be manipulated as explained in the <a class="reference internal" href="manual.html#numpy">numpy</a> documentation,
because it is of type <tt class="docutils literal"><span class="pre">numpy</span> <span class="pre">array</span></tt>. Numpy provides a powerful matrix
processing environment.</p>
</div>
<div class="section" id="example-spin-transfer-torque-zhang-li-model">
<h2><a class="toc-backref" href="manual.html#id92">2.20&nbsp;&nbsp;&nbsp;Example: Spin transfer torque (Zhang-Li model)</a></h2>
<p>Nmag provides support for the Zhang-Li extension to the
Landau-Lifshitz-Gilbert (LLG) equation <a class="footnote-reference" href="manual.html#id16" id="id15">[7]</a>, in order to model the interaction
between a uniform electric current density and a spatially varying
magnetisation. The extened LLG equation reads</p>
<div align="center" class="align-center"><img alt="../example_zhangli1/eq_zhangli_llg.png" class="align-center" src="../example_zhangli1/eq_zhangli_llg.png" /></div>
<p>where the first two terms on the right-hand side are the normal LLG equation, and the extra terms come from the Zhang-Li model, and</p>
<div align="center" class="align-center"><img alt="../example_zhangli1/eq_zhangli_llg_d.png" class="align-center" src="../example_zhangli1/eq_zhangli_llg_d.png" /></div>
<p>The central column shows the method which can be used to set
the field (<tt class="docutils literal"><span class="pre">Simulation.set_m</span></tt> or <tt class="docutils literal"><span class="pre">Simulation.set_H_ext</span></tt>) or
the name of the corresponding parameter in the material definition
(for example, <tt class="docutils literal"><span class="pre">mat</span> <span class="pre">=</span> <span class="pre">MagMaterial(Ms=SI(0.8e6,</span> <span class="pre">&quot;A/m&quot;),</span> <span class="pre">...)</span></tt>).
The current density appears only throughout the quantity <tt class="docutils literal"><span class="pre">v</span></tt>, which
we define as:</p>
<div align="center" class="align-center"><img alt="../example_zhangli1/eq_v.png" class="align-center" src="../example_zhangli1/eq_v.png" /></div>
<p>with:</p>
<div align="center" class="align-center"><img alt="../example_zhangli1/eq_v_d.png" class="align-center" src="../example_zhangli1/eq_v_d.png" /></div>
<p>In this and in the next examples we show how to set up a micromagnetic
simulation including such spin transfer torque effects.
We show how the current density can be specified and how the required
parameters can be included in the material definitions.</p>
<p>As a first example, we consider a thin Permalloy film which develops
a vortex in the center. We compute the dynamics of the vortex
as a response to the application of a current.</p>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id15">[7]</a></td><td>S. Zhang and Z. Li, <em>Roles of Nonequilibrium Conduction Electrons
on the Magnetization Dynamics of Ferromagnets</em>, Physical Review
Letters <strong>93</strong>, 127204 (2004), online at
<a class="reference external" href="http://link.aps.org/doi/10.1103/PhysRevLett.93.127204">http://link.aps.org/doi/10.1103/PhysRevLett.93.127204</a></td></tr>
</tbody>
</table>
<div class="section" id="current-driven-motion-of-a-vortex-in-a-thin-film">
<h3><a class="toc-backref" href="manual.html#id93">2.20.1&nbsp;&nbsp;&nbsp;Current-driven motion of a vortex in a thin film</a></h3>
<p>The system under investigation is a 100 x 100 x 10 nm Permalloy film.
The mesh is stored in the file
<a class="reference external" href="../example_zhangli1/pyfilm.nmesh.h5">pyfilm.nmesh.h5</a>.</p>
<p>The simulation is subdivided in two parts:</p>
<ul class="simple">
<li>In part I, the system is
relaxed to obtain the initial magnetisation configuration when the
current <strong>is not</strong> applied, which is just a vortex in the center of
the film.</li>
<li>In part II, the vortex magnetisation obtained in part I is
loaded and used as the initial magnetisation configuration. A current
is applied and the magnetisation dynamics is analysed by
saving periodically the data (the magnetisation, the other fields and
their averages).</li>
</ul>
<p>Here we use two separate simulation scripts to carry out part I and
part II subsequentely. This is the approach that is easiest to
understand. Once the basic ideas have become clear, it is often a good
idea to write only one simulation script that carries out both part I
and part II. (Indeed many of the parameters, such as the saturation
magnetisation or the exchange coupling need to be specified in each of
the two scripts leading to possible errors: for example if one decides
to investigate a different material and changes the parameters just in
one file and forgets the other, etc.). In the next section
(<a class="reference internal" href="manual.html#example-current-driven-magnetisation-precession-in-nanopillars">Example: Current-driven magnetisation precession in nanopillars</a>), we present
a more robust approach, where both part I and part II are executed by
just one script.</p>
</div>
<div class="section" id="part-i-relaxation">
<h3><a class="toc-backref" href="manual.html#id94">2.20.2&nbsp;&nbsp;&nbsp;Part I: Relaxation</a></h3>
<p>The first script carries out a normal micromagnetic simulation
(i.e. no spin transfer torque), and determines the relaxed
magnetisation configuration for a given geometry, material and initial
configuration. It saves the final magnetisation to disk. Here is the
full listing of <a class="reference external" href="../example_zhangli1/relaxation.py">relaxation.py</a>
:</p>
<pre class="literal-block">
# We model a bar 100 nm x 100 nm x 10 nm where a vortex sits in the center.
# This is part I: we just do a relaxation to obtain the shape of the vortex.
import math, nmag
from nmag import SI, at
from nsim.si_units.si import degrees_per_ns

# Define the material
mat_Py = nmag.MagMaterial(name=&quot;Py&quot;,
                          Ms=SI(0.8e6,&quot;A/m&quot;),
                          exchange_coupling=SI(13.0e-12, &quot;J/m&quot;),
                          llg_gamma_G=SI(0.2211e6, &quot;m/A s&quot;),
                          llg_damping=1.0)

# Define the simulation object and load the mesh
sim = nmag.Simulation()
sim.load_mesh(&quot;pyfilm.nmesh.h5&quot;, [(&quot;Py&quot;, mat_Py)], unit_length=SI(1e-9,&quot;m&quot;))

# Set a initial magnetisation which will relax into a vortex
def initial_m(p):
  x, y, z = p
  return [-(y-50.0e-9), (x-50.0e-9), 40.0e-9]

sim.set_m(initial_m)

# Set convergence parameters and run the simulation
sim.set_params(stopping_dm_dt=1.0*degrees_per_ns)
sim.relax(save=[('fields', at('step', 0) | at('stage_end'))])

# Write the final magnetisation to file &quot;vortex_m.h5&quot;
sim.save_restart_file(&quot;vortex_m.h5&quot;)

</pre>
<p>After importing the usual Nmag module and helper objects, we define
the material, create the simulation object and load the mesh,
(similar to what is shown in previous examples):</p>
<pre class="literal-block">
# Define the material
mat_Py = nmag.MagMaterial(name=&quot;Py&quot;,
                          Ms=SI(0.8e6,&quot;A/m&quot;),
                          exchange_coupling=SI(13.0e-12, &quot;J/m&quot;),
                          llg_gamma_G=SI(0.2211e6, &quot;m/A s&quot;),
                          llg_damping=1.0)

# Define the simulation object and load the mesh
sim = nmag.Simulation()
sim.load_mesh(&quot;pyfilm.nmesh.h5&quot;, [(&quot;Py&quot;, mat_Py)], unit_length=SI(1e-9,&quot;m&quot;))
</pre>
<p>Notice that the damping parameter <tt class="docutils literal"><span class="pre">llg_damping</span></tt> is set to a high value,
to allow for quick relaxation of the magnetisation.
We write a function <tt class="docutils literal"><span class="pre">initial_m</span></tt> that is being given the position of each
site in the mesh as a vector <tt class="docutils literal"><span class="pre">p</span></tt> with three components, and which returns
an initial magnetisation vector. This vector is chosen such that the initial
magnetisation that is described by this function is likely to relax into a
vortex configuration:</p>
<pre class="literal-block">
def initial_m(p):
  x, y, z = p
  return [-(y-50.0e-9), (x-50.0e-9), 40.0e-9]
</pre>
<p>The magnetisation at point <tt class="docutils literal"><span class="pre">p</span></tt> is obtained from a 90 degree rotation
of the vector which connects <tt class="docutils literal"><span class="pre">p</span></tt> to the center of the film.
This vector doesn't have to be normalised: Nmag will take care of
normalising it for us.</p>
<p>We need to instruct the simulation object <tt class="docutils literal"><span class="pre">sim</span></tt> to use this function
to set the magnetisation:</p>
<pre class="literal-block">
sim.set_m(initial_m)
</pre>
<p>We set the criterion to be used to decide when the magnetisation has
relaxed. The value used here in <a class="reference internal" href="manual.html#set-params">set_params</a> (i.e. one degree per
nanosecond) is the default value (so we could omit this, but we change
the value in the second part of this example):</p>
<pre class="literal-block">
sim.set_params(stopping_dm_dt=1.0*degrees_per_ns)
</pre>
<p>We finally run the simulation using the <a class="reference internal" href="manual.html#relax">relax</a> command until the
convergence criterion dm/dt &lt; 1 degree per nanosecond is
fullfilled. In the process, we save spatially resolved data for all
fields at step 0, and the same data at the end of the stage
(i.e. when an equilibrium has been reached, just before the <a class="reference internal" href="manual.html#relax">relax</a>
function returns):</p>
<pre class="literal-block">
sim.relax(save=[('fields', at('step', 0) | at('stage_end'))])
</pre>
<p>We finally save the relaxed magnetisation to a file using the function
<a class="reference internal" href="manual.html#save-restart-file">save_restart_file</a>, so that we can use this in part 2 as the initial
configuration:</p>
<pre class="literal-block">
sim.save_restart_file(&quot;vortex_m.h5&quot;)
</pre>
<p>We can launch the script with the command:</p>
<pre class="literal-block">
$ nsim relaxation.py
</pre>
<p>The output files for this simulation will have the prefix <tt class="docutils literal"><span class="pre">relaxation</span></tt> in
their names. The script saves the magnetisation at the beginning
(before relaxation) and at the end (after relaxation). The magnetisations
can be extracted and saved into vtk files using the command
<tt class="docutils literal"><span class="pre">nmagpp</span> <span class="pre">relaxation</span> <span class="pre">--vtk=m.vtk</span></tt>, as usual. MayaVi can then be used
to show the initial magnetisation (as described by the <tt class="docutils literal"><span class="pre">initial_m</span></tt> function):</p>
<div align="center" class="figure">
<img alt="zhangli-1" src="../example_zhangli1/m-begin.png" />
</div>
<p>The magnetisation at the end of the relaxation process:</p>
<div align="center" class="figure">
<img alt="zhangli-2" src="../example_zhangli1/m-end.png" />
</div>
<p>The relaxed vortex is much smaller than the initial one.  The
important thing to notice is that such a magnetisation configuration
has now been saved into the file <tt class="docutils literal"><span class="pre">vortex_m.h5</span></tt> which will be used as
the initial magnetisation for part II of this simulation, where we
study the current driven dynamics of the vortex.</p>
</div>
<div class="section" id="part-ii-current-driven-dynamics">
<h3><a class="toc-backref" href="manual.html#id95">2.20.3&nbsp;&nbsp;&nbsp;Part II: Current driven dynamics</a></h3>
<p>For part II we need to use a slightly modified version of the script
used for part I. Here is the full listing of
<a class="reference external" href="../example_zhangli1/stt.py">stt.py</a> :</p>
<pre class="literal-block">
# We model a bar 100 nm x 100 nm x 10 nm where a vortex sits in the center.
# This is part II: we load the vortex from file and apply a spin-polarised current

import nmag
from nmag import SI, every, at

# Define the material
mat_Py = nmag.MagMaterial(name=&quot;Py&quot;,
                          Ms=SI(0.8e6,&quot;A/m&quot;),
                          exchange_coupling=SI(13.0e-12, &quot;J/m&quot;),
                          llg_gamma_G=SI(0.2211e6, &quot;m/A s&quot;),
                          llg_polarisation=1.0,
                          llg_xi=0.05,
                          llg_damping=0.1)

# Define the simulation object and load the mesh
sim = nmag.Simulation()
sim.load_mesh(&quot;pyfilm.nmesh.h5&quot;, [(&quot;Py&quot;, mat_Py)], unit_length=SI(1e-9,&quot;m&quot;))

# Set the initial magnetisation: part II uses the one saved by part I
sim.load_m_from_h5file(&quot;vortex_m.h5&quot;)
sim.set_current_density([1e12, 0, 0], unit=SI(&quot;A/m^2&quot;))

sim.set_params(stopping_dm_dt=0.0) # * WE * decide when the simulation should stop!

sim.relax(save=[('fields', at('convergence') | every('time', SI(1.0e-9, &quot;s&quot;))),
                ('averages', every('time', SI(0.05e-9, &quot;s&quot;)) | at('stage_end'))],
          do = [('exit', at(&quot;time&quot;, SI(10e-9, &quot;s&quot;)))])

</pre>
<p>We now discuss the script with particular emphasis on the differences
with the first one. One difference lies in the material definition:</p>
<pre class="literal-block">
# Define the material
mat_Py = nmag.MagMaterial(name=&quot;Py&quot;,
                          Ms=SI(0.8e6,&quot;A/m&quot;),
                          exchange_coupling=SI(13.0e-12, &quot;J/m&quot;),
                          llg_gamma_G=SI(0.2211e6, &quot;m/A s&quot;),
                          llg_polarisation=1.0,
                          llg_xi=0.05,
                          llg_damping=0.1)
</pre>
<p>Here we use two new arguments for the <a class="reference internal" href="manual.html#magmaterial">MagMaterial</a> class.
The first is <tt class="docutils literal"><span class="pre">llg_polarisation</span></tt> which is used to specify the spin polarisation
of the conduction electrons inside the given material.
The second, <tt class="docutils literal"><span class="pre">llg_xi</span></tt>, is used to specify the degree of non-adiabaticity.
Note that for the damping parameter, <tt class="docutils literal"><span class="pre">llg_damping</span></tt>, we are now using
a smaller value, 0.1 (these values are not realistic for Permalloy).</p>
<p>The script then continues by creating the simulation object
and loading the mesh (which is identical to the relaxation script shown in part I). The initial magnetisation is read from the <tt class="docutils literal"><span class="pre">vortex_m.h5</span></tt> file:</p>
<pre class="literal-block">
# Set the initial magnetisation: part II uses the one saved by part I
sim.load_m_from_h5file(&quot;vortex_m.h5&quot;)
</pre>
<p>Here we use the function <a class="reference internal" href="manual.html#load-m-from-h5file">load_m_from_h5file</a> to load the magnetisation
from the file <tt class="docutils literal"><span class="pre">vortex_m.h5</span></tt>, which was created in part I by using
the function <a class="reference internal" href="manual.html#save-restart-file">save_restart_file</a>.
We set the current density:</p>
<pre class="literal-block">
sim.set_current_density([1e12, 0, 0], unit=SI(&quot;A/m^2&quot;))
</pre>
<p>The current density has norm <tt class="docutils literal"><span class="pre">10^12</span> <span class="pre">A/m^2</span></tt> and is aligned in the <tt class="docutils literal"><span class="pre">x</span></tt>
direction. We then disable the convergence check:</p>
<pre class="literal-block">
sim.set_params(stopping_dm_dt=0.0) # * WE * decide when the simulation should stop!
</pre>
<p>Here we decide that convergence should be reached when the magnetisation moves
less than 0.0 degrees per nanosecond. This cannot happen and hence convergence
is never reached: we'll tell the <tt class="docutils literal"><span class="pre">relax</span></tt> method to exit after a fixed amount
of time has been simulated:</p>
<pre class="literal-block">
sim.relax(save=[('fields', at('convergence') | every('time', SI(1.0e-9, &quot;s&quot;))),
                ('averages', every('time', SI(0.05e-9, &quot;s&quot;)) | at('stage_end'))],
          do = [('exit', at(&quot;time&quot;, SI(10e-9, &quot;s&quot;)))])
</pre>
<p>We run the simulation for just 10 nanoseconds by forcing an exit with
<tt class="docutils literal"><span class="pre">('exit',</span> <span class="pre">at(&quot;time&quot;,</span> <span class="pre">SI(10e-9,</span> <span class="pre">&quot;s&quot;)))</span></tt>.  We also save the fields
every nanosecond and save the averages more often, every 50
picoseconds. The relax method will simulate a vortex &quot;hit&quot; by a spin
polarised current and will save the averages so that we can see how
the magnetisation changes in time.</p>
<p>To run the script (which takes of the order of half an hour) we use as usual:</p>
<blockquote>
$ nsim stt.py</blockquote>
<p>The output files for this simulation will start with the prefix <tt class="docutils literal"><span class="pre">stt</span></tt>.
The script saves the average magnetisation periodically in time.
We can therefore plot it using the following gnuplot script:</p>
<pre class="literal-block">
set term postscript color eps enhanced
set out &quot;m_of_t.eps&quot;

set xlabel &quot;time (ns)&quot;
set ylabel &quot;average magnetisation (10^6 A/m)&quot;
plot [0:10] \
  &quot;m_of_t.dat&quot; u ($1*1e9):($2/1e6) t &quot;&lt;M_x&gt;&quot; w lp, \
  &quot;&quot; u ($1*1e9):($3/1e6) t &quot;&lt;M_y&gt;&quot; w lp, \
  &quot;&quot; u ($1*1e9):($4/1e6) t &quot;&lt;M_z&gt;&quot; w lp

</pre>
<p>to obtain the following graph:</p>
<div align="center" class="figure">
<img alt="zhangli-3" src="../example_zhangli1/m_of_t.png" />
</div>
</div>
<div class="section" id="standard-problem">
<h3><a class="toc-backref" href="manual.html#id96">2.20.4&nbsp;&nbsp;&nbsp;Standard problem</a></h3>
<p>The simulation carried out here is a (coarse) version of the recently
proposed standard problem for spin transfer torque micromagnetic
studies <a class="footnote-reference" href="manual.html#id18" id="id17">[8]</a>.</p>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id17">[8]</a></td><td>Massoud Najafi, Benjamin Kruger, Stellan Bohlens, Matteo Franchin, Hans Fangohr, Antoine Vanhaverbeke, Rolf Allenspach, Markus Bolte, Ulrich Merkt, Daniela Pfannkuche, Dietmar P. F. Moller, and Guido Meier, <em>Proposal for a Standard Problem for Micromagnetic Simulations Including Spin-Transfer Torque</em>, Journal of Applied Physics, in print (2009), preprint available at <a class="reference external" href="http://www.soton.ac.uk/~fangohr/publications/preprint/Najafi_etal_2009.pdf">http://www.soton.ac.uk/~fangohr/publications/preprint/Najafi_etal_2009.pdf</a></td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="example-current-driven-magnetisation-precession-in-nanopillars">
<h2><a class="toc-backref" href="manual.html#id97">2.21&nbsp;&nbsp;&nbsp;Example: Current-driven magnetisation precession in nanopillars</a></h2>
<p>This is the second example we provide in order to illustrate the usage
of the Zhang-Li extension to model spin-transfer-torque in Nmag.
While in the <a class="reference internal" href="manual.html#current-driven-motion-of-a-vortex-in-a-thin-film">Current-driven motion of a vortex in a thin film</a> example we tried to present two scripts (one for initial relaxation, and one for the spin torque transfer simulation),
sacrificing usability for the sake of clarity, here we'll try to present
a real-life script, using the power of the Python programming language
as much as it is needed to achieve our goal.</p>
<div align="center" class="figure">
<img alt="../example_zhangli2/nanopillar.png" src="../example_zhangli2/nanopillar.png" />
</div>
<p>We consider a ferromagnetic nanopillar in the shape of a cylinder.
We assume that the magnetisation in the nanopillar is pinned in the two
faces of the cylinder along opposite directions: on the right face
the magnetisation points to the right, while on the left face it points
to the left. The magnetisation is then forced to develop a domain wall.
We then study how such an &quot;artificial&quot; domain wall interacts with a current
flowing throughout the cylinder, along its axis.</p>
<p>By &quot;artificial&quot; we mean that the domain wall is developed as a
consequence of the pinning, which we artificially impose.  In real
systems, the pinning can be provided through interface exchange
coupling or may have a geometrical origin, in combination with
suitable material parameters. The situation we consider here is
described and studied in more detail in publications <a class="footnote-reference" href="manual.html#franchin2008a" id="id19">[9]</a> and <a class="footnote-reference" href="manual.html#franchin2008b" id="id20">[10]</a>.</p>
<table class="docutils footnote" frame="void" id="franchin2008a" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[9]</td><td><em>(<a class="fn-backref" href="manual.html#id19">1</a>, <a class="fn-backref" href="manual.html#id21">2</a>)</em> Matteo Franchin, Thomas Fischbacher, Giuliano Bordignon, Peter de Groot, Hans Fangohr, <em>Current-driven dynamics of domain walls constrained in ferromagnetic nanopillars</em>, Physical Review B <strong>78</strong>, 054447 (2008), online at <a class="reference external" href="http://eprints.soton.ac.uk/59253">http://eprints.soton.ac.uk/59253</a>,</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="franchin2008b" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[10]</td><td><em>(<a class="fn-backref" href="manual.html#id20">1</a>, <a class="fn-backref" href="manual.html#id22">2</a>)</em> Matteo Franchin, Giuliano Bordignon, Peter A. J. de Groot, Thomas Fischbacher, Jurgen P. Zimmermann, Guido Meier, Hans Fangohr, <em>Spin-polarized currents in exchange spring systems</em>, Journal of Applied Physics <strong>103</strong>, 07A504 (2008), online at <a class="reference external" href="http://link.aip.org/link/?JAPIAU/103/07A504/1">http://link.aip.org/link/?JAPIAU/103/07A504/1</a></td></tr>
</tbody>
</table>
<div class="section" id="two-simulations-in-one-single-script">
<h3><a class="toc-backref" href="manual.html#id98">2.21.1&nbsp;&nbsp;&nbsp;Two simulations in one single script</a></h3>
<p>The nanopillar is made of Permalloy and has the shape of a cylinder with
radius of 10 nm and length 30 nm. The mesh is loaded from the file
<a class="reference external" href="../example_zhangli2/l030.nmesh.h5">l030.nmesh.h5</a>
which was created using <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> from the file
<a class="reference external" href="../example_zhangli2/l030.geo">l030.geo</a>.</p>
<div align="center" class="align-center"><img alt="../example_zhangli2/mesh.png" class="align-center" src="../example_zhangli2/mesh.png" /></div>
<p>The simulation is subdivided into two parts, similarly to the previous
example:</p>
<ul class="simple">
<li>In part I, the system is relaxed to obtain the initial magnetisation
configuration when the current is not applied.</li>
<li>In part II the current is applied to the artificial domain wall
whose shape was calculated in part I.</li>
</ul>
<p>This time, however, we use just one single script to execute both
parts of the simulation in one go.  In particular, we define a
function which takes some input parameters such as the current
density, the damping, etc and uses them to carry out a simulation. We
then call this function twice: once for part I and once for part
II.</p>
<p>The full listing of the script <a class="reference external" href="../example_zhangli2/stt_nanopillar.py">stt_nanopillar.py</a>:</p>
<pre class="literal-block">
import nmag, os, math
from nmag import SI, every, at
from nsim.si_units.si import degrees_per_ns

l = 30.0                        # The nanopillar thickness is 30 nm
hl = l/2                        # hl is half the nanopillar thickness
relaxed_m_file = &quot;relaxed_m.h5&quot; # File containing the relaxed magnetisation
mesh_name = &quot;l030.nmesh.h5&quot;     # Mesh name
mesh_unit = SI(1e-9, &quot;m&quot;)       # Unit length for space used by the mesh

def run_simulation(sim_name, initial_m, damping, stopping_dm_dt,
                   j, P=0.0, save=[], do=[], do_demag=True):
  # Define the material
  mat = nmag.MagMaterial(
          name=&quot;mat&quot;,
          Ms=SI(0.8e6, &quot;A/m&quot;),
          exchange_coupling=SI(13.0e-12, &quot;J/m&quot;),
          llg_damping=damping,
          llg_xi=SI(0.01),
          llg_polarisation=P)

  # Create the simulation object and load the mesh
  sim = nmag.Simulation(sim_name, do_demag=do_demag)
  sim.load_mesh(mesh_name, [(&quot;np&quot;, mat)], unit_length=mesh_unit)

  # Set the pinning at the top and at the bottom of the nanopillar
  def pinning(p):
    x, y, z = p
    tmp = float(SI(x, &quot;m&quot;)/(mesh_unit*hl))
    if abs(tmp) &gt;= 0.999:
      return 0.0
    else:
      return 1.0
  sim.set_pinning(pinning)

  if type(initial_m) == str:            # Set the initial magnetisation
    sim.load_m_from_h5file(initial_m)   # a) from file if a string is provided
  else:
    sim.set_m(initial_m)                # b) from function/vector, otherwise

  if j != 0.0:                          # Set the current, if needed
    sim.set_current_density([j, 0.0, 0.0], unit=SI(&quot;A/m^2&quot;))

  # Set additional parameters for the time-integration and run the simulation
  sim.set_params(stopping_dm_dt=stopping_dm_dt,
                 ts_rel_tol=1e-7, ts_abs_tol=1e-7)
  sim.relax(save=save, do=do)
  return sim

# If the initial magnetisation has not been calculated and saved into
# the file relaxed_m_file, then do it now!
if not os.path.exists(relaxed_m_file):
  # Initial direction for the magnetisation
  def m0(p):
      x, y, z = p
      tmp = min(1.0, max(-1.0, float(SI(x, &quot;m&quot;)/(mesh_unit*hl))))
      angle = 0.5*math.pi*tmp
      return [math.sin(angle), math.cos(angle), 0.0]

  save = [('fields', at('step', 0) | at('stage_end')),
          ('averages', every('time', SI(5e-12, 's')))]

  sim = run_simulation(sim_name=&quot;relaxation&quot;, initial_m=m0,
                       damping=0.5, j=0.0, save=save,
                       stopping_dm_dt=1.0*degrees_per_ns)
  sim.save_restart_file(relaxed_m_file)
  del sim

# Now we simulate the magnetisation dynamics
save = [('averages', every('time', SI(9e-12, 's')))]
do   = [('exit', at('time', SI(6e-9, 's')))]
run_simulation(sim_name=&quot;dynamics&quot;, initial_m=relaxed_m_file, damping=0.02,
               j=0.1e12, P=1.0, save=save, do=do, stopping_dm_dt=0.0)

</pre>
<p>After importing the required modules, we define some variables such as
the length of the cylinder, <tt class="docutils literal"><span class="pre">l</span></tt>; the name of the file where to put
the relaxed magnetisation, <tt class="docutils literal"><span class="pre">relaxed_m_file</span></tt>; the name of the mesh,
<tt class="docutils literal"><span class="pre">mesh_name</span></tt>; its unit length, <tt class="docutils literal"><span class="pre">mesh_unit</span></tt>:</p>
<pre class="literal-block">
l = 30.0                        # The nanopillar thickness is 30 nm
hl = l/2                        # hl is half the nanopillar thickness
relaxed_m_file = &quot;relaxed_m.h5&quot; # File containing the relaxed magnetisation
mesh_name = &quot;l030.nmesh.h5&quot;     # Mesh name
mesh_unit = SI(1e-9, &quot;m&quot;)       # Unit length for space used by the mesh
</pre>
<p>These quantities are used later in the script. For example, knowing
the length of the nanopillar is necessary in order to set a proper
initial magnetisation for the relaxation. By making this a parameter
at the top of the program, we can change it there (if we wan to study
the same system for a different l), and just run the script again.</p>
<p>We define the function <tt class="docutils literal"><span class="pre">run_simulation</span></tt>: we teach Python how to run
a simulation given some parameters, such as the initial magnetisation,
the damping, the current density, etc.  The function is defined
starting with the line:</p>
<pre class="literal-block">
def run_simulation(sim_name, initial_m, damping, stopping_dm_dt,
                   j, P=0.0, save=[], do=[], do_demag=True):
</pre>
<p>The arguments of the function (the names inside the parenthesis) are
those parameters which must be choosen differently in part I and part II.
For example, we decided to make the current density <tt class="docutils literal"><span class="pre">j</span></tt> an argument
for the function <tt class="docutils literal"><span class="pre">run_simulation</span></tt>, because in part I <tt class="docutils literal"><span class="pre">j</span></tt> must be set
to zero, while in part II it must be set to some value greater than zero.
On the other hand, the saturation magnetisation does not appear
in the argument list of the function, since it has the same value
both in part I and part II.</p>
<p>A remark about the Python syntax: arguments such as <tt class="docutils literal"><span class="pre">sim_name</span></tt>
must be specified explicitly when using the function <tt class="docutils literal"><span class="pre">run_simulation</span></tt>,
while arguments such as <tt class="docutils literal"><span class="pre">P=0</span></tt> have a default value (0.0 in this case)
and the user may omit them, meaning that Python will then use
the default values.</p>
<p>We skip the explanation of the body of the function and focus on the code which
follows it. We'll return later on the implementation of <tt class="docutils literal"><span class="pre">run_simulation</span></tt>.
For now, the user should keep in mind that <tt class="docutils literal"><span class="pre">run_simulation</span></tt> just runs
one distinct micromagnetic simulation every time it is called (and what simulation this is will depend on the parameters given to the function). The function returns
the simulation object which it created.</p>
<p>We now comment the code which follows the function <tt class="docutils literal"><span class="pre">run_simulation</span></tt>:</p>
<pre class="literal-block">
# If the initial magnetisation has not been calculated and saved into
# the file relaxed_m_file, then do it now!
if not os.path.exists(relaxed_m_file):
  # Initial direction for the magnetisation
  def m0(pos):
      x, y, z = pos
      tmp = min(1.0, max(-1.0, float(SI(x, &quot;m&quot;)/(mesh_unit*hl))))
      angle = 0.5*math.pi*tmp
      return [math.sin(angle), math.cos(angle), 0.0]

  save = [('fields', at('step', 0) | at('stage_end')),
          ('averages', every('time', SI(5e-12, 's')))]

  sim = run_simulation(sim_name=&quot;relaxation&quot;, initial_m=m0,
                       damping=0.5, j=0.0, save=save,
                       stopping_dm_dt=1.0*degrees_per_ns)
  sim.save_restart_file(relaxed_m_file)
  del sim
</pre>
<p>This piece of code carries out part I of the simulation: it relaxes
the system starting from a sensible initial guess for the
magnetisation and saves the relaxed magnetisation configuration so
that it can be used in part II.</p>
<p>In more detail, it starts by checking (using the function
<tt class="docutils literal"><span class="pre">os.path.exists</span></tt>) if a file containing the initial magnetisation
exists. If this is not the case, then the following indented block
will be executed, which computes and saves this initial
magnetisation. If the file exists, the whole indented block is
skipped, and we go straight to part II of the calculation.</p>
<p>In order to compute the relaxed configuration, an initial guess <tt class="docutils literal"><span class="pre">m0</span></tt>
for the magnetisation is defined.  Such magnetisation linearly rotates
from left to right as the position changes from the left face to the
right face of the cylinder.  Here <tt class="docutils literal"><span class="pre">x</span></tt> is the x coordinate of the
position vector <tt class="docutils literal"><span class="pre">p</span></tt> and <tt class="docutils literal"><span class="pre">tmp</span> <span class="pre">=</span> <span class="pre">min(1.0,</span> <span class="pre">max(-1.0,</span> <span class="pre">float(SI(x,</span>
<span class="pre">&quot;m&quot;)/(mesh_unit*hl))))</span></tt> is a continuous function which changes
linearly from -1 to 1 when going from the left to the right face,
keeping constant outside the cylinder.</p>
<p>In the code above we also define the variable <tt class="docutils literal"><span class="pre">save</span></tt> which is used
to specify when and what should be saved to disk. Here we save the
fields before and after the relaxation and save the averages every 5
picoseconds.</p>
<p>We then call the <tt class="docutils literal"><span class="pre">run_simulation</span></tt> function we defined above to relax
the magnetisation. This function returns the simulation object
<tt class="docutils literal"><span class="pre">sim</span></tt>, which we use to save the magnetisation using the
<a class="reference internal" href="manual.html#save-restart-file">save_restart_file</a> function.</p>
<p>Once this is done, we delete the simulation object, releasing resources
(memory) we have used for the simulation of part I.  Note that for
the relaxation, we use <tt class="docutils literal"><span class="pre">j=0.0</span></tt> (zero current density), <tt class="docutils literal"><span class="pre">damping=0.5</span></tt>
(fast damping, to reach convergence quickly) and
<tt class="docutils literal"><span class="pre">stopping_dm_dt=1.0*degrees_per_ns</span></tt> (this means that the simulation
should end when the magnetisation moves slower than 1 degree per
nanosecond).</p>
<p>The following part of the script deals with part II, the computation
of the current-driven dynamics:</p>
<pre class="literal-block">
# Now we simulate the magnetisation dynamics
save = [('averages', every('time', SI(9e-12, 's')))]
do   = [('exit', at('time', SI(6e-9, 's')))]

run_simulation(sim_name=&quot;dynamics&quot;,
               initial_m=relaxed_m_file,
               damping=0.02,
               j=0.1e12,
               P=1.0,
               save=save,
               do=do,
               stopping_dm_dt=0.0)
</pre>
<p>Here we decide to save the averages every 9 picoseconds and exit the
simulation after 6 nanoseconds. We use <tt class="docutils literal"><span class="pre">stopping_dm_dt=0.0</span></tt> to
disable the convergence check (here we just want to simulate for a
fixed amount of time). We also use full spin polarisation, <tt class="docutils literal"><span class="pre">P=1.0</span></tt>,
we apply a current density of <tt class="docutils literal"><span class="pre">j=0.1e12</span> <span class="pre">A/m^2</span></tt> and use a realistic
damping parameter for Permalloy, <tt class="docutils literal"><span class="pre">damping=0.02</span></tt>. For the initial
magnetisation we pass the name of the file where the relaxed
magnetisation was saved in part I and we specify a simulation name
<tt class="docutils literal"><span class="pre">sim_name=&quot;dynamics&quot;</span></tt> which is different from the one used for the
relaxation (which was <tt class="docutils literal"><span class="pre">sim_name=&quot;relaxation&quot;</span></tt>). The simulation name
will decide the prefix of any filenames that are being created when
saving data. (If the simulation name is not specified, the name of the
script file is used.)</p>
<p>We now return to discuss the function <tt class="docutils literal"><span class="pre">run_simulation</span></tt> and see how
it carries out the actual simulations. First, the function defines the
material:</p>
<pre class="literal-block">
# Define the material
mat = nmag.MagMaterial(
        name=&quot;mat&quot;,
        Ms=SI(0.8e6, &quot;A/m&quot;),
        exchange_coupling=SI(13.0e-12, &quot;J/m&quot;),
        llg_damping=damping,
        llg_xi=SI(0.01),
        llg_polarisation=P)
</pre>
<p>It uses the variable <tt class="docutils literal"><span class="pre">P</span></tt> which is passed as an argument to the function.
Then the simulation object is created and the mesh is loaded:</p>
<pre class="literal-block">
# Create the simulation object and load the mesh
sim = nmag.Simulation(sim_name, do_demag=do_demag)
sim.load_mesh(mesh_name, [(&quot;np&quot;, mat)], unit_length=mesh_unit)
</pre>
<p>Note that <tt class="docutils literal"><span class="pre">sim_name</span></tt> is passed to the Simulation object,
allowing the user to use different prefixes for the output files
of the simulation. For example, if <tt class="docutils literal"><span class="pre">sim_name</span> <span class="pre">=</span> <span class="pre">&quot;relaxation&quot;</span></tt>,
then the output files produced when saving the fields or their averages
to disk will have names starting with the prefix <tt class="docutils literal"><span class="pre">relaxation_</span></tt>.
On the other hand, if <tt class="docutils literal"><span class="pre">sim_name</span> <span class="pre">=</span> <span class="pre">&quot;dynamics&quot;</span></tt>, the names of these files
will all start with the prefix <tt class="docutils literal"><span class="pre">dynamics_</span></tt>.</p>
<p>Using different simulation names allows us to save the data of part I
and part II in different independent files.  The function continues
with the code above:</p>
<pre class="literal-block">
# Set the pinning at the left and right face of the nanopillar
def pinning(p):
  x, y, z = p
  tmp = float(SI(x, &quot;m&quot;)/(mesh_unit*hl))
  if abs(tmp) &gt;= 0.999:
    return 0.0
  else:
    return 1.0
sim.set_pinning(pinning)
</pre>
<p>which is used to pin the magnetisation at the left and right faces of
the cylinder.  Note here that <tt class="docutils literal"><span class="pre">x</span></tt> is the x component of the position
of the mesh site and that:</p>
<pre class="literal-block">
tmp = float(SI(x, &quot;m&quot;)/(mesh_unit*hl))
</pre>
<p>is equal to -1 at the right face, and to +1 at the left face.
We then set the magnetisation. If <tt class="docutils literal"><span class="pre">initial_m</span></tt> is a string,
then we assume it is the name of the file and load the magnetisation
with the method <tt class="docutils literal"><span class="pre">load_m_from_h5file</span></tt>, otherwise we assume it is just
a function and set the magnetisation in the usual way, using the method
<tt class="docutils literal"><span class="pre">set_m</span></tt>:</p>
<pre class="literal-block">
if type(initial_m) == str:            # Set the initial magnetisation
  sim.load_m_from_h5file(initial_m)   # a) from file if a string is provided
else:
  sim.set_m(initial_m)                # b) from function/vector, otherwise
</pre>
<p>We then set the current density along the x direction
(only if <tt class="docutils literal"><span class="pre">j</span></tt> is not zero):</p>
<pre class="literal-block">
if j != 0.0:                          # Set the current, if needed
  sim.set_current_density([j, 0.0, 0.0], unit=SI(&quot;A/m^2&quot;))
</pre>
<p>Finally, we set tolerances, the stopping criterion and launch the simulation:</p>
<pre class="literal-block">
# Set additional parameters for the time-integration and run the simulation
sim.set_params(stopping_dm_dt=stopping_dm_dt,
               ts_rel_tol=1e-7, ts_abs_tol=1e-7)
sim.relax([None], save=save, do=do)
return sim
</pre>
<p>The <a class="reference internal" href="manual.html#relax">relax</a> function carries out the simulation, taking into account the stopping criterion and <tt class="docutils literal"><span class="pre">save</span></tt> and <tt class="docutils literal"><span class="pre">do</span></tt> actions. Finally, the function returns the simulation object which it created.</p>
</div>
<div class="section" id="results-precession-of-the-magnetisation">
<h3><a class="toc-backref" href="manual.html#id99">2.21.2&nbsp;&nbsp;&nbsp;Results: precession of the magnetisation</a></h3>
<p>We launch the script with:</p>
<pre class="literal-block">
$ nsim stt_nanopillar.py
</pre>
<p>The script runs both part I (output files starting with <tt class="docutils literal"><span class="pre">relaxation_</span></tt>)
and part II (output files starting with <tt class="docutils literal"><span class="pre">dynamics_</span></tt>).
The relaxed magnetisation can be extracted and saved into a vtk file using
the command <tt class="docutils literal"><span class="pre">nmagpp</span> <span class="pre">relaxation</span> <span class="pre">--vtk=m.vtk</span></tt>. MayaVi can then be used
to obtain the following picture:</p>
<div align="center" class="figure">
<img alt="zhangli2-1" src="../example_zhangli2/m-end.png" />
</div>
<p>We can now take a look at the results obtained for the dynamics.
The average magnetisation as a function of time can be extracted
using:</p>
<pre class="literal-block">
ncol dynamics time M_mat_0 M_mat_1 M_mat_2 &gt; m_of_t.dat
</pre>
<p>We can use the following gnuplot script:</p>
<pre class="literal-block">
set term postscript color eps enhanced solid
set out &quot;m_of_t.eps&quot;

set xlabel &quot;time (ns)&quot;
set ylabel &quot;average magnetisation (10^6 A/m)&quot;
plot [0:6] \
  &quot;m_of_t.dat&quot; u ($1*1e9):($2/1e6) t &quot;&lt;M_x&gt;&quot; w l, \
  &quot;&quot; u ($1*1e9):($3/1e6) t &quot;&lt;M_y&gt;&quot; w l, \
  &quot;&quot; u ($1*1e9):($4/1e6) t &quot;&lt;M_z&gt;&quot; w l


</pre>
<p>and obtain the following graph:</p>
<div align="center" class="figure">
<img alt="zhangli2-2" src="../example_zhangli2/m_of_t.png" />
</div>
<p>The sinusoidal dependence of the y and z magnetisation components suggests
that the magnetisation rotates around the nanopillar axis with a frequency
which increases to approach its maximum value.</p>
<p>A more detailed discussion of results and interpretation is provided
in the publications <a class="footnote-reference" href="manual.html#franchin2008a" id="id21">[9]</a> and <a class="footnote-reference" href="manual.html#franchin2008b" id="id22">[10]</a> mentioned in section <a class="reference internal" href="manual.html#example-current-driven-magnetisation-precession-in-nanopillars">Example: Current-driven magnetisation precession in nanopillars</a>.</p>
</div>
</div>
<div class="section" id="compression-of-the-boundary-element-matrix-using-hlib">
<h2><a class="toc-backref" href="manual.html#id100">2.22&nbsp;&nbsp;&nbsp;Compression of the Boundary Element Matrix using HLib</a></h2>
<!-- This data file has been placed in the public domain. -->
<!-- Derived from the Unicode character mappings available from
<http://www.w3.org/2003/entities/xml/>.
Processed by unicode2rstsubs.py, part of Docutils:
<http://docutils.sourceforge.net>. -->
<div class="section" id="hierarchical-matrices-in-micromagnetism">
<h3><a class="toc-backref" href="manual.html#id101">2.22.1&nbsp;&nbsp;&nbsp;Hierarchical Matrices in Micromagnetism</a></h3>
<p>Nmag uses the hybrid finite element method/boundary element method
(hybrid FEM/BEM) to compute the demagnetisation field (as does
<a class="reference external" href="http://magnet.atp.tuwien.ac.at/scholz/magpar/">Magpar</a>). Not using this method, one would have to discretise a large
part of space arround the magnetic structure (ideally all
space). Using the hybrid FEM/BEM method, it is only necessary to
discretise (and solve the equations for the demag field on that
discretisation) those parts of space that are occupied by magnetic
material.</p>
<p>A disadvantage of the hybrid FEM/BEM method is that it involves the
assembly of a dense boundary element matrix <strong>B</strong>, whose number of
elements scales quadratically with the number of surface nodes N of
our finite element mesh, i.e. the matrix <strong>B</strong> has as many rows as there are
surface nodes N in the mesh (and also as many columns).</p>
<!-- comment:

If `i` and `j` denote two nodes on the surface of the mesh, an element
B\ :sub:`ij`\ of the boundary element matrix **B** can be physically
interpreted as the potential generated at `j` by a dipole layer
located around `i`. -->
<p>This is in particular an issue when studying flat structures such as
thin films. For example, imagine we model a thin film of side lengths
100 nm x 100 nm x 2nm. If we decide to double the side lengths to 200
nm x 200 nm x 2nm, then this roughly corresponds to an increase of
surface node numbers N by a factor of 4. The matrix <strong>B</strong> will then
grow in size by a factor 4^2=16 due to the doubling of the two side
lengths by a factor of 2. In practice, the memory requirements of the
matrix <strong>B</strong> often limit the size of a structure that can be modelled.</p>
<p>In order to improve the efficiency of the hybrid FEM/BEM, one can
employ techniques which involve some kind of approximation of <strong>B</strong>,
for example using hierarchical matrices.</p>
<!-- comment:
The basic `idea
<http://hlib.org/literature.html#boerm_grasedyck_hackbusch_2004>`__ of
this hierarchical matrix approach is to split **B** into submatrices,
which are stored within the leaves of a hierarchical tree
structure. Since those submatrices describe the dipole potential at a
cluster of reference nodes generated by a cluster of source nodes,
their matrix entries will be small and vary smoothly if both clusters
are sufficiently well separated. In the latter case it is therefore
possible to approximate the submatrix by a data-sparse approximation,
i.e. by a representation which only requires the storage of a few data
entries. The efficiency of hierarchical matrices derives from those
approximations. -->
<p>The basic idea <a class="reference external" href="http://www.mis.mpg.de/publications/other-series/ln/lecturenote-2103.html">idea</a>
is to approximate submatrices of <strong>B</strong> by a data-sparse approximation
where possible (within user-provided tolerance margins).  In general
the complexity of the storage requirements and execution time of
simple operations like the matrix-vector product scale as O(N*log(N)),
as compared to the quadratical costs N^2 using the standard matrix
representation. For the use of HLib hierarchical matrices in
micromagnetic simulations we are often mostly interested in the their
reduced <em>memory</em> requirements.</p>
<p>The library <a class="reference external" href="http://www.hlib.org">HLib</a> contains implementations of this hierarchical matrix
methodology, and can be used with Nmag in order to run micromagnetic
simulations in a more memory efficient way (see for example <a class="reference external" href="http://link.aip.org/link/?JAPIAU/105/07D542/1">Knittel
et al 105, 07D542 (2009)</a>, <a class="reference external" href="http://www.soton.ac.uk/~fangohr/publications/postprint/Knittel_etal_JAP_105_07D542_2009.pdf">postprint pdf</a>).
.</p>
</div>
<div class="section" id="installation-of-hlib">
<h3><a class="toc-backref" href="manual.html#id102">2.22.2&nbsp;&nbsp;&nbsp;Installation of HLib</a></h3>
<p>In order to be able to use the <a class="reference external" href="http://www.hlib.org">HLib</a> library and to obtain the HLib source
code, you have to apply for an HLib licence as explained on
<a class="reference external" href="http://hlib.org/license.html">http://hlib.org/license.html</a>.</p>
<p>Once the HLib authors grant a licence, they will send their HLib tarball. Nmag will have to be compiled from source (see <a class="reference external" href="../../install/install_a.html">install from source</a>) in the presence of this tarball to make use of it.</p>
<p>We describe the required steps for this in detail.  We assume you
downloaded the HLib tarball and the Nmag tarball in your home
directory <tt class="docutils literal"><span class="pre">~/</span></tt> (but any other subdirectory will work fine). Then, if
you issue a <tt class="docutils literal"><span class="pre">ls</span></tt> command, you get something like:</p>
<pre class="literal-block">
me&#64;mymachine:~/$ ls
HLib-1.3p19.tar.gz  nmag-0.1-all.tar.gz
</pre>
<p>You can now untar the nmag tarball and enter the newly created directory:</p>
<pre class="literal-block">
me&#64;mymachine:~/$ tar xzvf nmag-0.1-all.tar.gz
me&#64;mymachine:~/$ cd nmag-0.1
</pre>
<p>Inside the directory <tt class="docutils literal"><span class="pre">nmag-0.1</span></tt> there is a directory called
<tt class="docutils literal"><span class="pre">hlib-pkg</span></tt> and we need to copy (or move) the HLib tarball into this directory:</p>
<pre class="literal-block">
me&#64;mymachine:~/nmag-0.1$ cp ../HLib-1.3p19.tar.gz hlib-pkg/
</pre>
<p>You can now compile Nmag in the usual way:</p>
<pre class="literal-block">
me&#64;mymachine:~/nmag-0.1$ make
</pre>
<p>The build system should recognise that the <tt class="docutils literal"><span class="pre">hlib-pkg</span></tt> directory contains
a tarball and should prompt you asking what to do:</p>
<pre class="literal-block">
me&#64;mymachine:~/nmag-0.1$ make
bash ./patches/hlib/hlib-untar.sh ./hlib-pkg HLib-1.3p19.tar.gz &amp;&amp; \
          rm -f .deps_hlib_patch &amp;&amp; make .deps_hlib_install; true
_____________________________________________________
 It seems you want to compile Nmag with HLib support
 I'll need your confirmation in order to proceed...

I found ./hlib-pkg/HLib-1.3p19.tar.gz
Is this the HLib tarball you want to use? (yes/no) yes
</pre>
<p>Type <tt class="docutils literal"><span class="pre">yes</span></tt> and <tt class="docutils literal"><span class="pre">ENTER</span></tt>. The build system should untar the HLib tarball, it
should patch it (HLib needs to be patched in order to be usable by Nmag)
and it should install it in the right location with respect to the Nmag
libraries. If all goes well, you should get an installation of Nmag which is
capable of using HLib for the compression of the BEM matrix.</p>
<p>As you see, the only additional step which is required with respect to the
normal procedure for compiling Nmag from source, is to put the HLib tarball
inside the directory <tt class="docutils literal"><span class="pre">nmag-0.1/hlib-pkg</span></tt>.</p>
<p>The current nmag release requires Hlib version 1.3p19.</p>
</div>
<div class="section" id="testing-the-hlib-bem-matrix-compression">
<h3><a class="toc-backref" href="manual.html#id103">2.22.3&nbsp;&nbsp;&nbsp;Testing the HLib BEM Matrix compression</a></h3>
<p>There is a test target <tt class="docutils literal"><span class="pre">make</span> <span class="pre">checkhlib</span></tt> which tests whether a demag
field can be computed using the HLib and compares this with the result
of the same calculation using a full BEM. If the deviations become large,
the test will fail. To run the test, do</p>
<blockquote>
<a class="reference external" href="mailto:me&#64;mymachine">me&#64;mymachine</a>:~/nmag-0.1$ make checkhlib</blockquote>
<p>The test should take less than 5 minutes. If it passes, then it
appears that the hlib is used, and produces quantitatively appropriate
approximations of the true solution.</p>
</div>
<div class="section" id="using-hlib-example-1-demagnetisation-field-of-a-sphere">
<h3><a class="toc-backref" href="manual.html#id104">2.22.4&nbsp;&nbsp;&nbsp;Using HLib example 1: Demagnetisation Field of a Sphere</a></h3>
<p>The properties of a hierarchical matrix depend much on the settings of
different parameters and on the particular algorithm used to create
the low-rank approximations.  In Nmag, we only use the HCA II
algorithm, which seems to be the most reliable amongst the commonly
used algorithms, being still very efficient (see for example <a class="reference external" href="http://link.aip.org/link/?JAPIAU/105/07D542/1">Knittel et al 105,
07D542 (2009)</a>,
<a class="reference external" href="http://www.soton.ac.uk/~fangohr/publications/postprint/Knittel_etal_JAP_105_07D542_2009.pdf">postprint pdf</a>).</p>
<p>The performance and accuracy of the HCA II algorithm can be tuned by providing
a number of parameters, which are collected inside a <a class="reference internal" href="manual.html#hmatrixsetup">HMatrixSetup</a> object.
A default <tt class="docutils literal"><span class="pre">HMatrixSetup</span></tt> object is provided, where a reasonable choice of
these parameters is made. The default parameters can be overriden by users.</p>
<p>We point the reader to the documentation of the <a class="reference internal" href="manual.html#hmatrixsetup">HMatrixSetup</a> class
for a list and description of all avaliable parameters. The next
example shows how to use HLib with the default values for the setup of
the BEM matrix.</p>
<div class="section" id="using-hlib-with-default-parameters">
<h4>2.22.4.1&nbsp;&nbsp;&nbsp;Using HLib with default parameters</h4>
<p>The Nmag script <a class="reference external" href="../example_phi_BEM_hlib/sphere_hlib.py">sphere_hlib.py</a> shows how Nmag can be used in order to compute
the demagnetisation field within a sphere with a radius of 50 nm.</p>
<blockquote>
<pre class="literal-block">
import nmag
import time
from nmag import SI

# When creating the simulation object, specify that the BEM hmatrix should be
# set up by using the default parameters.
sim = nmag.Simulation(phi_BEM=nmag.default_hmatrix_setup)

# Specify magnetic material, parameters chosen as in example 1
Py = nmag.MagMaterial(name=&quot;Py&quot;,
                      Ms=SI(1e6, &quot;A/m&quot;),
                      exchange_coupling=SI(13.0e-12, &quot;J/m&quot;))

# Load the mesh
sim.load_mesh('sphere.nmesh.h5',
              [('sphere', Py)],
              unit_length=SI(1e-9, 'm'))

# Set the initial magnetisation
sim.set_m([1,0,0])

# Save the demagnetisation field
sim.save_data(fields=['H_demag'])

# Probe the demagnetisation field at ten points within the sphere
for i in range(-5,6):
    x = i*1e-9
    Hdemag = sim.probe_subfield_siv('H_demag', [x,0,0])
    print &quot;x=&quot;, x, &quot;: H_demag = &quot;, Hdemag


</pre>
</blockquote>
<p>In this first example, we use default parameters for setting up the BEM
matrix by passing the object <tt class="docutils literal"><span class="pre">nmag.default_hmatrix_setup</span></tt> to the
<tt class="docutils literal"><span class="pre">Simulation</span></tt> object:</p>
<pre class="literal-block">
sim = nmag.Simulation(phi_BEM=nmag.default_hmatrix_setup)
</pre>
<p>This command specifies that the BEM matrix should be set up using the default
parameters in <tt class="docutils literal"><span class="pre">nmag.default_hmatrix_setup</span></tt>.
(The actual values of the parameters can be visualised on the screen by simply
printing the object with <tt class="docutils literal"><span class="pre">import</span> <span class="pre">nmag;</span> <span class="pre">print</span> <span class="pre">nmag.default_hmatrix_setup</span></tt>.)</p>
<p>When running the simulation <a class="reference external" href="../example_phi_BEM_hlib/sphere_hlib.py">sphere_hlib.py</a> using the usual command:</p>
<pre class="literal-block">
nsim sphere_hlib.py --clean,
</pre>
<p>it should print out the demagnetisation field at ten points along the line
(x,0,0):</p>
<pre class="literal-block">
x= -5e-09 : H_demag =  [-333060.61988567741, -16.426569556599606, -63.649046900628299]
x= -4e-09 : H_demag =  [-333061.67213255615, -17.81158234138228, -65.112039406898973]
x= -3e-09 : H_demag =  [-333062.69422596297, -19.401486521725044, -66.015626464953897]
x= -2e-09 : H_demag =  [-333062.72991753434, -20.940683675745074, -66.988296036794026]
x= -1e-09 : H_demag =  [-333061.60282647074, -22.420106762492924, -68.042400926888646]
x= 0.0 : H_demag =  [-333060.29023012909, -23.736721821840622, -68.984395930340639]
x= 1e-09 : H_demag =  [-333058.66039082204, -24.758745874347209, -69.6797361890888]
x= 2e-09 : H_demag =  [-333055.87727687479, -24.635979967196079, -70.705429412122513]
x= 3e-09 : H_demag =  [-333054.17167091055, -24.9868363963913, -73.501799477569747]
x= 4e-09 : H_demag =  [-333052.78687652596, -25.388604442091431, -76.097088958697071]
x= 5e-09 : H_demag =  [-333051.43416558538, -25.507782471847442, -77.792885797356391]
</pre>
<p>As in <a class="reference internal" href="manual.html#example-1">example 1</a> of our guided tour, we should obtain a constant
magnetic induction of about [333333,0,0] [A/m]. Deviations from that value
can be mainly ascribed to the discretisation errors of the finite
element method (rather than the error due to the approximation with
hierarchical matrices). To see this, we use <a class="reference external" href="../example_phi_BEM_hlib/sphere_fullBEM.py">sphere_fullBEM.py</a> which carries out the same
calculation but uses the normal full BEM. It reports:</p>
<pre class="literal-block">
x= -5e-09 : H_demag =  [-333065.71403658605, -5.2685406972238447, -55.70105442854085]
x= -4e-09 : H_demag =  [-333067.37484881631, -4.2116117445407726, -57.778611300679266]
x= -3e-09 : H_demag =  [-333068.83107133937, -3.7372238611028603, -59.825445387210245]
x= -2e-09 : H_demag =  [-333069.28217968839, -2.9635031726006642, -62.513814422201456]
x= -1e-09 : H_demag =  [-333067.6639511605, -1.5730916838594211, -66.546659227740889]
x= 0.0 : H_demag =  [-333066.04572263273, -0.18268019511817793, -70.579504033280344]
x= 1e-09 : H_demag =  [-333064.22835497675, 0.79797869001455679, -74.851480234723581]
x= 2e-09 : H_demag =  [-333060.20872696047, 2.9088218728650852, -77.0823444044496]
x= 3e-09 : H_demag =  [-333056.59267071093, 5.064110260421554, -80.187548021318634]
x= 4e-09 : H_demag =  [-333052.97641355224, 7.2199889195136837, -83.294534914159939]
x= 5e-09 : H_demag =  [-333051.27043353132, 9.4396856537516776, -85.662174893158024]
</pre>
<p>This shows that the error introduced by the HLib is of the order of 10
in 333333 (in this example). Note that the y and z component
theoretically should be zero (for both calculations: with and without
HLib), and that the error we see there (of the order of 60/333333 in
the z-component) is coming from approximating the spherical shape with
tetrahedra, and approximating the magnetisation with a piecewise
linear function (not primarily from using the HLib approximation of the BEM).</p>
</div>
<div class="section" id="hlib-memory-usage">
<h4>2.22.4.2&nbsp;&nbsp;&nbsp;HLib Memory usage</h4>
<p>Nmag will also provide information on the memory requirements for the
hierarchical matrix. First it will print to stdout (and here
exceptionally not write to the log file) the following lines to the
screen, which are each preceded by <tt class="docutils literal"><span class="pre">HLib</span></tt>:</p>
<pre class="literal-block">
HLib: Memory footprint of hierarchical matrix: 10.523720 MB.
HLib: Equivalent full matrix would require: 98.273628 MB.
HLib: The compression rate is 10.71%
</pre>
<p>The first line states the amount of memory required for the storage of the
hierarchical matrix, the second one states the equivalent memory requirements
when using the full boundary element matrix, and the last line gives the
corresponding compression rate. Furthermore Nmag creates the file
<cite>memory_info.dat</cite>, which in our example looks like:</p>
<pre class="literal-block">
Number of surface nodes:                3589
Size of hierarchical matrix:        10.52 MB
Total size of inadmissible leaves:   1.40 MB
Total size of admissible leaves:     8.96 MB
</pre>
<p>While the first two lines should be relatively self-explanatory, the third
line states the total amount of memory needed to store the matrix blocks
which cannot be approximated, while the fourth line gives the equivalent
number for the approximated matrix blocks. Additionally, one can obtain
the memory used for the hierarchical tree structure itself, by computing
the difference between the size of the hierarchical matrix and
the sum of the total sizes of the admissible and inadmissible leaves.</p>
</div>
<div class="section" id="changing-the-parameters-of-hlib">
<h4>2.22.4.3&nbsp;&nbsp;&nbsp;Changing the Parameters of HLib</h4>
<p>Let us assume we want to run the simulation of the last section again, but this
time we would like to reduce the time needed to assemble our hierarchical
matrix. To achieve this, we coarsen the hierarchical tree by increasing the
parameter <tt class="docutils literal"><span class="pre">nmin</span></tt> to 50, reassign the parameter <tt class="docutils literal"><span class="pre">eps_aca</span></tt> to 1e-5 in order to
decrease the accuracy of the HCA II algorithm, and reduce the accuracy of
the numerical integration by setting the parameter <tt class="docutils literal"><span class="pre">quadorder</span></tt> to 2.</p>
<p>To use non-default settings in a new script <a class="reference external" href="../example_phi_BEM_hlib/sphere_hlib2.py">sphere_hlib2.py</a> we  add one line to create an <tt class="docutils literal"><span class="pre">HMatrixSetup</span></tt> object</p>
<pre class="literal-block">
#create an HLib object
hms = nmag.HMatrixSetup(nmin=50, eps_aca=1e-5, quadorder=2)
</pre>
<p>This object is then passed to the <tt class="docutils literal"><span class="pre">Simulation</span></tt> object:</p>
<pre class="literal-block">
sim = nmag.Simulation(phi_BEM=hms)
</pre>
<p>In order to make the time measurement you can just run the nsim command
with a preceding 'time', i.e.</p>
<pre class="literal-block">
time nsim sphere_hlib2.py --clean
</pre>
<p>do the same with the sphere_hlib.py script, and compare the execution times. Alternatively,
search for the string like &quot;Populating BEM took 25.094362 seconds&quot; in the log file/output.
The execution time of the second script should be smaller (see also <a class="reference internal" href="manual.html#using-hlib-example-2-thin-films">Using HLib Example 2: Thin Films</a>).</p>
<p>For completeness: the Hdemag values computed with this script are:</p>
<pre class="literal-block">
x= -5e-09 : H_demag =  [-333060.73884748813, -5.7471691393211453, -56.164777361260889]
x= -4e-09 : H_demag =  [-333062.34355895646, -4.6973695734449556, -58.19523338342605]
x= -3e-09 : H_demag =  [-333063.7357911733, -4.2543955018989577, -60.199068292632305]
x= -2e-09 : H_demag =  [-333064.14913635491, -3.5107100192801424, -62.841949236542568]
x= -1e-09 : H_demag =  [-333062.54691465426, -2.1473409122582736, -66.824386136704007]
x= 0.0 : H_demag =  [-333060.94469295366, -0.78397180523640564, -70.806823036865438]
x= 1e-09 : H_demag =  [-333059.14023403701, 0.15188988623380831, -75.030255790251871]
x= 2e-09 : H_demag =  [-333055.17692864774, 2.2289146769013355, -77.213961296827563]
x= 3e-09 : H_demag =  [-333051.63216875959, 4.3434799953307275, -80.273150211395659]
x= 4e-09 : H_demag =  [-333048.08718075219, 6.4586908275326955, -83.334113807086638]
x= 5e-09 : H_demag =  [-333046.47566667694, 8.6375699926922742, -85.648195356633963]
</pre>
</div>
</div>
<div class="section" id="using-hlib-example-2-thin-films">
<h3><a class="toc-backref" href="manual.html#id105">2.22.5&nbsp;&nbsp;&nbsp;Using HLib Example 2: Thin Films</a></h3>
<p>In this example we consider square thin films with a thickness of 10
nm (in z-direction), and a varying edge length (in x and y directions)
between 20 and 130 nm . The magnetisation within those films is
initially homogeneously aligned and points out-of-plane. We then use
Nmag's <a class="reference internal" href="manual.html#relax">relax</a> routine in order to evolve the magnetisation field to an
energetically (meta-)stable state.</p>
<p>In order to estimate the efficiency benefits of hierarchical matrices,
the simulations are executed twice: (i) with and (ii) without
hierarchical matrices. Optimal damping is ensured by setting the
damping constant of the LLG equation to 1. To increase the efficiency
of the relaxation the tolerance of the time-stepper has been increased
to 1e-5 (see <a class="reference internal" href="manual.html#id23">Example: Timestepper tolerances</a>).</p>
<p>For our estimation of the efficiency we measure the time needed for
the setup of our simulation (basically the time for populating the
finite element and boundary element matrices), the time for relaxing
the system, and the memory consumption at the end of the simulation,
which should be roughly equal to the maximal value throughout the
simulation.</p>
<p>For each film size and either use of the full BEM or the approximation through hierarchical matrices, a separate nsim script file
(<a class="reference external" href="../example_phi_BEM_hlib/simulation_films/thinfilm20_full.py">thinfilm20_full.py</a>,
<a class="reference external" href="../example_phi_BEM_hlib/simulation_films/thinfilm40_full.py">thinfilm40_full.py</a>,
<a class="reference external" href="../example_phi_BEM_hlib/simulation_films/thinfilm60_full.py">thinfilm60_full.py</a>, ...,
<a class="reference external" href="../example_phi_BEM_hlib/simulation_films/thinfilm20_hlib.py">thinfilm20_hlib.py</a>, etc.)
has been written. It is important to start every simulation as a
single process (by calling <tt class="docutils literal"><span class="pre">nsim</span> <span class="pre">thinfilm20_full.py</span> <span class="pre">--clean</span></tt> etc.),
so that there are no overlaps in the memory access of different
simulations. From every script a routine <tt class="docutils literal"><span class="pre">run_simulation</span></tt> which is
imported from a local nsim module <a class="reference external" href="../example_phi_BEM_hlib/simulation_films/simtools.py">simtools.py</a>, starts a simulation specified by
its arguments (name of the simulation, name of the mesh file, name of
hlib object in case hierarchical matrices are used, and the tolerance
for the time integrator) and returns the number of nodes of the mesh,
the simulation's memory consumption and the setup- and relaxation
times. These values are then written to a file <tt class="docutils literal"><span class="pre">timings_hlib.dat</span></tt> or
<tt class="docutils literal"><span class="pre">timings_full.dat</span></tt>, respectively.</p>
<p>Beside extracting the information on the performance, it is also important to
check, whether simulations using the full boundary element matrix and a
hierarchical matrix approximation actually do the same, and that the simulated
behaviour is physically correct.</p>
<p>Looking at the spatially averaged magnetisation we find a very good agreement
between both simulation types (example given for the film with an edge length of
100nm):</p>
<div align="center" class="align-center"><img alt="../example_phi_BEM_hlib/relaxation_m.png" class="align-center" src="../example_phi_BEM_hlib/relaxation_m.png" /></div>
<p>The magnetisation field moves from its out-of-plane configuration into the plane
and relaxes into a high remanent state, which is aligned along the diagonal of the
square base. The plot below shows a 3d visualisation of the relaxed magnetisation
field (obtained with Mayavi2) for a thin film with an edge length of 130 nm.</p>
<div align="center" class="align-center"><img alt="../example_phi_BEM_hlib/thinfilm130.png" class="align-center" src="../example_phi_BEM_hlib/thinfilm130.png" /></div>
<p>We have run the simulations on a machine with an
<cite>AMD Athlon(tm) 64 X2 Dual Core Processor 3800+</cite>, using only one core. The
graphs below show the results of our efficiency test of hierarchical matrices.
It can be seen that the memory requirements are reduced considerably. While the
consumed memory increases (almost) linearly with the number of surface nodes <cite>N</cite>
for the calculation with hierarchical matrices, the increase is of a higher
order (O(<cite>N</cite><sup>4/3</sup>)), when using the accurate boundary element matrix
<strong>B</strong>. The enhanced scaling behaviour allows for simulation of larger
ferromagnetic structures. The graph
on the memory consumption should enable users to estimate, whether they can
simulate a certain structure with Nmag+HLib and the available hardware.</p>
<div align="center" class="align-center"><img alt="../example_phi_BEM_hlib/performance.png" class="align-center" src="../example_phi_BEM_hlib/performance.png" /></div>
<p>Besides the savings in memory, hierarchical matrices also reduce the time needed
for the simulation setup considerably (see the bottom graph).</p>
</div>
<div class="section" id="hlib-and-mpi">
<h3><a class="toc-backref" href="manual.html#id106">2.22.6&nbsp;&nbsp;&nbsp;HLib and MPI</a></h3>
<p>The <a class="reference external" href="http://www.hlib.org">HLib</a> library that is available for academic use does not support
parallel execution. It is thus stored on the master node, and cannot
be distributed over several nodes. Simulations using the Hlib library
can use MPI (for all other calculations).</p>
</div>
</div>
<div class="section" id="id23">
<span id="example-timestepper-tolerances"></span><span id="example-tolerances"></span><h2><a class="toc-backref" href="manual.html#id107">2.23&nbsp;&nbsp;&nbsp;Example: Timestepper tolerances</a></h2>
<p>The tolerance settings of a simulation can greatly affect the
performance, the accuracy and the usefulness of a simulation. Section
<a class="reference internal" href="manual.html#solvers-and-tolerance-settings">Solvers and tolerance settings</a> provides an overview. In this
example, we demonstrate</p>
<ul class="simple">
<li>how the time integrator's tolerances can be set and</li>
<li>how these tolerances affect the simulation results and performance.</li>
</ul>
<p>The time integrator we use is the PVODE solver from the <a class="reference external" href="http://www.llnl.gov/CASC/sundials/">SUNDIALS</a>
package. It is optimised to deal with stiff systems of ordinary
differential equations and is therefore very suited for micromagnetic
simulations. It can also execute in parallel (i.e. across several CPUs
at the same time using MPI). The computational challenge of the time
integration lies in the different time scales associated with the
(fast) exchange field and the (slower) demagnetisation field.</p>
<p>Sundials provides two parameters <tt class="docutils literal"><span class="pre">rtol</span></tt> and <tt class="docutils literal"><span class="pre">atol</span></tt> (see <a class="reference external" href="https://computation.llnl.gov/casc/sundials/documentation/cv_guide.pdf">sundials
documentation</a>)
to control the required accuracy of the calculations. Sundials uses
these parameters to determine the number of iterations required to
simulate a given amount of real time (for example one pico
second). Equivalently, these parameters determine the amount of real
time that can be simulated per iteration.</p>
<p>It is common that the amount of time simulated per iteration varies
throughout a simulation as different time step sizes are required to
resolve the physics to the same accuracy level. (The <a class="reference internal" href="manual.html#ndt">ndt</a> data file
contains one column <tt class="docutils literal"><span class="pre">last_step_dt</span></tt> which provides the size of the
time step. Use <a class="reference internal" href="manual.html#ncol">ncol</a> to extract this data conveniently.)</p>
<p>The sundials tolerance parameters <tt class="docutils literal"><span class="pre">rtol</span></tt> and <tt class="docutils literal"><span class="pre">atol</span></tt> can be set in
nmag using the <tt class="docutils literal"><span class="pre">ts_rel_tol</span></tt> and <tt class="docutils literal"><span class="pre">ts_abs_tol</span></tt> arguments in the
<a class="reference internal" href="manual.html#set-params">set_params</a> function. (The letters <tt class="docutils literal"><span class="pre">ts</span></tt> in <tt class="docutils literal"><span class="pre">ts_rel_tol</span></tt> and
<tt class="docutils literal"><span class="pre">ts_abs_tol</span></tt> stand for Time Stepper).</p>
<p>The integration of the Landau Lifshitz and Gilbert equation is carried
out on the <em>normalised</em> magnetisation, and the corresponding field
(see <a class="reference internal" href="manual.html#fields-and-subfields-in-nmag">Fields and Subfields in nmag</a>) is called <tt class="docutils literal"><span class="pre">m</span></tt> (the magnetisation with the saturation magnetisation magnitude is called capital <tt class="docutils literal"><span class="pre">M</span></tt> in nmag). Because this
field is normalised, we set <tt class="docutils literal"><span class="pre">rtol</span></tt> and <tt class="docutils literal"><span class="pre">atol</span></tt> to the same value in
this example, and refer to the value just as <tt class="docutils literal"><span class="pre">tol</span></tt>.</p>
<p>We use the program <a class="reference external" href="../example_tolerances/bar_tol.py">bar_tol.py</a> that:</p>
<ul class="simple">
<li>re-uses the bar studied in <a class="reference internal" href="manual.html#example-2">example 2</a> but</li>
<li>carries out the time integration for a number of different tolerance values.</li>
</ul>
<pre class="literal-block">
import nmag
from nmag import SI

import time #python standard modules, used to measure run time

def run_sim(tol):
    &quot;&quot;&quot;Function that is called repeatedly with different tolerance values.
    Each function call is carrying out one simulation.
    &quot;&quot;&quot;
    mat_Py = nmag.MagMaterial(name=&quot;Py&quot;,
                              Ms=SI(0.86e6,&quot;A/m&quot;),
                              exchange_coupling=SI(13.0e-12, &quot;J/m&quot;),
                              llg_damping=0.5)

    #compose name of simulation to inlude value of tolerance
    sim = nmag.Simulation(&quot;bar_%.6f&quot; % tol)

    sim.load_mesh(&quot;bar30_30_100.nmesh.h5&quot;,
                  [(&quot;Py&quot;, mat_Py)],
                  unit_length=SI(1e-9,&quot;m&quot;))

    sim.set_m([1,0,1])

    #set tolerance (has to be called after set_m())
    sim.set_params(ts_abs_tol=tol, ts_rel_tol=tol)

    dt = SI(2.5e-12, &quot;s&quot;) 

    timing = 0 #initialise variable to measure execution time

    for i in range(0, 121): 
        timing -= time.time()    #start measuring time
        sim.advance_time(dt*i)   #compute time development for 300ps
        timing += time.time()    #stop measuring time
                                 #we exclude time required to save data
                                 
        sim.save_data()          #save averages every 2.5 ps

    #at end of simulation, write performance data into summary file
    f=open('resultsummary.txt','a') #open file to append 
    f.write('%g %d %g\n' % (tol,sim.clock['step'],timing))
    f.close()


#main program
tols = [1e-1,1e-2,1e-3,1e-4,1e-5,1e-6]

for tol in tols:
    run_sim(tol)



</pre>
<p>From a conceptual point of view, we see something new here: the section of the code that starts with:</p>
<pre class="literal-block">
def run_sim(tol):
</pre>
<p><tt class="docutils literal"><span class="pre">def</span></tt>ines a function with name <tt class="docutils literal"><span class="pre">run_sim</span></tt> which will carry out a
complete simulation every time it is called. It takes one argument:
the parameter <tt class="docutils literal"><span class="pre">tol</span></tt>. The simulation name (which is re-used in the
name of the <a class="reference internal" href="manual.html#ndt">ndt</a> data file) contains the value of <tt class="docutils literal"><span class="pre">tol</span></tt>. For
example, if the <tt class="docutils literal"><span class="pre">tol=0.1</span></tt>, then the name of the simulation is
<tt class="docutils literal"><span class="pre">bar_0.100000</span></tt> and the name of the ndt data file is
<tt class="docutils literal"><span class="pre">bar_0.100000_dat.ndt</span></tt>. We can thus call this function repeatedly
for different values of <tt class="docutils literal"><span class="pre">tol</span></tt>, and each time a complete simulation
will be run and new data files created. <a class="footnote-reference" href="manual.html#id25" id="id24">[11]</a></p>
<p>The main loop of the script:</p>
<pre class="literal-block">
#main program
tols = [1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1.0]

for tol in tols:
    run_sim(tol)
</pre>
<p>simply iterates over values <tt class="docutils literal"><span class="pre">0.1,</span> <span class="pre">0.01,</span> <span class="pre">0.001,</span> <span class="pre">0.0001,</span> <span class="pre">0.00001</span></tt> and
<tt class="docutils literal"><span class="pre">0.000001</span></tt> and calls the function <tt class="docutils literal"><span class="pre">run_sim</span></tt> with a different
tolerance value in every iteration of the for-loop.</p>
<p>Once the program has finished, we have data files
<tt class="docutils literal"><span class="pre">bar_0.000001_dat.ndt,</span> <span class="pre">bar_0.000010_dat.ndt,</span> <span class="pre">...</span></tt> and
<tt class="docutils literal"><span class="pre">bar_0.100000_dat.ndt</span></tt> that can be analysed and plotted in the usual
way.</p>
<p>We show a plot of the x, y and z components of the magnetisation
against time (as in <a class="reference internal" href="manual.html#example-2">example 2</a>) for each of the tolerance
values. The run with <tt class="docutils literal"><span class="pre">tol=1e-6</span></tt> is the most accurate, and the
corresponding black line has been tagged with little <tt class="docutils literal"><span class="pre">+</span></tt> characters.</p>
<div align="center" class="align-center"><img alt="../example_tolerances/plot1.png" class="align-center" src="../example_tolerances/plot1.png" /></div>
<p>We can see that curves seem to coincide (at this scale) apart from the
red <tt class="docutils literal"><span class="pre">tol=1e-1</span></tt> curve which deviates somewhat.
We zoom in to region between 1.2e-10 seconds and 2e-10 seconds and
focus on the lowers curves in the main plot:</p>
<div align="center" class="align-center"><img alt="../example_tolerances/plot2.png" class="align-center" src="../example_tolerances/plot2.png" /></div>
<p>The better resolution reveals that there is a clear deviation of the
various curves: the red (0.1), indigo (0.01) and yellow (1e-3) curves
approach the black (1e-6) curve in this order. The blue (1e-4) and
green (1e-5) curves appear to coincide with the black reference curve.</p>
<p>Another zoom at the z-component of the magnetisation towards the end
of the simulated time interval (time&gt;1.8e-10 seconds) shows that the
less accurate curves (red, and then indigo and yellow) show a large
amount of jitter (although following the reference curve <em>on
average</em>).</p>
<div align="center" class="align-center"><img alt="../example_tolerances/plot3.png" class="align-center" src="../example_tolerances/plot3.png" /></div>
<p>We conclude that we should use a tolerance of at most 1e-3 for this
simulation; better 1e-4 or smaller.</p>
<p>In simulation work, we are of course interested to get the most
accurate simulation results. However, in reality this is conflicting
with the increased run time that is associated with more accurate
simulations. In this example, we have written some performance data
into <a class="reference external" href="../example_tolerances/resultsummary.txt">resultssummary.txt</a>. Reformatted,
postprocessed and the rows re-ordered, this is the data complete with
table headings:</p>
<pre class="literal-block">
========== ========== ============== =====================
       tol      steps   CPU time (s) CPU time per step (s)
========== ========== ============== =====================
  0.000001        740         120.81                 0.163
  0.000010        356          62.37                 0.175
  0.000100        182          46.10                 0.253
  0.001000        119          66.36                 0.558
  0.010000        114          92.08                 0.808
  0.100000         88          94.69                 1.076
========== ========== ============== =====================

</pre>
<p>The accuracy of the simulation results decreases from the top of the
table downwards. We know from the graphs above that we should use a
tolerance setting of 1e-4 or smaller to obtain fairly accurate results
(assuming that the 1e-6 curve is used as a reference).</p>
<p>The number of iterations required increases from the tolerance 1e-4 to
tolerance 1e-6 by a factor of 4 while the total CPU time increases by
a factor of 2.6.</p>
<p>Looking at the greater tolerances 1e-3 and 0.01, we see that while the
number of iterations required decreases, the CPU time is
increasing. This is the first indication that at this tolerance level
the system becomes difficult to treat efficiently by sundials (it
basically appears to be noisy and stochastic equations are hard to
integrate).</p>
<p>In summary,</p>
<ul class="simple">
<li>to minimise the simulation time, we need to choose a tolerance value
as large as &quot;possible&quot;.</li>
<li>The definition of &quot;possible&quot; will depend on the context. A good way
of obtaining a suitable tolerance value is to run the same simulation
repeatedly with decreasing tolerance values. Once the resulting curves
converge (as a function of decreasing tolerance settings), a good tolerance level
has been found. (This would be 1e-4 for the example shown here.)</li>
<li>Choosing the tolerance values to be too large, can be counter
productive (and take much more CPU time than the lower accuracy
level).</li>
<li>The default value for the sundials tolerances is shown in the
documentation of <a class="reference internal" href="manual.html#set-params">set_params</a>. A simulation can often be accelerated
significantly by increasing this value.</li>
<li>A change of the tolerances has to be considered together with the
convergence criterion for hysterises loop calculations (see next
section: <a class="reference internal" href="manual.html#hysteris-loop-calculation-not-converging-a-word-of-warning">Hysteris loop calculation not converging? A word of warning ...</a>)</li>
</ul>
<div class="section" id="hysteris-loop-calculation-not-converging-a-word-of-warning">
<h3><a class="toc-backref" href="manual.html#id108">2.23.1&nbsp;&nbsp;&nbsp;Hysteris loop calculation not converging? A word of warning ...</a></h3>
<p>The <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> and the <a class="reference internal" href="manual.html#relax">relax</a> command need to have a criterion how to
decide when the simulation has reached a (meta)stable state and when
the relaxation (at a given applied field) should be considered to have
been reached. A common approach (which is used by OOMMF and nmag, for
example) is to monitor the change of the (normalised) magnetisation
with respect to time (i.e. dm/dt). If the absolute value of this drops
below a given threshold, then one considers the system as converged
(the <a class="reference internal" href="manual.html#relax">relax</a> command will return at this point, while the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a>
command will move to the next field). This threshold can be changed
from its default value with the <a class="reference internal" href="manual.html#set-params">set_params</a> simulation method (the
attribute is <cite>stopping_dm_dt</cite>).</p>
<p>The choice of the tolerances (<cite>ts_rel_tol</cite> and <cite>ts_abs_tol</cite>) <em>must</em>
respect the chosen <cite>stopping_dm_dt</cite> value (or conversely
the <cite>stopping_dm_dt</cite> needs to be adapted to work with
the chosen tolerances):
large values for the tolerances correspond to lower accuracy
and to larger random fluctuations of dm/dt,
which consequently may never become lower than <cite>stopping_dm_dt</cite>.
In such a case the simulation never returns from the <a class="reference internal" href="manual.html#relax">relax</a> command,
because the convergence criterion is never satisfied.</p>
<p>In all the examples we have studied, we have found that the default
parameters work fine. However, if you find that a simulation never
returns from the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> or <a class="reference internal" href="manual.html#relax">relax</a> command, it is worth reducing
the tolerances for the time stepper (on increasing <cite>stopping_dm_dt</cite>)
to see whether this resolves the problem).</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="manual.html#id24">[11]</a></td><td>We could, in fact, avoid re-creating all the operator matrices
and the BEM, and just repeat the simulation with varying values of the
<tt class="docutils literal"><span class="pre">tol</span></tt> parameter. However, this would mean that the data is written
into the same file (so is slightly less convenient here).  It would
also be a less pedagogical example in this guided tour.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="example-parallel-execution-mpi">
<h2><a class="toc-backref" href="manual.html#id109">2.24&nbsp;&nbsp;&nbsp;Example: Parallel execution (MPI)</a></h2>
<p>Nmag's numerical core (which is part of the nsim multi-physics
library) has been designed to carry out numerical computation on
several CPUs simultaneously. The protocol that we are using for this
is the wide spread Message Passing Interface (MPI). There are a number
of MPI implementations; the best known ones are probably MPICH1,
MPICH2 and LAM-MPI. Currently, we support <a class="reference external" href="http://www-unix.mcs.anl.gov/mpi/mpich1/">MPICH1</a> and <a class="reference external" href="http://www.mcs.anl.gov/research/projects/mpich2">MPICH2</a>.</p>
<p>Which mpi version to use? Whether you want to use mpich1 or mpich2
will depend on your installation: currently, the installation from
source provides mpich2 (which is also used in the virtual machines)
whereas the Debian package relies on mpich1 (no Debian package is
provided after release 0.1-6163).</p>
<div class="section" id="using-mpich2">
<h3><a class="toc-backref" href="manual.html#id110">2.24.1&nbsp;&nbsp;&nbsp;Using mpich2</a></h3>
<p>Before
the actual simulation is started, a <cite>multi-purpose daemon</cite> must be
started when using MPICH2.</p>
<hr class="docutils" />
<p><strong>The ``.mpd.conf`` file</strong></p>
<p>MPICH2 will look for a configuration file with name <tt class="docutils literal"><span class="pre">.mpd.conf</span></tt> in
the user's home directory. If this is missing, an attempt to start
the multi-purpose daemon, will result in an error message like
this:</p>
<pre class="literal-block">
$&gt; mpd
configuration file /Users/fangohr/.mpd.conf not found
A file named .mpd.conf file must be present in the user's home
directory (/etc/mpd.conf if root) with read and write access
only for the user, and must contain at least a line with:
MPD_SECRETWORD=&lt;secretword&gt;
One way to safely create this file is to do the following:
  cd $HOME
  touch .mpd.conf
  chmod 600 .mpd.conf
and then use an editor to insert a line like
  MPD_SECRETWORD=mr45-j9z
into the file.  (Of course use some other secret word than mr45-j9z.)
</pre>
<p>If you don't have this file in your home directory, just follow the
instructions above to create it with some secret word of your choice
(Note that the above example is from a Mac OS X system: on Linux the
home directory is usually under <tt class="docutils literal"><span class="pre">/home/USERNAME</span></tt> rather than
<tt class="docutils literal"><span class="pre">/Users/USERNAME</span></tt> as shown here.)</p>
<hr class="docutils" />
<p>Let's assume we have a multi-core machine with more than one
CPU. This makes the mpi setup slightly easier, and is also likely to
be more efficient than running a job across the network between
difference machines.</p>
<p>First, we need to start the multi-purpose daemon:</p>
<pre class="literal-block">
$&gt; mpd &amp;
</pre>
<p>It will look  for the file <tt class="docutils literal"><span class="pre">~/.mpd.conf</span></tt> as described above. If found, it will start silently. Otherwise it will complain.</p>
<div class="section" id="testing-that-nsim-executes-in-parallel">
<h4>2.24.1.1&nbsp;&nbsp;&nbsp;Testing that nsim executes in parallel</h4>
<p>First, let's make sure that <tt class="docutils literal"><span class="pre">nsim</span></tt> is in the search path. The command <tt class="docutils literal"><span class="pre">which</span> <span class="pre">nsim</span></tt> will return the location of the executable if it can be found in the search path. For example:</p>
<pre class="literal-block">
$&gt; which nsim
/home/fangohr/new/nmag-0.1/bin/nsim
</pre>
<p>To execute nsim using two processes, we can use the command:</p>
<pre class="literal-block">
$&gt; mpiexec -n 2 nsim
</pre>
<p>There are two useful commands to check whether nsim is aware of the intended MPI setup. The fist one is <tt class="docutils literal"><span class="pre">ocaml.mpi_status()</span></tt> which provides the total number of processes in the MPI set-up:</p>
<pre class="literal-block">
$&gt; mpiexec -n 2 nsim
&gt;&gt;&gt; ocaml.mpi_status()
MPI-status: There are 2 nodes (this is the master, rank=0)
&gt;&gt;&gt;
</pre>
<p>The other command is <tt class="docutils literal"><span class="pre">ocaml.mpi_hello()</span></tt> and prints a short 'hello' from all processes:</p>
<pre class="literal-block">
&gt;&gt;&gt; ocaml.mpi_hello()
&gt;&gt;&gt; [Node   0/2] Hello from beta.kk.soton.ac.uk
[Node   1/2] Hello from beta.kk.soton.ac.uk
</pre>
<p>For comparison, let's look at the output of these commands if we start <tt class="docutils literal"><span class="pre">nsim</span></tt> <em>without</em> MPI, in which case only one MPI node is reported:</p>
<pre class="literal-block">
$&gt; nsim
&gt;&gt;&gt; ocaml.mpi_status()
MPI-status: There are 1 nodes (this is the master, rank=0)
&gt;&gt;&gt; ocaml.mpi_hello()
[Node   0/1] Hello from beta.kk.soton.ac.uk
</pre>
<p>Assuming this all works, we can now start the actual simulation. To
use two CPUs on the local machine to run the <tt class="docutils literal"><span class="pre">bar30_30_100.py</span></tt>
program, we can use:</p>
<pre class="literal-block">
$&gt; mpiexec -n 2 nsim bar30_30_100.py
</pre>
<p>To run the program again, using 4 CPUs on the local machine:</p>
<pre class="literal-block">
$&gt; mpiexec -n 4 nsim bar30_30_100.py
</pre>
<p>Note that mpich2 (and mpich1) will spawn more processes than there are
CPUs if necessary. I.e. if you are working on some Intel Dual Core
processor (with 2 CPUs and one core each) but request to run your
program with 4 (via the <tt class="docutils literal"><span class="pre">-n</span> <span class="pre">4</span></tt> switch given to <tt class="docutils literal"><span class="pre">mpiexec</span></tt>), than
you will have 4 processes running on the 2 CPUs.</p>
<p>If you want to stop the <tt class="docutils literal"><span class="pre">mpd</span></tt> daemon, you can use:</p>
<pre class="literal-block">
$&gt; mpdallexit
</pre>
<p>For diagnostic purposes, the <tt class="docutils literal"><span class="pre">mpdtrace</span></tt> command can be use to track
whether a multipurpose daemon is running (and which machines are part
of the <cite>mpi-ring</cite>).</p>
<p><strong>Advanced usage of mpich2</strong></p>
<p>To run a job across different machines, one needs to start the
multi-purpose daemons on the other machines with the <tt class="docutils literal"><span class="pre">mpdboot</span></tt>
command. This will search for a file (in the current directory) with
name <tt class="docutils literal"><span class="pre">mpd.hosts</span></tt> which should contain a list of hosts to participate
(very similar to the <tt class="docutils literal"><span class="pre">machinefile</span></tt> in MPICH1).</p>
<p>To trace which process is sending what messages to the standard out,
one can add the <tt class="docutils literal"><span class="pre">-l</span></tt> switch to the <tt class="docutils literal"><span class="pre">mpiexec</span></tt> command: then each
line of standard output will be preceded by the rank of the process
who has issued the message.</p>
<p>Please refer to the official <a class="reference external" href="http://www.mcs.anl.gov/research/projects/mpich2">MPICH2</a>  documentation for further details.</p>
</div>
</div>
<div class="section" id="using-mpich1">
<h3><a class="toc-backref" href="manual.html#id111">2.24.2&nbsp;&nbsp;&nbsp;Using mpich1</a></h3>
<p>Note: Most users will use MPICH2 (if they have compiled Nmag from the tar-ball): see <a class="reference internal" href="manual.html#using-mpich2">Using mpich2</a></p>
<p>Suppose we would like to run <a class="reference internal" href="manual.html#example-2">example 2</a> of the manual with 2
processors using MPICH1. We need to know the full path to the <tt class="docutils literal"><span class="pre">nsim</span></tt> executable. In
a <tt class="docutils literal"><span class="pre">bash</span></tt> environment (this is pretty much the standard on Linux and
Mac OS X nowadays), you can find the path using the <tt class="docutils literal"><span class="pre">which</span></tt>
command. On a system where nsim was installed from the Debian package:</p>
<pre class="literal-block">
$&gt; which nsim
/usr/bin/nsim
</pre>
<p>Let's assume we have a multi-core machine with more than one
CPU. This makes the mpi setup slightly easier, and is also likely to
be more efficient than running a job across the network between
difference machines. In that case, we can run the example on 2 CPUs using:</p>
<pre class="literal-block">
$&gt; mpirun -np 2 /usr/bin/nsim bar30_30_100.py
</pre>
<p>where <tt class="docutils literal"><span class="pre">-np</span></tt> is the command line argument for the Number of Processors.</p>
<p>To check that the code is running on more than one CPU, one of the
first few log messages will display (in addition to the runid of the
simulation) the number of CPUs used:</p>
<pre class="literal-block">
$&gt; mpirun -np 2 `which nsim` bar30_30_100.py

    nmag:2008-05-20 12:50:01,177   setup.py  269    INFO Runid (=name simulation) is 'bar30_30_100', using 2 CPUs
</pre>
<p>To use 4 processors (if we have a quad core machine available), we would use:</p>
<pre class="literal-block">
$&gt; mpirun -np 4 /usr/bin/nsim bar30_30_100.py
</pre>
<p>Assuming that the <tt class="docutils literal"><span class="pre">nsim</span></tt> executable is in the path, and that we are
using a bash-shell, we could shortcut the step of finding the <tt class="docutils literal"><span class="pre">nsim</span></tt>
executable by writing:</p>
<pre class="literal-block">
$&gt; mpirun -np 4 `which nsim` bar30_30_100.py
</pre>
<p>To run the job across the network on different machines
simultaneously, we need to create a file with the names of the hosts
that should be used for the parallel execution of the program. If you
intend to use nmag on a cluster, your cluster administrator should
explain where to find this machine file.</p>
<!-- comment:

If you intend to run the
program just on one machine but want to exploit the fact that this
machine has more than one CPU (as most newer computers have typically
one (or more) multi-core processors), then it is sufficient to write
``localhost`` into a file which we will call ``machines.txt``::

$> echo localhost > machines.txt -->
<p>To distribute a job across <tt class="docutils literal"><span class="pre">machine1.mydomain</span></tt>,
<tt class="docutils literal"><span class="pre">machine2.mydomain</span></tt>, and <tt class="docutils literal"><span class="pre">machine3.mydomain</span></tt> we need to create the
file <tt class="docutils literal"><span class="pre">machines.txt</span></tt> with content:</p>
<pre class="literal-block">
machine1.mydomain
machine2.mydomain
machine3.mydomain
</pre>
<p>We then need to pass the name of this file to the <tt class="docutils literal"><span class="pre">mpirun</span></tt> command
to run a (mpi-enabled) executable with mpich:</p>
<pre class="literal-block">
mpirun -machinefile machines.txt -np 3 /usr/bin/nsim bar30_30_100.py
</pre>
<p>For further details, please refer to the <a class="reference external" href="http://www-unix.mcs.anl.gov/mpi/mpich1/">MPICH1</a> documentation.</p>
</div>
<div class="section" id="visualising-the-partition-of-the-mesh">
<h3><a class="toc-backref" href="manual.html#id112">2.24.3&nbsp;&nbsp;&nbsp;Visualising the partition of the mesh</a></h3>
<p>We use Metis to partition the mesh. Partitioning means to allocate
certain mesh nodes to certain CPUs. Generally, it is good if nodes
that are spatially close to each other are assigned to the same CPU.</p>
<p>Here we demonstrate how the chosen partition can be visualised. As an
example, we use the <a class="reference internal" href="manual.html#example-demag-field-in-uniformly-magnetised-sphere">Example demag field in uniformly magnetised
sphere</a>. We are <a class="reference internal" href="manual.html#using-mpich2">using mpich2</a>:</p>
<pre class="literal-block">
$&gt; mpd &amp;
$&gt; mpiexec -l -n 3 nsim sphere1.py
</pre>
<p>The program starts, and prints the chose partition to stdout:</p>
<pre class="literal-block">
 nfem.ocaml:2008-05-28 15:11:07,757    INFO Calling ParMETIS to partition the me
sh among 3 processors
 nfem.ocaml:2008-05-28 15:11:07,765    INFO Processor 0: 177 nodes
 nfem.ocaml:2008-05-28 15:11:07,765    INFO Processor 1: 185 nodes
 nfem.ocaml:2008-05-28 15:11:07,766    INFO Processor 2: 178 nodes
</pre>
<p>If you can't find the information on the screen (=stdout), then have a
look in <tt class="docutils literal"><span class="pre">sphere1_log.log</span></tt> which contains a copy of the log messages
that have been printed to stdout.</p>
<p>If we save any fields spatially resolved (as with the
<tt class="docutils literal"><span class="pre">sim.save_data(fields='all')</span></tt> command), then nmag will create a file
with name (in this case) <tt class="docutils literal"><span class="pre">sphere1_dat.h5</span></tt>. In addition to the field
data that is saved, it also stores the finite element mesh <em>in the
order that was used when the file was created</em>. In this example, this
is the mesh ordered according to the output from the ParMETIS
package. The first 177 nodes of the mesh in this order are assigned to
CPU0, the next 185 are assigned to CPU1, and the next 178 are assigned to
CPU2.</p>
<p>We can visualise this partition using the <a class="reference internal" href="manual.html#nmeshpp">nmeshpp</a> command (which we
apply here to the mesh that is saved in the <tt class="docutils literal"><span class="pre">sphere1_dat.h5</span></tt> file):</p>
<pre class="literal-block">
$&gt; nmeshpp --partitioning=[177,185,178] sphere1_dat.h5 partitioning.vtk
</pre>
<p>The new file <tt class="docutils literal"><span class="pre">partitioning.vtk</span></tt> contains only one field on the mesh, and this has assigned to each mesh node the id of the associated CPU. We can visualise this, for example, using:</p>
<pre class="literal-block">
$&gt; mayavi -d partitioning.vtk -m SurfaceMap
</pre>
<div align="center" class="align-center"><img alt="../example_mpi1/sphere3partitions.png" class="align-center" src="../example_mpi1/sphere3partitions.png" /></div>
<p>The figure shows that the sphere has been divided into three areas
which carry values 0, 1 and 2 (corresponding to the MPI CPU rank which
goes from 0 to 2 for 3 CPUs). Actually, in this plot we can only see
the surface nodes (but the volume nodes have been partitioned
accordingly).</p>
<p>The process described here is a bit cumbersome to visualise the
partition. This could in principle be streamlined (so that we save the
partition data into the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> data file and can generate the
visualisation without further manual intervention). However, we expect
that this is not a show stopper and will dedicate our time to more
pressing issues. (User feedback and suggestions for improvements are
of course always welcome.)</p>
</div>
<div class="section" id="performance">
<h3><a class="toc-backref" href="manual.html#id113">2.24.4&nbsp;&nbsp;&nbsp;Performance</a></h3>
<p>Here is some data we have obtained on an IBM x440 system (with eight
1.9Ghz Intel Xeon processors). We use a test simulation (located in
<tt class="docutils literal"><span class="pre">tests/devtests/nmag/hyst/hyst.par</span></tt>) which computes a hysteresis
loop for a fairly small system (4114 mesh nodes, 1522 surface nodes,
BEM size 18MB). We use overdamped time integration to determine the
meta-stable states.</p>
<p>Both the setup and the time required to write data will not become
significantly faster when run on more than one CPU. We provide:</p>
<blockquote>
<p><strong>total time</strong>: this includes setup time, time for the main simulation loop and time for writing data (measured in seconds)</p>
<p><strong>total speedup</strong>: The speed up for the total execution time (i.e. ratio of execution time on one CPU to execution time on n CPUs).</p>
<p><strong>sim time</strong>: this is the time spend in the main simulation loop (and this is where expect a speed up)</p>
<p><strong>sim speedup</strong>: the speedup of the main simulation loop</p>
</blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="21%" />
<col width="28%" />
<col width="17%" />
<col width="23%" />
</colgroup>
<tbody valign="top">
<tr><td>CPUs</td>
<td>total time</td>
<td>total speedup</td>
<td>sim time</td>
<td>sim speedup</td>
</tr>
<tr><td>1</td>
<td>4165</td>
<td>1.00</td>
<td>3939</td>
<td>1.00</td>
</tr>
<tr><td>2</td>
<td>2249</td>
<td>1.85</td>
<td>2042</td>
<td>1.93</td>
</tr>
<tr><td>3</td>
<td>1867</td>
<td>2.23</td>
<td>1659</td>
<td>2.37</td>
</tr>
<tr><td>4</td>
<td>1605</td>
<td>2.60</td>
<td>1393</td>
<td>2.83</td>
</tr>
</tbody>
</table>
<p>The numbers shown here have been obtained using mpich2 (and using the
<tt class="docutils literal"><span class="pre">ssm</span></tt> device instead of the default <tt class="docutils literal"><span class="pre">sock</span></tt> device: this is
available on Linux and resulted in a 5% reduction of execution time).</p>
<p>Generally, the (network) communication that is required between the
nodes will slow down the communication. The smaller the system, the
more communication has to happen between the nodes (relative to the
amount of time spent on actual calculation). Thus, one expects a
better speed up for larger systems. The performance of the network is
also crucial: generally, we expect the best speed up on very fast
networks and shared memory systems (i.e. multi-CPU / multi-core
architectures). We further expect the speed-up to become worse (in
comparison to the ideal linear speed-up) with an increasing number of
processes.</p>
</div>
</div>
<div class="section" id="restarting-mpi-runs">
<h2><a class="toc-backref" href="manual.html#id114">2.25&nbsp;&nbsp;&nbsp;Restarting MPI runs</a></h2>
<p>There is one situation that should be avoided when exploiting parallel
computation. Usually, a simulation (involving for example a hysteresis
loop), can be continued using the <tt class="docutils literal"><span class="pre">--restart</span></tt> switch. This is also
true for MPI runs.</p>
<p>However, the number of CPUs used <em>must not change</em> between the initial
and any subsequent runs. (The reason for this is that the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt>
file needs to store the mesh as it has been reordered for <em>n</em> CPUs. If
we continue the run with another number of CPUs, the mesh data will
not be correct anymore which will lead to errors when extracting the
data from the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> file.)</p>
<p>Note also that there is currently no warning issued if a user ventures
into such a simulation.</p>
<!-- comment:
See here for mpich2 intro: http://magnet.atp.tuwien.ac.at/scholz/magpar/doc/html/examples.html#parallel -->
<!-- comment
.. include:: example_timestepper_params/doc.txt -->
</div>
<div class="section" id="more-than-one-magnetic-material-exchange-coupled">
<h2><a class="toc-backref" href="manual.html#id115">2.26&nbsp;&nbsp;&nbsp;More than one magnetic material, exchange coupled</a></h2>
<p>To be written.</p>
</div>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="manual.html#id116">3&nbsp;&nbsp;&nbsp;Background</a></h1>
<p>In this section, we list some background information on the simulation
package, some explanation of the philosophy behind it (which may
explain some of the user interface choices that have been made) and
explanation of some terms that are relevant.</p>
<div class="section" id="the-nsim-library">
<span id="nsim-library"></span><h2><a class="toc-backref" href="manual.html#id117">3.1&nbsp;&nbsp;&nbsp;The nsim library</a></h2>
<p>Nmag is the high-level user interface that provides micromagnetic
capabilities to a general purpose finite element multi-physics field
theory library called nsim. Therefore, many of the concepts used by
Nmag are inherited from nsim.</p>
</div>
<div class="section" id="fields-and-subfields">
<h2><a class="toc-backref" href="manual.html#id118">3.2&nbsp;&nbsp;&nbsp;Fields and subfields</a></h2>
<div class="section" id="field">
<span id="fields"></span><h3><a class="toc-backref" href="manual.html#id119">3.2.1&nbsp;&nbsp;&nbsp;Field</a></h3>
<p>The <a class="reference internal" href="manual.html#field">Field</a> is the central entity within the <a class="reference internal" href="manual.html#nsim-library">nsim library</a>. It represents physical
fields such as:</p>
<ul class="simple">
<li>magnetisation (usually a 3d vector field),</li>
<li>the magnetic exchange field (usually a 3d vector field), or</li>
<li>magnetic exchange energy (a scalar field).</li>
</ul>
<p>A field may contain degrees of freedom of different type, which belong
to different parts of a simulated object. For example, the
magnetisation field may contain the effective magnetisation (density)
for more than one type of magnetic atoms, which may make up different
parts of the object studied. In order to deal with this, we introduce
the concept of <a class="reference internal" href="manual.html#subfield">subfield</a>s: A Nmag/nsim field can be regarded as a
collection of subfields. Most often, there only is one subfield in a
field, but when it makes sense to group together multiple conceptually
independent fields (such as the effective magnetisation of the iron
atoms in a multilayer structure and that of some other magnetic metal
also present in the structure), a field may contain more than one
subfield: In particular, the magnetisation field <tt class="docutils literal"><span class="pre">M</span></tt> may contain
subfields <tt class="docutils literal"><span class="pre">M_Fe</span></tt> and <tt class="docutils literal"><span class="pre">M_Co</span></tt>.</p>
<p>The question what subfields to group together is partly a question of
design. For Nmag, the relevant choices have been made by the Nmag
developers, so the user should not have to worry about this.</p>
</div>
<div class="section" id="subfield">
<h3><a class="toc-backref" href="manual.html#id120">3.2.2&nbsp;&nbsp;&nbsp;Subfield</a></h3>
<p>Each field contains one or more <a class="reference internal" href="manual.html#subfield">subfield</a>s. For example, a
simulation with two different types of magnetic material (for example
Fe and Dy), has a field <tt class="docutils literal"><span class="pre">m</span></tt> for the normalised magnetisation and
this would contain two subfields <tt class="docutils literal"><span class="pre">m_Fe</span></tt> and <tt class="docutils literal"><span class="pre">m_Dy</span></tt>.</p>
<p>(It is partly a question of philosophy whether different material
magnetisations are treated as subfields in one field, or whether they
are treated as two fields. For now, we have chosen to collect all the
material magnetisations as different subfields in one field.)</p>
<p>Often, a field contains only one subfield and this may carry the same
name as the field.</p>
</div>
</div>
<div class="section" id="fields-and-subfields-in-nmag">
<h2><a class="toc-backref" href="manual.html#id121">3.3&nbsp;&nbsp;&nbsp;Fields and Subfields in Nmag</a></h2>
<div class="section" id="example-one-magnetic-material">
<h3><a class="toc-backref" href="manual.html#id122">3.3.1&nbsp;&nbsp;&nbsp;Example: one magnetic material</a></h3>
<p>Assuming we have a simulation of one material with name PermAlloy (Py),
we would have the following <a class="reference internal" href="manual.html#field">field</a>s and <a class="reference internal" href="manual.html#subfield">subfield</a>s:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="20%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Field</th>
<th class="head">Subfield</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>m</td>
<td>m_Py</td>
<td>normalised magnetisation</td>
</tr>
<tr><td>M</td>
<td>M_Py</td>
<td>magnetisation</td>
</tr>
<tr><td>H_total</td>
<td>H_total_Py</td>
<td>total effective field</td>
</tr>
<tr><td>H_ext</td>
<td>H_ext</td>
<td>external (applied) field (only one)</td>
</tr>
<tr><td>E_ext</td>
<td>E_ext_Py</td>
<td>energy density of Py due to external field</td>
</tr>
<tr><td>H_anis</td>
<td>H_anis_Py</td>
<td>crystal anisotropy field</td>
</tr>
<tr><td>E_anis</td>
<td>E_anis_Py</td>
<td>crystal anisotropy energy density</td>
</tr>
<tr><td>H_exch</td>
<td>H_exch_Py</td>
<td>exchange field</td>
</tr>
<tr><td>E_exch</td>
<td>E_exch_Py</td>
<td>exchange energy</td>
</tr>
<tr><td>H_demag</td>
<td>H_demag</td>
<td>demagnetisation field (only one)</td>
</tr>
<tr><td>E_demag</td>
<td>E_demag_Py</td>
<td>demagnetisation field energy density for Py</td>
</tr>
<tr><td>phi</td>
<td>phi</td>
<td>scalar potential for H_demag</td>
</tr>
<tr><td>rho</td>
<td>rho</td>
<td>magnetic charge density (div M)</td>
</tr>
<tr><td>H_total</td>
<td>H_total_Py</td>
<td>total effective field</td>
</tr>
</tbody>
</table>
<p>It is worth noting that the names of the fields are fixed whereas the
subfield names are (often) material dependent and given by</p>
<ul class="simple">
<li>the name of the field and the material name (joined through '<tt class="docutils literal"><span class="pre">_</span></tt>')
if there is one (material-specific) subfield for every magnetisation or</li>
<li>the name of the field if there is only one subfield (such as the
demagnetisation field or the applied external field)</li>
</ul>
<p>This may seem a little bit confusing at first, but is easy to
understand once one accepts the general rule that the
material-dependent quantities - and only those - contain a
material-related suffix. All atomic species experience the
demagnetisation field in the same way, so this has to be <tt class="docutils literal"><span class="pre">H_demag</span></tt>
(i.e. non-material-specific). On the other hand, anisotropy depends on
the atomic species, so this is <tt class="docutils literal"><span class="pre">H_anis_Py</span></tt>, and therefore, the total
effective field also has to be material-specific: <tt class="docutils literal"><span class="pre">H_total_Py</span></tt>. (All
this becomes particularly relevant in systems where two types of
magnetic atoms are embedded in the same crystal lattice.)</p>
</div>
<div class="section" id="example-two-magnetic-material">
<h3><a class="toc-backref" href="manual.html#id123">3.3.2&nbsp;&nbsp;&nbsp;Example: two magnetic material</a></h3>
<p>This table from the <a class="reference internal" href="manual.html#example-two-different-magnetic-materials">Example: two different magnetic materials</a> shows
the fields and subfields when more than one material is involved:</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="28%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Field</th>
<th class="head">Subfield(s)</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>m</td>
<td>m_Py, m_Co</td>
<td>normalised magnetisation</td>
</tr>
<tr><td>M</td>
<td>M_Py, M_Co</td>
<td>magnetisation</td>
</tr>
<tr><td>H_total</td>
<td>H_total_Py, H_total_Co</td>
<td>total effective field</td>
</tr>
<tr><td>H_ext</td>
<td>H_ext</td>
<td>external (applied) field (only one)</td>
</tr>
<tr><td>E_ext</td>
<td>E_ext_Py, E_ext_Co</td>
<td>energy density of Py due to external field</td>
</tr>
<tr><td>H_anis</td>
<td>H_anis_Py, H_anis_Co</td>
<td>crystal anisotropy field</td>
</tr>
<tr><td>E_anis</td>
<td>E_anis_Py, E_anis_Co</td>
<td>crystal anisotropy energy density</td>
</tr>
<tr><td>H_exch</td>
<td>H_exch_Py, H_exch_Co</td>
<td>exchange field</td>
</tr>
<tr><td>E_exch</td>
<td>E_exch_Py, E_exch_Co</td>
<td>exchange energy</td>
</tr>
<tr><td>H_demag</td>
<td>H_demag</td>
<td>demagnetisation field (only one)</td>
</tr>
<tr><td>E_demag</td>
<td>E_demag_Py, E_demag_Co</td>
<td>demagnetisation field energy density</td>
</tr>
<tr><td>phi</td>
<td>phi</td>
<td>scalar potential for H_demag</td>
</tr>
<tr><td>rho</td>
<td>rho</td>
<td>magnetic charge density (div M)</td>
</tr>
<tr><td>H_total</td>
<td>H_total_Py, H_total_Co</td>
<td>total effective field</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="obtaining-and-setting-subfield-data">
<h3><a class="toc-backref" href="manual.html#id124">3.3.3&nbsp;&nbsp;&nbsp;Obtaining and setting subfield data</a></h3>
<p>Data contained in subfields can be written to files (using
<a class="reference internal" href="manual.html#save-data">save_data</a>), can be probed at particular points in space
(<a class="reference internal" href="manual.html#probe-subfield">probe_subfield</a>, <a class="reference internal" href="manual.html#probe-subfield-siv">probe_subfield_siv</a>), or can be obtained from all
sites simultaneously (<a class="reference internal" href="manual.html#get-subfield">get_subfield</a>). Some data can also be set (in
particular the applied field <tt class="docutils literal"><span class="pre">H_ext</span></tt> using <a class="reference internal" href="manual.html#set-h-ext">set_H_ext</a> and all the
subfields belonging to the field <tt class="docutils literal"><span class="pre">m</span></tt> using <a class="reference internal" href="manual.html#set-m">set_m</a>).</p>
</div>
<div class="section" id="primary-and-secondary-fields">
<h3><a class="toc-backref" href="manual.html#id125">3.3.4&nbsp;&nbsp;&nbsp;Primary and secondary fields</a></h3>
<p>There are two different types of fields in nmag: <em>primary</em> and
<em>secondary</em> fields.</p>
<p><em>Primary fields</em> are those that the user can set
arbitrarily. Currently, these are the (normalised) magnetisation <tt class="docutils literal"><span class="pre">m</span></tt>
and the external field <tt class="docutils literal"><span class="pre">H_ext</span></tt> (which can be modified with <a class="reference internal" href="manual.html#set-m">set_m</a>
and <a class="reference internal" href="manual.html#set-h-ext">set_H_ext</a>).</p>
<p><em>Secondary</em> fields (which could also be called <em>dependent fields</em>) can
not be set directly from the user but are computed from the primary
fields.</p>
</div>
</div>
<div class="section" id="mesh">
<h2><a class="toc-backref" href="manual.html#id126">3.4&nbsp;&nbsp;&nbsp;Mesh</a></h2>
<p>In finite element calculations, we need a mesh to define the geometry
of the system. For development and debugging purposes, nsim includes
some (at present undocumented) capabilities to generate toy meshes
directly from geometry specifications, but for virtually all nsim
applications, the user will have to use an external tool to generate a
(tetrahedral) mesh file describing the geometry.</p>
<div class="section" id="node">
<h3><a class="toc-backref" href="manual.html#id127">3.4.1&nbsp;&nbsp;&nbsp;Node</a></h3>
<p>Roughly speaking, a mesh is a tessellation of space where the support
points are called <em>mesh nodes</em>. nmag uses an unstructured mesh
(i.e. the cells filling up three-dimensional space are tetrahedra).</p>
</div>
<div class="section" id="node-id">
<h3><a class="toc-backref" href="manual.html#id128">3.4.2&nbsp;&nbsp;&nbsp;node id</a></h3>
<p>Each node in the finite element mesh has an associated node id. This
is an integer (starting from 0 for the first node).</p>
<p>This information is used when defining which node is connected to
which (see <a class="reference internal" href="manual.html#finite-element-mesh-generation">Finite element mesh generation</a> for more details), and
when defining the <a class="reference internal" href="manual.html#sites">sites</a> at which the field degrees of freedom are
calculated.</p>
</div>
<div class="section" id="node-position">
<h3><a class="toc-backref" href="manual.html#id129">3.4.3&nbsp;&nbsp;&nbsp;node position</a></h3>
<p>The position (as a 3d vector) in space of a node.</p>
</div>
</div>
<div class="section" id="site">
<span id="sites"></span><h2><a class="toc-backref" href="manual.html#id130">3.5&nbsp;&nbsp;&nbsp;Site</a></h2>
<p>A <a class="reference internal" href="manual.html#mesh">mesh</a> has nodes, and each node is identified by its <a class="reference internal" href="manual.html#node-id">node id</a>.</p>
<p>If we use <em>first order basis functions</em> in the finite element
calculation, then a <em>site</em> is exactly the same as a <em>node</em>. In
micromagnetism, we almost always use first order basis functions
(because the requirement to resolve the exchange length forces us to
have a very fine mesh, and usually the motivation of using higher
order basis functions is to make the mesh coarser).</p>
<p>If we were to use <em>second</em> or <em>higher order base functions</em>, then we
have more sites than nodes. In a second order basis function
calculation, we identify sites by a tuple of <a class="reference internal" href="manual.html#node-id">node id</a>.</p>
</div>
<div class="section" id="si-object">
<h2><a class="toc-backref" href="manual.html#id131">3.6&nbsp;&nbsp;&nbsp;SI object</a></h2>
<p>We are using a special <tt class="docutils literal"><span class="pre">SI</span></tt> object to express physical entities (see
also <a class="reference internal" href="manual.html#si">SI</a>). Let us first clarify some terminology:</p>
<dl class="docutils" id="si-value">
<dt>physical entity</dt>
<dd>A pair (a,b) where a is a number (for example 10) and b is a product
of powers of dimensions (for example m^1s^-1) which we need to
express a physical quantity (in this example 10 m/s).</dd>
<dt>dimension</dt>
<dd>SI dimensions: meters (m), seconds (s), Ampere (A), kilogram (kg), Kelvin
(K), Mol (mol), candela (cd). These can be obtained using the <a class="reference internal" href="manual.html#units">units</a> attribute of the <a class="reference internal" href="manual.html#si">SI</a> object.</dd>
<dt>SI-value</dt>
<dd>for a given physical entity (a,b) where a is the numerical value and
b are the SI dimensions, this is just the numerical value a (and can be
obtained with the <a class="reference internal" href="manual.html#value">value</a> attribute of the <a class="reference internal" href="manual.html#si">SI</a> object).</dd>
<dt>Simulation Units</dt>
<dd>The dimensionless number that expressed an entity within the
simulation core. This is irrelevant to the user, except in highly
exotic situations.</dd>
</dl>
<p>There are several reasons for using SI objects:</p>
<ul class="simple">
<li>In the context of the micromagnetic simulations, the use of SI
objects avoids ambiguity as the user has to specify the right
dimensions and - where possible - the code will complain if these
are unexpected units (such as in the definition of material
parameters).</li>
<li>The specification of units is more important when the
micromagnetism is extended with other physical phenomena (moving
towards multi-physics calculations) for which, in principle, the
software cannot predict what units these will have.</li>
<li>Some convenience in having a choice of how to specify, for example,
magnetic fields (i.e. <tt class="docutils literal"><span class="pre">A/m</span></tt>, <tt class="docutils literal"><span class="pre">T/mu0</span></tt>, <tt class="docutils literal"><span class="pre">Oe</span></tt>). See also comments
in <a class="reference internal" href="manual.html#set-h-ext">set_H_ext</a>.</li>
</ul>
<div class="section" id="library-of-useful-si-constants">
<h3><a class="toc-backref" href="manual.html#id132">3.6.1&nbsp;&nbsp;&nbsp;Library of useful si constants</a></h3>
<p>The <tt class="docutils literal"><span class="pre">si</span></tt> name space in nmag provides the following constants:</p>
<pre class="literal-block">
&quot;&quot;&quot;Some useful SI constants&quot;&quot;&quot;
import math
from lib import SI
kilogram = SI(1.0,[&quot;kg&quot;,1])  #: The kilogram
meter = SI(1.0,[&quot;m&quot;,1])      #: The meter
metre = meter                #  alternative spelling
Ampere = SI(1.0,[&quot;A&quot;,1])     #: The Ampere
Kelvin = SI(1.0,[&quot;K&quot;,1])     #: The Kelvin
second = SI(1.0,[&quot;s&quot;,1])     #: The second
candela = SI(1.0,[&quot;cd&quot;,1])   #: The candela
mol = SI(1.0,[&quot;mol&quot;,1])      #: The mol

#specific units for magnetism

Newton = kilogram*meter/second**2          #: Newton
mu0 = SI(4.0e-7*math.pi, &quot;N/A^2&quot;)          #: vacuum permeability mu0
Tesla = kilogram/Ampere/second**2          #: Tesla
Gauss = 1e-4*kilogram/Ampere/second**2     #: Gauss
Oersted=Gauss/mu0 		           #: Oersted
Oe=Oersted          		           #: Oersted
gamma0 = SI(-2.2137286285040001e5, &quot;m/A s&quot;)#: gyromagnetic ratio gamma0

# units: degrees/nanosecond: Useful to specify the stopping_dm_dt
degrees_per_ns = SI(math.pi/180.0)/SI(1e-9, &quot;s&quot;)

# other units and constants
Joule = SI(&quot;J&quot;)
bohr_magneton = 9.2740094980e-24*Joule/Tesla # Bohr magneton
positron_charge = SI(1.6021765314e-19, &quot;C&quot;)
electron_charge =  -positron_charge
boltzmann_constant = SI(1.3806504e-23, &quot;J/K&quot;)

</pre>
<p>To express the magnetisation in A/m equivalent to the polaration of 1
Tesla, we could thus use:</p>
<pre class="literal-block">
from nmag import si

myM = 1.5*si.Tesla/si.mu0
</pre>
<p>The command reference for <a class="reference internal" href="manual.html#si">SI</a> provides some more details on the behaviour of SI objects.</p>
</div>
</div>
<div class="section" id="terms">
<h2><a class="toc-backref" href="manual.html#id133">3.7&nbsp;&nbsp;&nbsp;Terms</a></h2>
<div class="section" id="stage-step-iteration-time-etc">
<h3><a class="toc-backref" href="manual.html#id134">3.7.1&nbsp;&nbsp;&nbsp;Stage, Step, iteration, time, etc.</a></h3>
<p>We use the same terminology for hysteresis loops as <a class="reference external" href="http://math.nist.gov/oommf/">OOMMF</a> (stage, step, iteration, time) and extend this slightly:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">step:</th><td class="field-body"><p class="first">A step is the smallest possible change of the fields. This
corresponds (usually) to carrying out a time integration of the
system over a small amount of time <cite>dt</cite>. Step is an integer starting
from 0.</p>
<p>If we minimise energy (rather than computing the time development
exactly), then a step may not necessarily refer to progressing the
simulation through real time.</p>
</td>
</tr>
<tr class="field"><th class="field-name">iteration:</th><td class="field-body"><p class="first">Another term for Step (deprecated)</p>
</td>
</tr>
<tr class="field"><th class="field-name">stage:</th><td class="field-body"><p class="first">An integer to identify all the calculations carried out at one
(constant) applied magnetic field (as in <a class="reference external" href="http://math.nist.gov/oommf/">OOMMF</a>).</p>
</td>
</tr>
<tr class="field"><th class="field-name">time:</th><td class="field-body"><p class="first">The time that has been simulated (typically of the order of
pico- or nanoseconds).</p>
</td>
</tr>
<tr class="field"><th class="field-name">id:</th><td class="field-body"><p class="first">This is an integer (starting from 0) that uniquely identifies
saved data. <em>I. e.</em> whenever data is saved, this number will increase by
1. It is available in the <a class="reference internal" href="manual.html#h5-data-file">h5 data file</a> and the <a class="reference internal" href="manual.html#ndt">ndt</a> data files,
and thus allows
to match data in the ndt files with the corresponding (spatially resolved)
field data in the h5 file.</p>
</td>
</tr>
<tr class="field"><th class="field-name">stage_step:</th><td class="field-body"><p class="first">The number of steps since we have started the current stage.</p>
</td>
</tr>
<tr class="field"><th class="field-name">stage_time:</th><td class="field-body"><p class="first">The amount of time that has been simulated since we started this stage.</p>
</td>
</tr>
<tr class="field"><th class="field-name">real_time:</th><td class="field-body"><p class="first">The amount of real time the simulation has been running
(this is the [wall] execution time) and therefore typically of the
order of minutes to days.</p>
</td>
</tr>
<tr class="field"><th class="field-name">local_time:</th><td class="field-body"><p class="first">A string (human readable) with the local time. Useful in
data files to see when an entry was saved.</p>
</td>
</tr>
<tr class="field"><th class="field-name">unix_time:</th><td class="field-body"><p class="first last">The number of (non-leap) seconds since 1.1.1970 - this is
the same information as local_time but represented in a more computer
friendly way for computing differences.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="some-geek-talk-deciphered">
<h3><a class="toc-backref" href="manual.html#id135">3.7.2&nbsp;&nbsp;&nbsp;Some geek-talk deciphered</a></h3>
<dl class="docutils">
<dt>nmag uses some object orientation in the high-level user interface</dt>
<dd>presented here. There are a few special terms used in object
orientation that may not be familiar and of which we attempt to give
a very brief description:</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">method:</th><td class="field-body">A method is just a function that is associated to an object.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="solvers-and-tolerance-settings">
<h2><a class="toc-backref" href="manual.html#id136">3.8&nbsp;&nbsp;&nbsp;Solvers and tolerance settings</a></h2>
<p>There are a number of linear algebra solvers and one solver for
ordinary differential equations (ODEs) in nmag:</p>
<ol class="arabic">
<li><p class="first">two solvers for the calculation of the demagnetisation
field. Default values can be modified when creating the <a class="reference internal" href="manual.html#simulation">Simulation</a>
object (this user interface is not final -- if you really feel you
would like to change the defaults, please contact the <a class="reference internal" href="manual.html#nmag-team">nmag team</a> so
we can take your requirements into account in the next release).</p>
</li>
<li><p class="first">one solver for the system of algebraic equations that results from
the time integrator's implicit integration scheme.</p>
<p>(We need to document the default settings and how to modify this.)</p>
</li>
<li><p class="first">the ODE integrator.</p>
<p>Setting of the tolerances for the ODE integrator can be done with
<a class="reference internal" href="manual.html#set-params">set_params</a>. An example of this is shown in section <a class="reference internal" href="manual.html#example-tolerances">example
tolerances</a>.</p>
</li>
</ol>
<p>We expect that for most users, the tolerances of the ODE integrator
are most important (see <a class="reference internal" href="manual.html#example-tolerances">example tolerances</a>) as this greatly affects
the performance of the simulation.</p>
</div>
<div class="section" id="the-equation-of-motion-the-landau-lifshitz-gilbert-equation">
<h2><a class="toc-backref" href="manual.html#id137">3.9&nbsp;&nbsp;&nbsp;The equation of motion: the Landau-Lifshitz-Gilbert equation</a></h2>
<p>The magnetisation evolution, as computed by the <a class="reference internal" href="manual.html#advance-time">advance_time</a> or the
<a class="reference internal" href="manual.html#hysteresis">hysteresis</a> methods of the <tt class="docutils literal"><span class="pre">Simulation</span></tt> class, is determined by the
following equation of motion:</p>
<blockquote>
dM/dt = -llg_gamma_G * M x H + llg_damping * M x dM/dt,</blockquote>
<p>which is the Landau-Lifshitz-Gilbert equation (we often use the abbreviation
&quot;LLG&quot;), a vector equation, where <tt class="docutils literal"><span class="pre">M</span></tt>, <tt class="docutils literal"><span class="pre">H</span></tt> and <tt class="docutils literal"><span class="pre">dM/dt</span></tt> are three
dimensional vectors and <tt class="docutils literal"><span class="pre">x</span></tt> represent the vector product.
This equation is used to dermine the evolution of each component
of the magnetisation.
For example, if the system has two materials with name <tt class="docutils literal"><span class="pre">m1</span></tt> and <tt class="docutils literal"><span class="pre">m2</span></tt>,
then the magnetisation has two components <tt class="docutils literal"><span class="pre">M_m1</span></tt> and <tt class="docutils literal"><span class="pre">M_m2</span></tt> and
the equations:</p>
<blockquote>
<p>dM_m1/dt = -llg_gamma_G_m1 * M_m1 x H_m1 + llg_damping_m1 * M_m1 x dM_m1/dt,</p>
<p>dM_m2/dt = -llg_gamma_G_m2 * M_m2 x H_m2 + llg_damping_m2 * M_m2 x dM_m2/dt,</p>
</blockquote>
<p>determine the dynamics of <tt class="docutils literal"><span class="pre">M_m1</span></tt> and <tt class="docutils literal"><span class="pre">M_m2</span></tt>.
Here <tt class="docutils literal"><span class="pre">H_m1</span></tt> and <tt class="docutils literal"><span class="pre">H_m2</span></tt> are the effective fields relative to the two
components, while with <tt class="docutils literal"><span class="pre">dM_m1/dt</span></tt> and <tt class="docutils literal"><span class="pre">dM_m2/dt</span></tt> we denote the two time
derivatives. The constant <tt class="docutils literal"><span class="pre">llg_gamma_G_XX</span></tt> in front of the precession term
in the LLG equation is often called &quot;gyromagnetic ratio&quot;, even if usually,
in physics, the gyromagnetic ratio of a particle is the ratio between its
magnetic dipole moment and its angular momentum (and has units <tt class="docutils literal"><span class="pre">A</span> <span class="pre">s/kg</span></tt>).
It is then an improper nomenclature, but it occurs frequently in the
literature. The <tt class="docutils literal"><span class="pre">llg_damping_XX</span></tt> constant is called damping constant.
Notice that these two constants are specified on a per-material basis.
This means that each material has its own pair of constants
(<tt class="docutils literal"><span class="pre">llg_gamma_G_m1</span></tt>, <tt class="docutils literal"><span class="pre">llg_damping_m1</span></tt>) and
(<tt class="docutils literal"><span class="pre">llg_gamma_G_m2</span></tt>, <tt class="docutils literal"><span class="pre">llg_damping_m2</span></tt>).
The two constants are specified when the corresponding material is created
using the <a class="reference internal" href="manual.html#magmaterial">MagMaterial</a> class.</p>
</div>
</div>
<div class="section" id="command-reference">
<h1><a class="toc-backref" href="manual.html#id138">4&nbsp;&nbsp;&nbsp;Command reference</a></h1>
<div class="section" id="magmaterial">
<h2><a class="toc-backref" href="manual.html#id139">4.1&nbsp;&nbsp;&nbsp;MagMaterial</a></h2>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">MagMaterial</span></tt></dd>
<dt>Class constructor information:</dt>
<dd><pre class="first last literal-block">
(self,
name,
Ms=SI(0.86e6, &quot;A/m&quot;),
llg_damping=SI(0.5),
llg_gamma_G=SI(2.210173e5, &quot;m/A s&quot;),
exchange_coupling=SI(1.3e-11, &quot;J/m&quot;),
anisotropy=None,
anisotropy_order=None,
do_precession=True)
</pre>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>name</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the material. This will be used in the names of
material dependent fields and subfields. Must be alphanumeric
(i.e. contain only the characters 0-9_a-zA-Z)
Examples: <tt class="docutils literal"><span class="pre">'Py'</span></tt>, <tt class="docutils literal"><span class="pre">'Fe_1'</span></tt>,  <tt class="docutils literal"><span class="pre">'Fe_2'</span></tt></p>
</dd>
<dt><cite>Ms</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">The saturation magnetisation of the material (in Ampere per
meter).</p>
<p class="last">Example (and default (PermAlloy) value): <tt class="docutils literal"><span class="pre">SI(0.86e6,&quot;A/m&quot;)</span></tt></p>
</dd>
<dt><cite>llg_gamma_G</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">The constant in front of the precession term in the LLG equation:</p>
<blockquote>
<p>dM/dt = -llg_gamma_G * M x H + llg_damping * M x dM/dt</p>
</blockquote>
<p>It is often called gyromagnetic ratio, even if usually, in physics,
the gyromagnetic ratio of a particle is the ratio between its magnetic
dipole moment and its angular momentum (and has units A*s/kg).
It is then an improper nomenclature, but it occurs frequently in the
literature.</p>
<p class="last">Example (and default value): <tt class="docutils literal"><span class="pre">SI(2.210173e5,</span> <span class="pre">&quot;m/A</span> <span class="pre">s&quot;)</span></tt>.</p>
</dd>
<dt><cite>llg_damping</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">The damping parameter (often called alpha). Optimum damping
for 1.0, realistic values are of the order of 0.01. The
default value (as in OOMMF) is 0.5.</p>
<p class="last">Example (and default value): <tt class="docutils literal"><span class="pre">SI(0.5,&quot;&quot;)</span></tt></p>
</dd>
<dt><cite>exchange_coupling</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">The coupling strength for the exchange interaction in Joule
per meter.</p>
<p class="last">Example (and default value): <tt class="docutils literal"><span class="pre">SI(1.3e-11,</span> <span class="pre">&quot;J/m&quot;)</span></tt></p>
</dd>
<dt><cite>anisotropy</cite> <span class="classifier-delimiter">:</span> <span class="classifier">PredefinedAnisotropy Object  or function(vector) -&gt; SI Object</span></dt>
<dd><p class="first">Either a predefined anisotropy (such as returned by
<a class="reference internal" href="manual.html#uniaxial-anisotropy">uniaxial_anisotropy</a> or <a class="reference internal" href="manual.html#cubic-anisotropy">cubic_anisotropy</a>), or a custom
function (which must be polynomial in the components of <tt class="docutils literal"><span class="pre">m</span></tt>)
<tt class="docutils literal"><span class="pre">a(m)</span></tt> that computes anisotropy energy density
as a function of the (normalised) magnetisation direction <tt class="docutils literal"><span class="pre">m</span></tt>.</p>
<p>If you specify a custom anisotropy function, you also
need to pass the order of the polynomial in the <tt class="docutils literal"><span class="pre">anisotropy_order</span></tt>
parameter.</p>
<p class="last">Default value is <tt class="docutils literal"><span class="pre">None</span></tt>, that is, no anisotropy term
is used.</p>
</dd>
<dt><cite>anisotropy_order</cite> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first">If a custom polynomial anisotropy function <tt class="docutils literal"><span class="pre">a(m)</span></tt> is specified, the order
of the polynomial must be given in this parameter. This is not required
for pre-defined <a class="reference internal" href="manual.html#uniaxial-anisotropy">uniaxial_anisotropy</a> or <a class="reference internal" href="manual.html#cubic-anisotropy">cubic_anisotropy</a> anisotropy
functions.</p>
<p class="last">Default value is <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
</dd>
<dt><cite>do_precession</cite> <span class="classifier-delimiter">:</span> <span class="classifier">True or False</span></dt>
<dd><p class="first last">Boolean that can switch off the precessional term in the LLG
equation. This is useful to improve convergence speed
when studying metastable configurations.</p>
</dd>
<dt><cite>properties</cite>: list of strings (default: [&quot;magnetic&quot;,&quot;material&quot;])</dt>
<dd><p class="first">A list of additional properties this material will be associated with.
Normally, users do not have to change this, but it is used internally
when setting up discretized operators.</p>
<p class="last">Example (and default value): <tt class="docutils literal"><span class="pre">True</span></tt></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="section" id="uniaxial-anisotropy">
<h3><a class="toc-backref" href="manual.html#id140">4.1.1&nbsp;&nbsp;&nbsp;uniaxial_anisotropy</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">uniaxial_anisotropy</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(axis,</span> <span class="pre">K1,</span> <span class="pre">K2=0)</span></tt></dd>
</dl>
<p>Returns a predefined anisotropy modelling an uniaxial anisotropy energy density term:</p>
<pre class="literal-block">
E_anis = - K1 * &lt;axis, m&gt;^2 - K2 * &lt;axis, m&gt;^4
</pre>
<p>(where <cite>m</cite> is the (normalised) magnetization.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>axis</cite> <span class="classifier-delimiter">:</span> <span class="classifier">vector (=list)</span></dt>
<dd><p class="first last">Easy axis (or hard axis, if K1 &lt; 0; will be normalised).</p>
</dd>
<dt><cite>K1</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first last">Second-order phenomenological anisotropy constant (as used in the equation above).</p>
</dd>
<dt><cite>K2</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">Fourth-order phenomenological anisotropy constant (as used in the equation above).</p>
<p class="last">Default value is <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cubic-anisotropy">
<h3><a class="toc-backref" href="manual.html#id141">4.1.2&nbsp;&nbsp;&nbsp;cubic_anisotropy</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">cubic_anisotropy</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(axis1,</span> <span class="pre">axis2,</span> <span class="pre">K1,</span> <span class="pre">K2=0,</span> <span class="pre">K3=0)</span></tt></dd>
</dl>
<p>Returns a predefined anisotropy modelling a cubic anisotropy energy density term:</p>
<pre class="literal-block">
E_anis = K1 * (&lt;axis1,m&gt;^2 &lt;axis2,m&gt;^2 + &lt;axis1,m&gt;^2 &lt;axis3,m&gt;^2 + &lt;axis2,m&gt;^2 &lt;axis3,m&gt;^2)
       + K2 * (&lt;axis1,m&gt;^2 &lt;axis2,m&gt;^2 &lt;axis3,m&gt;^2)
       + K3 * (&lt;axis1,m&gt;^4 &lt;axis2,m&gt;^4 + &lt;axis1,m&gt;^4 &lt;axis3,m&gt;^4 + &lt;axis2,m&gt;^4 &lt;axis3,m&gt;^4)
</pre>
<p>(where <cite>m</cite> is the (normalised) magnetisation.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>axis1</cite> <span class="classifier-delimiter">:</span> <span class="classifier">vector (=list)</span></dt>
<dd><p class="first last">First cubic anisotropy axis (will be normalised).</p>
</dd>
<dt><cite>axis2</cite> <span class="classifier-delimiter">:</span> <span class="classifier">vector (=list)</span></dt>
<dd><p class="first last">Second cubic anisotropy axis (will be orthonormalised with regards to <cite>axis1</cite>).</p>
</dd>
<dt><cite>K1</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first last">Fourth-order phenomenological anisotropy constant (as used in the equation above).</p>
</dd>
<dt><cite>K2</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">Sixth-order phenomenological anisotropy constant (as used in the equation above).</p>
<p class="last">Default value is <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
</dd>
<dt><cite>K3</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">Eigth-order phenomenological anisotropy constant (as used in the equation above).</p>
<p class="last">Default value is <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="simulation">
<h2><a class="toc-backref" href="manual.html#id142">4.2&nbsp;&nbsp;&nbsp;Simulation</a></h2>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation</span></tt></dd>
<dt>Class constructor information:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">name=None,</span> <span class="pre">phi_BEM=None,</span> <span class="pre">periodic_bc=None,</span> <span class="pre">do_demag=True,</span> <span class="pre">do_anisotropy_jacobian=False,</span> <span class="pre">temperature=None,</span> <span class="pre">thermal_delta_t=None,</span> <span class="pre">user_seed_T=0,</span> <span class="pre">timestepper_max_order=2,</span> <span class="pre">timestepper_krylov_max=300,</span> <span class="pre">ksp_tolerances={},</span> <span class="pre">adjust_tolerances=False,</span> <span class="pre">use_pvode=True,</span> <span class="pre">lam_debugfile=None)</span></tt></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>name</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">Name of the simulation object; this is used e.g. for prefixing
filenames created by nmag.</p>
<p class="last">Default value is the name of the current script (sans extension).</p>
</dd>
<dt><cite>do_demag</cite> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Pass <tt class="docutils literal"><span class="pre">False</span></tt> to disable the demagnetisation field.</p>
</dd>
<dt><cite>do_anisotropy_jacobian</cite> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">Pass <tt class="docutils literal"><span class="pre">True</span></tt> to enable the inclusion of derivatives from the
anisotropy into the Jacobian. (Complicated anisotropy terms may blow
up memory requirements for the Jacobian.)</p>
<p class="last">Default value is <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
</dd>
<dt><cite>temperature</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">Simulated temperature (unless equal to None, stochastic thermal
fluctuations will be enabled).</p>
<p class="last">Currently not supported (since July 2008)</p>
</dd>
<dt><cite>thermal_delta_t</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">Time step to use when stochastic thermal fluctuations are enabled.</p>
<p class="last">Currently not supported (since July 2008)</p>
</dd>
<dt><cite>timestepper_max_order</cite> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first">Maximum order for the time integrator (we use the BDF method).</p>
<p class="last">Default value is 2.</p>
</dd>
<dt><cite>timestepper_krylov_max</cite> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first">Maximum dimension of the Krylov subspace to be used in the time
integrator.</p>
<p class="last">Default (recommended) value is 300.</p>
</dd>
<dt><cite>ksp_tolerances</cite>: dictionary</dt>
<dd><p class="first">Keys to this dictionary are:
DBC.rtol DBC.atol DBC.dtol DBC.maxits
NBC.rtol NBC.atol NBC.dtol NBC.maxits</p>
<p class="last">Values are the petsc KSP-solver tolerances for the Dirichlet and
von Neumann Laplace solvers used internally to compute the magnetic
scalar potential from magnetic charge density.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="section" id="advance-time">
<h3><a class="toc-backref" href="manual.html#id143">4.2.1&nbsp;&nbsp;&nbsp;advance_time</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.advance_time</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">target_time,</span> <span class="pre">max_it=-1,</span> <span class="pre">exact_tstop=None)</span></tt></dd>
</dl>
<p>This method carries out the time integration of the
Landau-Lifshitz and Gilbert equation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>target_time</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first last">The simulation will run until this time is reached. If the target_time is
zero, this will simply update all fields.</p>
</dd>
<dt><cite>max_it</cite> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The maximum number of iterations (steps) to be carried out
in this time integration call. If set to <tt class="docutils literal"><span class="pre">-1</span></tt>, then there is no limit.</p>
</dd>
<dt><cite>exact_tstop</cite> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">When exact_tstop is True, the time integration is advanced exactly
up to the given target_time. When False, the time integration ends
&quot;close&quot; to the target_time. The latter option can result in better
performance, since the time integrator is free to choose time
steps which are as wide as possible. When exact_tstop is not
given, or is None, the default value for this option will be used.
The default value can be set using the method set_params, which
should hence be used to control the behaviour of the hysteresis
and relax methods.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="get-subfield">
<h3><a class="toc-backref" href="manual.html#id144">4.2.2&nbsp;&nbsp;&nbsp;get_subfield</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.get_subfield</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">subfieldname,</span> <span class="pre">units=None)</span></tt></dd>
</dl>
<p>Given a subfieldname, this will return a numpy-array
containing all the data (one element for each site).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield, for example <tt class="docutils literal"><span class="pre">m_Py</span></tt> or <tt class="docutils literal"><span class="pre">H_demag</span></tt>.</p>
</dd>
</dl>
<p><cite>units</cite> : SI object</p>
<blockquote>
<p>Optional parameter. If it is provided, then the entity is
expressed in these units. If it is not provided, then the
correct SI dimensions for this subfield are looked up, and
<a class="reference internal" href="manual.html#si-value">SI-value</a>s are returned.</p>
<p>If you would like to see simulation units in the output,
then use <tt class="docutils literal"><span class="pre">SI(1)</span></tt>.</p>
<p>In short: if you omit the second parameter, you will
obtain SI values.</p>
</blockquote>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><cite>data</cite> : numpy-array</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="get-subfield-positions">
<h3><a class="toc-backref" href="manual.html#id145">4.2.3&nbsp;&nbsp;&nbsp;get_subfield_positions</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.get_subfield_positions</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">subfieldname,</span> <span class="pre">pos_units=SI(1,['m',1.0]))</span></tt></dd>
</dl>
<p>This function provides the positions of the sites for data
obtained with <a class="reference internal" href="manual.html#get-subfield">get_subfield</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield, for example <tt class="docutils literal"><span class="pre">m_Py</span></tt> or <tt class="docutils literal"><span class="pre">H_demag</span></tt>.</p>
</dd>
<dt><cite>pos_units</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first">Specifies the physical dimension in which positions are to be expressed.
Default is <tt class="docutils literal"><span class="pre">SI(1,'m')</span></tt>, which means to return site positions in meters.</p>
<p class="last">To obtain site positions in nanometers, use <tt class="docutils literal"><span class="pre">SI(1e-9,'m')</span></tt>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>pos</cite> <span class="classifier-delimiter">:</span> <span class="classifier">numpy-array</span></dt>
<dd><p class="first last">Array containing a position (i.e. 3 floating point
numbers) for every site.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="get-subfield-sites">
<h3><a class="toc-backref" href="manual.html#id146">4.2.4&nbsp;&nbsp;&nbsp;get_subfield_sites</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.get_subfield_sites</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">subfieldname)</span></tt></dd>
</dl>
<p>This function provides the node indices of the sites for data
obtained with <a class="reference internal" href="manual.html#get-subfield">get_subfield</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield, for example <tt class="docutils literal"><span class="pre">m_Py</span></tt> or <tt class="docutils literal"><span class="pre">H_demag</span></tt>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>data</cite> <span class="classifier-delimiter">:</span> <span class="classifier">numpy-array</span></dt>
<dd><p class="first last">Array containing a list of integers for every site. The
integers within each list are node indices of the
mesh. There will be only one integer per site in first
order basis function calculations (which is the usual case
in micromagnetics)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="get-subfield-average">
<h3><a class="toc-backref" href="manual.html#id147">4.2.5&nbsp;&nbsp;&nbsp;get_subfield_average</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.get_subfield_average</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">field_name,</span> <span class="pre">subfield_name=None)</span></tt></dd>
</dl>
<p>Returns the average of the subfield <tt class="docutils literal"><span class="pre">subfield_name</span></tt> of
the field <tt class="docutils literal"><span class="pre">fieldname</span></tt> as an SI object (or a list of [list
of [list of [...]]] SI objects in the field is a vector, 2nd rank tensor etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>field_name</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">name of the field</p>
</dd>
<dt><cite>subfield_name</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">name of the subfield</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>See also <a class="reference internal" href="manual.html#get-subfield-average-siv">get_subfield_average_siv</a>.</p>
</div>
<div class="section" id="get-subfield-average-siv">
<h3><a class="toc-backref" href="manual.html#id148">4.2.6&nbsp;&nbsp;&nbsp;get_subfield_average_siv</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.get_subfield_average_siv</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">field_name,</span> <span class="pre">subfield_name=None)</span></tt></dd>
</dl>
<p>Returns the average of the subfield <tt class="docutils literal"><span class="pre">subfield_name</span></tt> of
the field <tt class="docutils literal"><span class="pre">fieldname</span></tt> as a single floating point number (or
a list if it is a vector, or a list of list for matrices etc).</p>
<p>The number is expressed in SI units (hence the suffix _siv
which stands for si value).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>field_name</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">name of the field</p>
</dd>
<dt><cite>subfield_name</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">name of the subfield</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre class="literal-block">
ave_M = sim.get_subfield_average_siv(&quot;M&quot;,&quot;Py&quot;)
</pre>
<p>will obtain the average magnetisation of the subfield M_Py of field M, for example
<tt class="docutils literal"><span class="pre">ave_M</span> <span class="pre">=</span> <span class="pre">[100000.00,0.,0.]</span></tt></p>
</div>
<div class="section" id="probe-subfield">
<h3><a class="toc-backref" href="manual.html#id149">4.2.7&nbsp;&nbsp;&nbsp;probe_subfield</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.probe_subfield</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">subfieldname,</span> <span class="pre">pos,</span> <span class="pre">unit=None)</span></tt></dd>
</dl>
<p>for a given subfield name and position (SI object), return data (as SI object).</p>
<p>Note that <tt class="docutils literal"><span class="pre">get_subfield_siv</span></tt> has the same functionality but
takes a list of floats for the position (instead of an SI
object) and returns (a list of) float(s) which is just the
<a class="reference internal" href="manual.html#si-value">SI-value</a> of that physical entity.</p>
<p>If the subfield is not defined at that part of space, <tt class="docutils literal"><span class="pre">None</span></tt>
is returned.</p>
<p>If the subfield does generally not exist, then a <tt class="docutils literal"><span class="pre">KeyError</span></tt> exception
is thrown.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield</p>
</dd>
<dt><cite>pos</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI object</span></dt>
<dd><p class="first last">The position for which the data should be returned</p>
</dd>
<dt><cite>unit</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI object</span></dt>
<dd><p class="first">If you request the value for a subfield of a field that is
part of nmag (i.e. fields M, m, H_demag, etc), then you do
not need to provide this object.</p>
<p>If you request data of any other (multi-physics) fields,
then this function needs to know the SI dimensions of that
field (for the correct conversion from simulation units to
SI units).</p>
<p class="last">If incorrect dimensions are provided, the returned data is
likely to be wrongly scaled.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>data</cite> <span class="classifier-delimiter">:</span> <span class="classifier">[list [of list[ of ...]]] SI objects</span></dt>
<dd><p class="first last">The returned object is an SI object for scalar subfields,
a list of SI objects for vector fields, a list of list of
SI objects for (rank 2) tensor fields, etc.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="probe-subfield-siv">
<h3><a class="toc-backref" href="manual.html#id150">4.2.8&nbsp;&nbsp;&nbsp;probe_subfield_siv</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.probe_subfield_siv</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">subfieldname,</span> <span class="pre">pos,</span> <span class="pre">unit=None)</span></tt></dd>
</dl>
<p>The same behaviour as <tt class="docutils literal"><span class="pre">get_subfield</span></tt> but the <tt class="docutils literal"><span class="pre">pos</span></tt> and return
data are <a class="reference internal" href="manual.html#si-value">SI-value</a>s (not SI objects).</p>
<p>If the subfield is not defined at that part of space, <tt class="docutils literal"><span class="pre">None</span></tt>
is returned.</p>
<p>If the subfield does generally not exist, then a <tt class="docutils literal"><span class="pre">KeyError</span></tt>
exception is thrown.</p>
<p>The input (position) and returned data is expressed in SI
units but of type float.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield</p>
</dd>
<dt><cite>pos</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of floats</span></dt>
<dd><p class="first last">The position for which the data should be returned (in meters)</p>
</dd>
<dt><cite>unit</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI object</span></dt>
<dd><p class="first">If you request the value for a subfield of a field that is part of nmag (i.e.
fields M, m, H_demag, etc), then you do not need to provide this object.</p>
<p>If you request data of any other (multi-physics) fields,
then this function needs to know the SI dimensions of that
field (for the correct conversion from simulation units to
SI units).</p>
<p class="last">If incorrect dimensions are provided, the returned data is
likely to be wrongly scaled.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>data</cite> <span class="classifier-delimiter">:</span> <span class="classifier">[list [of list[ of ...]]] float</span></dt>
<dd><p class="first last">The returned object is a float for scalar subfields,
a list of floats vector fields, a list of list of
floats for (rank 2) tensor fields, etc.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="probe-h-demag-siv">
<h3><a class="toc-backref" href="manual.html#id151">4.2.9&nbsp;&nbsp;&nbsp;probe_H_demag_siv</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.probe_H_demag_siv</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">pos,</span> <span class="pre">pos_unit=SI(1,['m',1.0]),</span> <span class="pre">epsilon=9.9999999999999995e-08)</span></tt></dd>
</dl>
<p>Compute the demag field at given position. Works inside
and outside of magnetic materials. Note that most fields can only
be probed where they are defined. This function computes the demag
field at the given position on the fly, based on the boundary element
method.</p>
<p>Note that for large distances away from the magnetic material, we expect
this not to be very accurate. Furthermore, there is an awkward technical
problem whenever the probe point lies in-plane with any of the surface
triangles. These awkward limitations are strongly linked to the method
used to compute the scalar potential internally and are intrinsically
difficult to avoid. They will go away in the future when potential
computations will be performed with Hlib.</p>
<p>Also, this function should (at present) not be used to probe the
demag field for periodic structures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>pos</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of floats</span></dt>
<dd><p class="first last">The SI numbers described the position in meters. A command like
<tt class="docutils literal"><span class="pre">probe_H_demag_siv([0,0,1e-9])</span></tt> would thus probe the demag field one
nanometer away (in z-direction) from the origin.</p>
</dd>
<dt><cite>pos_unit</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI object</span></dt>
<dd><p class="first last">Optional argument that defaults to SI(&quot;m&quot;). The full SI position is
computed as pos*pos_unit. The above example could therefore be written as
<tt class="docutils literal"><span class="pre">probe_H_demag_siv([0,0,1],pos_unit=SI(1e-9,&quot;m&quot;))</span></tt>.</p>
</dd>
<dt><cite>epsilon</cite> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">This parameter is used internally to compute the demag
field via central differences from the magnetic
potential if the observer point is in the exterior (&quot;vacuum&quot;)
region. It is the distance between the two points at
which each of the field components is being computed
(because the field is the negative gradient of the
potential). The default value of 1e-7 should be sensible
if normal simulation units are used (i.e. the mesh was
provided with coordinates in the range 1-1000).
Typically, this parameter should be ignored. Note that this number is
measured in simulation units.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of floats containing the demag field in SI units (i.e. A/m) at the
specified position.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="hysteresis">
<h3><a class="toc-backref" href="manual.html#id152">4.2.10&nbsp;&nbsp;&nbsp;hysteresis</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.hysteresis</span></tt></dd>
<dt>Arguments:</dt>
<dd><pre class="first last literal-block">
(
self,
H_ext_list,
save=[('averages', 'fields', at('stage_end'))],
do=[],
convergence_check=every(5, 'step')
)
</pre>
</dd>
</dl>
<p>This method executes a simulation where the applied field
is set in sequence to the values specified in <tt class="docutils literal"><span class="pre">H_ext_list</span></tt>.
The time integration proceeds with the same applied field
until convergence is reached. At this point the field is changed
to the next one in <tt class="docutils literal"><span class="pre">H_ext_list</span></tt> and the method <tt class="docutils literal"><span class="pre">reinitialise()</span></tt>
is called to proceed with the simulation.
The user can specify when to save data using the optional
argument <tt class="docutils literal"><span class="pre">save</span></tt>.</p>
<p>This allows to carry out hysteresis loop computations
and write the results to disk.</p>
<p>Technically we say that this function performs a multi-stage
simulation. In our terminology, a stage is a part of the simulation
where the field does not change. Therefore, every value
for the applied field specified in <tt class="docutils literal"><span class="pre">H_ext_list</span></tt> corresponds
to a different stage. Stages are numbered starting from 1,
which corresponds to <tt class="docutils literal"><span class="pre">H_ext_list[0]</span></tt>. In general during
stage number <tt class="docutils literal"><span class="pre">i</span></tt> the applied field is <tt class="docutils literal"><span class="pre">H_ext_list[i-1]</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>H_ext_list</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of values for the applied field</span></dt>
<dd><p class="first last">It is something like <tt class="docutils literal"><span class="pre">[H1,</span> <span class="pre">H2,</span> <span class="pre">H3,</span> <span class="pre">...]</span></tt>, where
<tt class="docutils literal"><span class="pre">Hi</span></tt> is the triple of components of the applied field,
i.e. SI objects having units of &quot;A/m&quot;;</p>
</dd>
<dt><cite>save</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of pairs <tt class="docutils literal"><span class="pre">(thing_to_save,</span> <span class="pre">when)</span></tt></span></dt>
<dd><p class="first"><tt class="docutils literal"><span class="pre">thing_to_save</span></tt> is either a string or a function provided
by the user and <tt class="docutils literal"><span class="pre">when</span></tt> is an instance of the class <tt class="docutils literal"><span class="pre">When</span></tt>,
i.e. an object which contains the specification of when
&quot;the thing&quot; has to be saved.</p>
<p>Possible string values for <tt class="docutils literal"><span class="pre">thing_to_save</span></tt> are:</p>
<blockquote class="last">
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">&quot;averages&quot;</span></tt>: to save the averages of all the fields
together with other information (such as the stage number,
the time reached, etc.). This is done calling the method
<tt class="docutils literal"><span class="pre">save_data()</span></tt>. Refer to its documentation
for further details;</li>
<li><tt class="docutils literal"><span class="pre">&quot;fields&quot;</span></tt>: to save all the fields. The method
<tt class="docutils literal"><span class="pre">save_data(fields='all')</span></tt> is called for this purpose;</li>
<li><tt class="docutils literal"><span class="pre">&quot;restart&quot;</span></tt>: to save the current magnetisation configuration
and all the information needed to restart the simulation.</li>
</ul>
</blockquote>
</dd>
<dt><cite>do</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of pairs <tt class="docutils literal"><span class="pre">(thing_to_do,</span> <span class="pre">when)</span></tt></span></dt>
<dd><p class="first">is very similar to the <tt class="docutils literal"><span class="pre">save</span></tt> argument, but is usually used
for other purposes.
<tt class="docutils literal"><span class="pre">thing_to_do</span></tt> is either a string or a function provided
by the user and <tt class="docutils literal"><span class="pre">when</span></tt> is an instance of the class <tt class="docutils literal"><span class="pre">When</span></tt>.</p>
<p>Possible string values for <tt class="docutils literal"><span class="pre">thing_to_do</span></tt> are:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">&quot;next_stage&quot;</span></tt>: induces the hysteresis method to advance
to the next stage;</li>
<li><tt class="docutils literal"><span class="pre">&quot;exit&quot;</span></tt>: induces the hysteresis method to exit,
even if the hysteresis computation has not still reached
its end.</li>
</ul>
</blockquote>
<p>The user can provide his own function to save data.
For example, the following three lines:</p>
<pre class="literal-block">
def my_fun(sim):
  sim.save_data()
sim.hysteresis(..., save=[(my_fun, every(10, 'step'))])
</pre>
<p>are equivalent to:</p>
<pre class="literal-block">
sim.hysteresis(..., save=[('averages', every(10, 'step'))])
</pre>
<p>To specify when something has to be saved the module <tt class="docutils literal"><span class="pre">when</span></tt>
is used. The functions <tt class="docutils literal"><span class="pre">at</span></tt> and <tt class="docutils literal"><span class="pre">every</span></tt>, provided by
this module, can refer to the following time variables:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">step</span></tt>: the step number from the beginning of the simulation;</li>
<li><tt class="docutils literal"><span class="pre">stage_step</span></tt>: the step number from the beginning of
the current stage;</li>
<li><tt class="docutils literal"><span class="pre">time</span></tt>: the simulation time passed from the beginning
of the simulation (measured in <a class="reference internal" href="manual.html#si">SI</a> objects);</li>
<li><tt class="docutils literal"><span class="pre">stage_time</span></tt>: the simulation time passed from the beginning
of the current stage;</li>
<li><tt class="docutils literal"><span class="pre">stage</span></tt>: the number of the current stage;</li>
<li><tt class="docutils literal"><span class="pre">convergence</span></tt>: a boolean value which is <tt class="docutils literal"><span class="pre">True</span></tt>
if the convergence criterion is satisfied.
Use in this way <tt class="docutils literal"><span class="pre">at('convergence')</span></tt></li>
</ul>
</blockquote>
<p>Remember that you can combine time specifications using
the operator | (or) and &amp; (and):</p>
<pre class="literal-block">
every(2, 'stage') &amp; at('convergence') --&gt; only at convergence
                                          of odd stages
every(10, 'step') | at('convergence') --&gt; at convergence
                                          and every 10 steps.
</pre>
<p>Some usage examples:</p>
<pre class="literal-block">
# Save fields (which implicitly will save the averages as well)
# when the magnetisation stops changing for each applied field
# (i.e. save at convergence):
sim.hysteresis(..., save=[('fields', at('convergence'))])

# Averages will be saved every 10 steps, fields (and
# implicitely averages) will be saved at convergence.
sim.hysteresis(..., save=[('averages', every(10, 'step')),
                          ('fields', at('convergence'))])

# Each stage will not last more than 10 ps, even
# if the magnetisation is not relaxed yet.
sim.hysteresis(..., do=[('next_stage', at('stage_time', SI(1e-11, &quot;s&quot;)))])

# Exit hysteresis loop simulation if the total number of
# steps exceeds 1e6, save fields every 100 steps and at
# convergence before that:
sim.hysteresis(..., save=[('fields', every(100, 'step') |
                          at('convergence'))],
                     do =[('exit', at(1e6, 'step'))])

# Save averages every 0.1 ns (useful for fourier transform)
# leave after 20 ns (using the related relax_ command)
sim.relax(save=[('averages', every('time', SI(1e-10, 's')))],
          do  =[('exit', at('time', SI(20e-9, 's')))])

# Save averages every nanosecond, and fields every 100 ns.
sim.relax(save=[('averages',every('time', SI(1e-9, 's'))),
                ('fields',  every('time', SI(100e-9,'s')))])

# Save averages every nanosecond, and fields every 100 ns,
# save restart file every 1000 steps
sim.relax(save=[('averages',every('time', SI(1e-9, 's'))),
                ('fields',  every('time', SI(100e-9, 's'))),
                ('restart', every(1000, 'step'))])
</pre>
<p class="last">If <tt class="docutils literal"><span class="pre">save</span></tt> is not given, averages and fields will be saved whenever
the stage ends (this is the default behaviour).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="load-mesh">
<h3><a class="toc-backref" href="manual.html#id153">4.2.11&nbsp;&nbsp;&nbsp;load_mesh</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.load_mesh</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">filename,</span> <span class="pre">region_names_and_mag_mats,</span> <span class="pre">unit_length,</span> <span class="pre">do_reorder=False,</span> <span class="pre">manual_distribution=None)</span></tt></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>filename</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The file that contains the mesh in nmesh format (ascii or hdf5)</p>
</dd>
<dt><cite>region_names_and_mag_mats</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of 2-tuples</span></dt>
<dd><p class="first">A list of 2-tuples containing the region names and the
magnetic materials associated to each region. For example,
having two spheres (called <tt class="docutils literal"><span class="pre">region_A</span></tt> and <tt class="docutils literal"><span class="pre">region</span> <span class="pre">B</span></tt>)
with materials A and B in the mesh, the argument would be
[(&quot;region_A&quot;, A),(&quot;region_B&quot;,B)] where
A and B must have been defined previously as <tt class="docutils literal"><span class="pre">nmag.MagMaterial</span></tt>.</p>
<p class="last">Having two Materials X and Y both defined in region A (as in a magnetic
two-component alloy), we would use [(&quot;region_A&quot;,[X,Y])].</p>
</dd>
<dt><cite>unit_length</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI object</span></dt>
<dd><p class="first last">The SI object defines what a length of 1.0 in the mesh file
corresponds to in reality. If the length 1.0 in the mesh corresponds to
a nanometer, then this SI object would be given as SI(1e-9,&quot;m&quot;)</p>
</dd>
<dt><cite>do_reorder</cite> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If set to True, metis will be called to reorder the mesh
(aiming to bring together node ids that correspond to node
locations that are spatially close to each other). If this
doesn't make sense to you, you should probably leave the
default (which is <tt class="docutils literal"><span class="pre">False</span></tt>).</p>
<p>Generally, we recommend to order a mesh using <tt class="docutils literal"><span class="pre">nmeshpp</span>
<span class="pre">--reordernodes</span> <span class="pre">mesh.nmesh</span> <span class="pre">orderedmesh.nmesh</span></tt>, and <em>not to
use</em> this reodering option here, if you think you need to
order it.</p>
<p>If you know nmag really well (you are probably a member of
the core team) then read on.</p>
<p>The use of <tt class="docutils literal"><span class="pre">do_reorder</span></tt> <em>can</em> make sense if either your
mesh is not ordered already, or you provide a
<tt class="docutils literal"><span class="pre">manual_distribution</span></tt> of nodes.</p>
<p class="last">The use of <tt class="docutils literal"><span class="pre">do_reorder</span></tt> makes no sense, if you run on more
than one CPU and leave the distribution of the nodes to
nmag (i.e. you use the default
<tt class="docutils literal"><span class="pre">manual_distribution==None</span></tt>).</p>
</dd>
<dt><cite>manual_distribution</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of integers</span></dt>
<dd><p class="first last">This list (if provided) describes how many nodes are to be
put onto which CPU under MPI-parallelized execution.  If
this is <tt class="docutils literal"><span class="pre">None</span></tt> (i.e. the default), then the distribution
is done automatically (through metis). This parameter
should generally not be used (unless you really know what
you are doing).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><cite>mesh</cite> : mesh object</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="load-m-from-h5file">
<h3><a class="toc-backref" href="manual.html#id154">4.2.12&nbsp;&nbsp;&nbsp;load_m_from_h5file</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.load_m_from_h5file</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">file_name)</span></tt></dd>
</dl>
<p>Use the magnetisation stored in <tt class="docutils literal"><span class="pre">file_name</span></tt> to set the magnetisation of
the simulation. (If more than one magnetisation configurations have been saved
in the file, it will load the first one.)</p>
<p>This can be used to retrieve the magnetisation saved in a
restart file, and to set the current magnetisation of the
simulation object to this magnetisation.</p>
<p>This restart file could have been written explicitely (using
the <a class="reference internal" href="manual.html#save-restart-file">save_restart_file</a> method), or implicitly by providing
a 'restart' action to the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a>/<a class="reference internal" href="manual.html#relax">relax</a> commands.</p>
<p>To simply continue a hysteresis/relax simulation using the
<tt class="docutils literal"><span class="pre">--restart</span></tt> option, there is no need to use this
function. It should only be used if lower-level manipulation
is required (see for example <a class="reference internal" href="manual.html#current-driven-motion-of-a-vortex-in-a-thin-film">Current-driven motion of a
vortex in a thin film</a>).</p>
</div>
<div class="section" id="save-restart-file">
<h3><a class="toc-backref" href="manual.html#id155">4.2.13&nbsp;&nbsp;&nbsp;save_restart_file</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.save_restart_file</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">filename=None,</span> <span class="pre">fieldnames=['m'],</span> <span class="pre">all=False)</span></tt></dd>
</dl>
<p>Save current magnetic configuration into file that can be used for
restarting.</p>
<p>This function saves the current magnetisation, the time and
all what is needed to restart the simulation exactly from
the point it was invoked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><cite>filename</cite> : string</p>
<blockquote>
<p>The file into which the restart file is written. Defaults
RUNID_restart.h5.</p>
</blockquote>
<dl class="last docutils">
<dt><cite>fieldnames</cite>: list</dt>
<dd><p class="first last">The fieldnames to be saved. Defaults to ['m']</p>
</dd>
<dt><cite>all</cite>:bool</dt>
<dd><p class="first last">If true, then all fields will be saved.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>This function is used by the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> and <a class="reference internal" href="manual.html#relax">relax</a> commands
to save a magnetic configuration from which a run can be
continued (using --restart).</p>
<p>Example:</p>
<blockquote>
<p>A common usecase for this function maybe to write the
magnetic configuration that comes from a relaxation process
to a file. And to load that configuration as the initial
configuration for a subsequent (series of) simulation(s).</p>
<p>In this case, one may want to provide the filename explicitely.
For example:</p>
<pre class="literal-block">
sim.save_restart_file(filename=&quot;relaxed_configuration.h5&quot;)
</pre>
<p>One can then use the <a class="reference internal" href="manual.html#load-m-from-h5file">load_m_from_h5file</a>, to read this file
<tt class="docutils literal"><span class="pre">relaxed_configuration.h5</span></tt> and to use it to set the
magnetisation up in the subsequent simulation.</p>
</blockquote>
</div>
<div class="section" id="relax">
<h3><a class="toc-backref" href="manual.html#id156">4.2.14&nbsp;&nbsp;&nbsp;relax</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.relax</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">H_applied=None,</span> <span class="pre">save=[('averages',</span> <span class="pre">'fields',</span> <span class="pre">at(stage_end,</span> <span class="pre">True))],</span> <span class="pre">do=[],</span> <span class="pre">convergence_check=every(5,</span> <span class="pre">'step'))</span></tt></dd>
</dl>
<p>This method carries out the time integration of the LLG until
the system reaches a (metastable) equilibrium.
Internally, this uses the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> loop command.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>H_applied</cite> <span class="classifier-delimiter">:</span> <span class="classifier">list of SI objects</span></dt>
<dd><p class="first">For a 3-d simulation, the SI-objects Hx, Hy and Hz would be
specified as <tt class="docutils literal"><span class="pre">[Hx,Hy,Hz]</span></tt>.</p>
<p class="last">Default value is <tt class="docutils literal"><span class="pre">None</span></tt>, resulting in the currently applied external
field <tt class="docutils literal"><span class="pre">H_ext</span></tt> being used.</p>
</dd>
<dt><cite>save</cite> <span class="classifier-delimiter">:</span> <span class="classifier">Schedule object</span></dt>
<dd><p class="first last">Allows to define what data to save at what events.
See documentation on the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> method and
on the <tt class="docutils literal"><span class="pre">Schedule</span></tt> object.</p>
</dd>
</dl>
<p class="last"><cite>convergence_check</cite> : every object The default value
(<tt class="docutils literal"><span class="pre">every(5,'step')</span></tt> specifies that we ask the time
integrator to carry out 5 steps before we check for
convergence. If in doubt, ignore this feature.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="save-data">
<h3><a class="toc-backref" href="manual.html#id157">4.2.15&nbsp;&nbsp;&nbsp;save_data</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.save_data</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">fields=None,</span> <span class="pre">avoid_same_step=False)</span></tt></dd>
</dl>
<p>Save the <em>averages</em> of all defined (subfields) into a ascii
data file. The filename is composed of the simulation name
and the extension <tt class="docutils literal"><span class="pre">_dat.ndt</span></tt>. The
extension <tt class="docutils literal"><span class="pre">ndt</span></tt> stands for Nmag Data Table (analog to OOMMFs
<tt class="docutils literal"><span class="pre">.odt</span></tt> extension for this kind of data file.</p>
<p>If <tt class="docutils literal"><span class="pre">fields</span></tt> is provided, then it will also save the spatially resolved fields
to a file with extensions <tt class="docutils literal"><span class="pre">_dat.h5</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><cite>fields</cite> : None, 'all' or list of fieldnames</p>
<blockquote>
<p>If None, then only spatially averaged data is saved into <tt class="docutils literal"><span class="pre">*ndt</span></tt> and <tt class="docutils literal"><span class="pre">*h5</span></tt> files.</p>
<p>If <tt class="docutils literal"><span class="pre">all</span></tt> (i.e. the string containing 'all'), then all fields are saved.</p>
<p>If a list of fieldnames is given, then only the selected
fieldnames will be saved (i.e. ['m','H_demag']).</p>
</blockquote>
<p><cite>avoid_same_step</cite> : bool</p>
<blockquote class="last">
<p>If <tt class="docutils literal"><span class="pre">True</span></tt>, then the data will only be saved if the
current <tt class="docutils literal"><span class="pre">clock['step']</span></tt> counter is different from the
step counter of the last saved configuration. If
<tt class="docutils literal"><span class="pre">False</span></tt>, then the data will be saved in any
case. Default is <tt class="docutils literal"><span class="pre">`False`</span></tt>. This is internally used by
the hysteresis command (which uses <tt class="docutils literal"><span class="pre">avoid_same_step</span> <span class="pre">==</span>
<span class="pre">True</span></tt>) to avoid saving the same data twice.</p>
<p>The only situation where the step counter may not have
changed from the last saved configuration is if the user
is modifying the magnetisation or external field manually
(otherwise the call of the time integrator to advance or
relax the system will automatically increase the step
counter).</p>
</blockquote>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="set-m">
<h3><a class="toc-backref" href="manual.html#id158">4.2.16&nbsp;&nbsp;&nbsp;set_m</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.set_m</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">values,</span> <span class="pre">subfieldname=None)</span></tt></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>values</cite> <span class="classifier-delimiter">:</span> <span class="classifier">vector (=list), function or numpy array.</span></dt>
<dd><p class="first last">The values to be set. See more detailed explanation below.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>This method sets the (normalised) magnetisation  (i.e. the <tt class="docutils literal"><span class="pre">m</span></tt> field)
to a particular value (or pattern).</p>
<p>It can be used in three different ways:</p>
<ol class="arabic">
<li><p class="first">Providing a constant vector</p>
<p>If given a vector, this function sets the <tt class="docutils literal"><span class="pre">m</span></tt> field to uniformly point in
the given direction, everywhere.</p>
<p>For example, to have the magnetisation point
in +x-direction, we could call the function like this:</p>
<pre class="literal-block">
sim.set_m([1,0,0])
</pre>
<p>To point in a 45 degree direction between the x- and y-axis,
we could use:</p>
<pre class="literal-block">
sim.set_m([1,1,0])
</pre>
<p>(The magnetisation will automatically be normalised.)</p>
</li>
<li><p class="first">Providing a function</p>
<p>If the magnetisation is meant to vary spatially, then a
function can be given to the <tt class="docutils literal"><span class="pre">set_m</span></tt> method as in this
example:</p>
<pre class="literal-block">
def my_magnetisation((x,y,z)):
    # get access to pi, cos and sin
    import math

    # change angle of Mx and My by 10 degree when x varies by 1nm
    angle = (x*1e9)*10./360*2*math.pi
    Mx = math.cos(angle)
    My = math.sin(angle)
    Mz = 0

    #return magnetisation vector for position (x,y,z)
    return (Mx,My,Mz)

sim.set_m(my_magnetisation)
</pre>
<p>The function <tt class="docutils literal"><span class="pre">my_magnetisation</span></tt> returns the magnetisation vector
corresponding to the given 3d position in space.</p>
<p>This position <tt class="docutils literal"><span class="pre">(x,y,z)</span></tt> as given to the function is expressed in meters.</p>
</li>
<li><p class="first">Providing a numpy array.</p>
<p>If a numpy array is provided to set the values of the
subfield, then the shape of this array has to match the
shape of the subfield data. For example, if the subfield is
the magnetisation of material X, and this material is
defined on n mesh sites, then the array needs to have n
entries. Each of those has to be a 3-component array,
as the magnetisation vector has three components.</p>
<p>Note: the Simulation.get_subfield() function can be used to
obtain exactly such a numpy array for the relevant
subfield.</p>
<p>To read such a numpy array from a file, you can use the
<a class="reference internal" href="manual.html#get-subfield-from-h5file">get_subfield_from_h5file</a> function. However, you have to be
sure that the node order in the mesh (that is stored in the
_dat.h5 file) is the same as the mesh you are currently
using in your simulation. This should certainly be the case
if (i) both runs [i.e. the saved and the current] are based
on the same mesh, and (ii) you only us one CPU [as using
more than one results in repartitioning and reordering of
the mesh]. We aim to not allow setting 'wrong' data here in
the future, but currently such checking is not
implemented. (fangohr 31/05/2008)</p>
</li>
</ol>
</div>
<div class="section" id="set-h-ext">
<h3><a class="toc-backref" href="manual.html#id159">4.2.17&nbsp;&nbsp;&nbsp;set_H_ext</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.set_H_ext</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">values,</span> <span class="pre">unit=None)</span></tt></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>values</cite> <span class="classifier-delimiter">:</span> <span class="classifier">vector (=list), function or numpy array.</span></dt>
<dd><p class="first last">See <a class="reference internal" href="manual.html#set-m">set_m</a> for an explanation of possible <tt class="docutils literal"><span class="pre">values</span></tt>.</p>
</dd>
</dl>
<p><cite>unit</cite> : SI Object</p>
<blockquote class="last">
<p>An SI Object that is used as a multiplier for the
<tt class="docutils literal"><span class="pre">values</span></tt>. This unit has to be physically compatible with
Ampere per meter.</p>
<p>To set an applied field that is homogenous and points in
+x-direction, one can use:</p>
<pre class="literal-block">
sim.set_H_ext([1e6,0,0],SI(1,&quot;A/m&quot;))

which is equivalent to::

sim.set_H_ext([1,0,0],SI(1e6,&quot;A/m&quot;))
</pre>
<p>However, we could also define the field in Oersted:</p>
<pre class="literal-block">
from nmag.si import Oe
sim.set_H_ext([100,0,0],Oe)
</pre>
<p>or in Tesla/mu0:</p>
<pre class="literal-block">
from nmag.si import Tesla, mu0
sim.set_H_ext([1,0,0],T/mu0)
</pre>
</blockquote>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="set-pinning">
<h3><a class="toc-backref" href="manual.html#id160">4.2.18&nbsp;&nbsp;&nbsp;set_pinning</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.set_pinning</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">values)</span></tt></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><cite>values</cite> : vector (=list), function or numpy array.</td>
</tr>
</tbody>
</table>
<p>This method sets the scalar pinning field which defines a
local scale factor for <tt class="docutils literal"><span class="pre">dm/dt</span></tt>.</p>
<p>Default value is <tt class="docutils literal"><span class="pre">1.0</span></tt>, use <tt class="docutils literal"><span class="pre">0.0</span></tt> to force <tt class="docutils literal"><span class="pre">dm/dt</span></tt> to
zero, that is, to &quot;pin&quot; (fix) magnetisation at a certain
position.</p>
<p>Semantics of the <cite>values</cite> parameter match <a class="reference internal" href="manual.html#set-m">set_m</a>.</p>
</div>
<div class="section" id="set-params">
<h3><a class="toc-backref" href="manual.html#id161">4.2.19&nbsp;&nbsp;&nbsp;set_params</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">Simulation.set_params</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">stopping_dm_dt=None,</span> <span class="pre">ts_rel_tol=None,</span> <span class="pre">ts_abs_tol=None,</span> <span class="pre">exact_tstop=None)</span></tt></dd>
</dl>
<p>Set the parameters which control the accuracy and performance
of the simulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>ts_rel_tol</cite> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">the relative error tolerance (default is 1e-6) for the timestepper</p>
</dd>
<dt><cite>ts_abs_tol</cite> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">the absolute error tolerance (default is 1e-6) for the timestepper</p>
</dd>
<dt><cite>stopping_dm_dt</cite> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="manual.html#si">SI</a> object</span></dt>
<dd><p class="first">the value used in the <a class="reference internal" href="manual.html#hysteresis">hysteresis</a> and <a class="reference internal" href="manual.html#relax">relax</a> functions to decide
whether convergence has been reached. If the largest value for dm/dt drops
below <tt class="docutils literal"><span class="pre">stopping_dm_dt</span></tt>, then convergence has been reached.</p>
<p class="last">The default value for <tt class="docutils literal"><span class="pre">stopping_dm_dt</span></tt> this is that the
magnetisation changes less than one degree per nanosecond,
i.e. <tt class="docutils literal"><span class="pre">stopping_dm_dt</span> <span class="pre">=</span> <span class="pre">SI(17453292.519943293,['s',-1])</span></tt>.</p>
</dd>
<dt><cite>exact_tstop</cite> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">the value of exact_tstop which is used by the advance_time method
when the optional argument is not given. This is also the value
used by the relax and hysteresis methods. See the documentation
of advance_time for further details.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Note that this command has to be issued <em>after</em> having created
an m-field with the <a class="reference internal" href="manual.html#set-m">set_m</a> command.</p>
</div>
</div>
<div class="section" id="get-subfield-from-h5file">
<h2><a class="toc-backref" href="manual.html#id162">4.3&nbsp;&nbsp;&nbsp;get_subfield_from_h5file</a></h2>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">get_subfield_from_h5file</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(filename,</span> <span class="pre">subfieldname,</span> <span class="pre">id=None,</span> <span class="pre">row=None,</span> <span class="pre">unit=None)</span></tt></dd>
</dl>
<p>Retrieve data from h5 file. Data are returned as <a class="reference internal" href="manual.html#si-value">SI-value</a>s.</p>
<p>Analog to <a class="reference internal" href="manual.html#get-subfield">get_subfield</a> (which returns subfield data for a
subfield of a simulation object), but will retrieve data from
saved <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>filename</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The full name of the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> data file.</p>
</dd>
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield to be retrieved.</p>
</dd>
<dt><cite>id</cite> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The <tt class="docutils literal"><span class="pre">id</span></tt> of the configuration to return (defaults to 0)</p>
</dd>
<dt><cite>row</cite> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first">If the <tt class="docutils literal"><span class="pre">id</span></tt> is not specified, the <tt class="docutils literal"><span class="pre">row</span></tt> can
be used to address the data row with index <tt class="docutils literal"><span class="pre">row</span></tt>.</p>
<p>For example, the magnetisation may have been saved at some
point during the simulation into a file (for example
using the <a class="reference internal" href="manual.html#restart-example">Restart example</a> functionality, or using the
<a class="reference internal" href="manual.html#save-data">save_data</a> method for the first time to save the m-field
(i.e. <tt class="docutils literal"><span class="pre">sim.save_data(fields=['m']</span></tt>) into a new file).</p>
<p class="last">We can use <tt class="docutils literal"><span class="pre">row=0</span></tt> to read the first magnetisation
configuration that has been written into this file (and
<tt class="docutils literal"><span class="pre">row=1</span></tt> to access the second etc).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy array</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="get-subfield-positions-from-h5file">
<h2><a class="toc-backref" href="manual.html#id163">4.4&nbsp;&nbsp;&nbsp;get_subfield_positions_from_h5file</a></h2>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">get_subfield_positions_from_h5file</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(filename,</span> <span class="pre">subfieldname)</span></tt></dd>
</dl>
<p>Analogous to <a class="reference internal" href="manual.html#get-subfield-positions">get_subfield_positions</a> (which returns the positions of
nodes for a subfield of a simulation object), but will retrieve
data from saved <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>filename</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The full name of the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> data file.</p>
</dd>
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield to be retrieved.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>numpy array</dt>
<dd><p class="first last">The positions are returned as <a class="reference internal" href="manual.html#si-value">si-value</a>s.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="get-subfield-sites-from-h5file">
<h2><a class="toc-backref" href="manual.html#id164">4.5&nbsp;&nbsp;&nbsp;get_subfield_sites_from_h5file</a></h2>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">get_subfield_sites_from_h5file</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(filename,</span> <span class="pre">subfieldname)</span></tt></dd>
</dl>
<p>Analogous to <a class="reference internal" href="manual.html#get-subfield-sites">get_subfield_sites</a> (which returns the site ids of
nodes for a subfield of a simulation object), but will retrieve
data from saved <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>filename</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The full name of the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> data file.</p>
</dd>
<dt><cite>subfieldname</cite> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the subfield to be retrieved.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>numpy array</dt>
<dd><p class="first last">The ids are returned as <a class="reference internal" href="manual.html#si-value">si-value</a>s.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="hmatrixsetup">
<h2><a class="toc-backref" href="manual.html#id165">4.6&nbsp;&nbsp;&nbsp;HMatrixSetup</a></h2>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">HMatrixSetup</span></tt></dd>
<dt>Class constructor information:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">algorithm='HCA2',</span> <span class="pre">**kwargs)</span></tt></dd>
</dl>
<p>A class collecting the parameters needed in order to set up an HMatrix
with HLib within Nmag.</p>
<p>The optional argument <tt class="docutils literal"><span class="pre">algorithm</span></tt> is by default set to &quot;HCA2&quot;.
At present no other values are supported.
The user can then specify a number of parameters in order to fine-tune
the setup of the HMatrix. <tt class="docutils literal"><span class="pre">**kwargs</span></tt> stands for one or more of the
following parameters (see <a class="reference external" href="http://www.hlib.org">Hlib</a> documentation
for detailed descriptions of the parameers):</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name" colspan="2">Parameters of HCA II:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><cite>eps_aca</cite> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">A heuristic parameter which influences the accuracy of HCA II.
By default this parameter is set to 1e-7</p>
</dd>
<dt><cite>poly_order</cite> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">A second parameter which influences the accuracy of the HCA II.
Its default setting is 4.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Parameter for recompression algorithm:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><cite>eps</cite> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">This parameter determines the accuracy of the recompression
algorithm, which optimises a given hierarchical matrix.
The default value is 0.001.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Parameters influencing the tree structure:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><dl class="first docutils">
<dt><cite>eta</cite> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">eta is a parameter which influences the so called admissibility
criterion. As explained above, a subblock of the boundary element
matrix basically  describes the dipole potential at a cluster of
surface nodes A generated by a different cluster B. The subblock
can only be approximated when both cluster are spatially well
separated. To have an objective measure of what 'well separated'
means, an admissibility criterion has been introduced. The smaller
the parameter eta is chosen, the more restrictive is the
admissibility criterion. The default value is 2.0.</p>
</dd>
<dt><cite>nmin</cite> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">In order to be able to adjust the coarseness of the tree structure
(a too fine tree structure would result in a higher amount of memory
required for the storage of the tree itself), a parameter nmin has
been introduced. It is the minimal number of lines or rows a
submatrix within a leave can have, and is by default set to 30.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Parameter for the numerical quadrature:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><dl class="first last docutils">
<dt><cite>quadorder</cite> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The order of the Gaussian quadrature used to compute matrix entries
for the low-rank matrix blocks. For the matrix blocks, which are not
approximated, an analytical expression instead of numerical
integration is used. By default, quadorder is set to 3.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="si">
<h2><a class="toc-backref" href="manual.html#id166">4.7&nbsp;&nbsp;&nbsp;SI</a></h2>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">SI</span></tt></dd>
<dt>Class constructor information:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">value,</span> <span class="pre">dimensions=[])</span></tt></dd>
</dl>
<p>Physical quantity in the SI units system.</p>
<p>This class allows to associate SI-dimensions (such as meter,
kilogram, Ampere, seconds, candela and mol) with a floating point
number.</p>
<p>The resulting object supports addition, subtraction, (which fails if
the dimensions of the objects in a sum or difference disagree),
multiplication and division.</p>
<p>There are different ways to create objects:</p>
<ol class="arabic">
<li><p class="first">The most fundamental approach is to
provide a value and a list of pairs where each pair is
a character identifying the SI base unit and an integer that
provides its power.</p>
<p>Examples:</p>
<ol class="upperalpha simple">
<li><tt class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">SI(10,['m',1,'s',-1])</span></tt> is the code to create an SI object v
that represents 10 m/s.</li>
<li><tt class="docutils literal"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">SI(0.6,['kg',1,'s',-2,'A',-1])</span></tt> is the code to create an SI
object T that represents  0.6 kg/(s^2 A) (i.e. 0.6 Tesla)</li>
</ol>
</li>
<li><p class="first">A more convenient way is to first define all the base units
like this (these are already defined in the <tt class="docutils literal"><span class="pre">si</span></tt> submodule, so
instead of the following lines below, we could also just write:
<tt class="docutils literal"><span class="pre">from</span> <span class="pre">si</span> <span class="pre">import</span> <span class="pre">meter,second,Ampere</span></tt>):</p>
<pre class="literal-block">
meter = SI(1,'m') # alternative spelling: metre
second = SI(1,'s')
Ampere = SI(1,'A')
</pre>
<p>and then to use these SI objects to create more complex
expressions:</p>
<pre class="literal-block">
v = 10*meter/second
B = 0.6*kilogram/second**2/Ampere
</pre>
<p>Of course, short hand notations can be defined such as:</p>
<pre class="literal-block">
T = kilogram/second**2/Ampere
B = 0.6*Tesla
</pre>
</li>
<li><p class="first">Finally, there is another convenient way:</p>
<p>Instead of a SI dimension vector as in (1), it is possible to pass
a string specifying dimensions. Examples are:</p>
<p>&quot;A/m&quot;, &quot;V/m&quot;, &quot;J/m^3&quot;, &quot;m^2 s^(-2)&quot;, &quot;m^-3 s^-1&quot; etc.</p>
<p>The dimensions parser will understand (in addition to m, kg, s, A, K, mol, cd):
J, N, W, T, V, C, Ohm, H</p>
</li>
</ol>
<p>A very basic demonstration of the SI object in use:</p>
<pre class="literal-block">
&gt;&gt;&gt; a = SI(1,'m')
&gt;&gt;&gt; b = SI(1e-3,'m')
&gt;&gt;&gt; print a+b
&lt;SI: 1.001  m &gt;
&gt;&gt;&gt; print a*b
&lt;SI: 0.001  m^2 &gt;
&gt;&gt;&gt; print a/b
&gt;&gt;&gt; &lt;SI: 1000  &gt;           #Note that this is dimensionless
                           #because we divided meters by meters
</pre>
<div class="section" id="value">
<h3><a class="toc-backref" href="manual.html#id167">4.7.1&nbsp;&nbsp;&nbsp;value</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">SI.value</span></tt></dd>
<dt>Property information</dt>
<dd><blockquote class="first">
<tt class="docutils literal"><span class="pre">None</span></tt></blockquote>
<p>Read-only attribute to obtain (dimensionless) value of Physical Object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><cite>value</cite> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The numerical value.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<blockquote class="last">
<pre class="doctest-block">
&gt;&gt;&gt; from nmag import SI
&gt;&gt;&gt; H = SI(10, 'A/m')
&gt;&gt;&gt; print H.value
10.0
 &gt;&gt;&gt; print H
&lt;SI: 10  A / m &gt;
</pre>
</blockquote>
</dd>
</dl>
</div>
<div class="section" id="units">
<h3><a class="toc-backref" href="manual.html#id168">4.7.2&nbsp;&nbsp;&nbsp;units</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">SI.units</span></tt></dd>
<dt>Property information</dt>
<dd><tt class="docutils literal"><span class="pre">None</span></tt></dd>
</dl>
<p>Read-only attribute to obtain units of Physical Object (returned as list of pairs of dimension name and power)</p>
</div>
<div class="section" id="in-units-of">
<h3><a class="toc-backref" href="manual.html#id169">4.7.3&nbsp;&nbsp;&nbsp;in_units_of</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">SI.in_units_of</span></tt></dd>
<dt>Arguments:</dt>
<dd><blockquote class="first">
<tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">unit_quantity)</span></tt></blockquote>
<p>The object will be expressed in multiplies of
'unit_quantity'. This is useful to convert from one
measurement convention (such as m/s) to another one (such as
km/h). The return value is just a float.</p>
<p>The units of 'unit_quantity' have to be compatible with the
units of the object itself (otherwise an exception is raised).</p>
<p>A simple example:</p>
<pre class="literal-block">
&gt;&gt;&gt; d = SI(10,'m')
&gt;&gt;&gt; inch = SI(2.54e-2,'m')
&gt;&gt;&gt; d.in_units_of(inch)
393.70078740157478
</pre>
<p>Another example:</p>
<pre class="literal-block">
&gt;&gt;&gt; m = SI(1,'m')
&gt;&gt;&gt; s = SI(1,'s')
     &gt;&gt;&gt; velocity=2*m/s
&gt;&gt;&gt; print velocity
&lt;SI: 2  m / s &gt;
&gt;&gt;&gt; km = 1000*m
&gt;&gt;&gt; h = 3600*s
&gt;&gt;&gt; print velocity.in_units_of(km/h)
8.2
</pre>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><cite>unit_quantity</cite> <span class="classifier-delimiter">:</span> <span class="classifier">SI Object</span></dt>
<dd><p class="first last">The SI object itself (i.e. <tt class="docutils literal"><span class="pre">self</span></tt>) will be expressed in
multiplies of this <tt class="docutils literal"><span class="pre">unit_quantity</span></tt>.  `</p>
</dd>
</dl>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>float</dt>
<dd><p class="first last">This is the number that, multiplied by the <tt class="docutils literal"><span class="pre">unit_quantitity</span></tt> will
provide the SI quantity of the object itself.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</div>
<div class="section" id="is-compatible-with">
<h3><a class="toc-backref" href="manual.html#id170">4.7.4&nbsp;&nbsp;&nbsp;is_compatible_with</a></h3>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">SI.is_compatible_with</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">(self,</span> <span class="pre">physical_quantity)</span></tt></dd>
</dl>
<p>Returns True when the given physical quantity is compatible with the object
itself.</p>
<p>Example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from nsim.si_units import SI
&gt;&gt;&gt; m_per_sec = SI(1,'m')/SI(1,'s')
&gt;&gt;&gt; km_per_hour = SI(1000,'m')/SI(3600,'s')
&gt;&gt;&gt; Newton = SI(1,'kg')*SI(1,'m')/SI(1,'s')**2
&gt;&gt;&gt; m_per_sec.is_compatible_with(Newton)
False
&gt;&gt;&gt; m_per_sec.is_compatible_with(km_per_hour)
True
</pre>
</div>
</div>
<div class="section" id="ipython">
<h2><a class="toc-backref" href="manual.html#id171">4.8&nbsp;&nbsp;&nbsp;ipython</a></h2>
<dl class="docutils">
<dt>Module:</dt>
<dd><tt class="docutils literal"><span class="pre">nmag</span></tt></dd>
<dt>Object:</dt>
<dd><tt class="docutils literal"><span class="pre">ipython</span></tt></dd>
<dt>Arguments:</dt>
<dd><tt class="docutils literal"><span class="pre">()</span></tt></dd>
</dl>
<p>Interactive python prompt (see <a class="reference internal" href="manual.html#example-ipython">Example: IPython</a>).</p>
</div>
<div class="section" id="command-line-options">
<h2><a class="toc-backref" href="manual.html#id172">4.9&nbsp;&nbsp;&nbsp;Command line options</a></h2>
<p>Nmag supports a number of command line options to configure its behaviour.</p>
<p>Suppose the simulation script is called <tt class="docutils literal"><span class="pre">X.py</span></tt>, then these OPTIONS can be specified like this:</p>
<pre class="literal-block">
nsim X.py OPTIONS
</pre>
<p><tt class="docutils literal"><span class="pre">X.py</span></tt> needs to contain at least the line <tt class="docutils literal"><span class="pre">import</span> <span class="pre">nmag</span></tt> as this will process the command line options.</p>
<p>The available options are:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">--clean:</th><td class="field-body"><p class="first">to override any existing <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> and <tt class="docutils literal"><span class="pre">_dat.ndt</span></tt> files. If this
option is not provided and the data files exist already, then nmag
will interrupt the execution without having modified the data files
on the disk.</p>
<p>Example:</p>
<pre class="literal-block">
nsim X.py --clean
</pre>
</td>
</tr>
<tr class="field"><th class="field-name">--loglevel:</th><td class="field-body"><p class="first">this switch determines the amount of information that is being send
to stdout (usually the screen) and also to the file <tt class="docutils literal"><span class="pre">X_log.log</span></tt>.</p>
<p>The available levels are in increasing order of detail:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">error:</th><td class="field-body">print no messages apart from errors</td>
</tr>
<tr class="field"><th class="field-name">warning:</th><td class="field-body">print warnings</td>
</tr>
<tr class="field"><th class="field-name">info:</th><td class="field-body">print a moderate amount of information (default)</td>
</tr>
<tr class="field"><th class="field-name">info2:</th><td class="field-body">print slightly more information</td>
</tr>
<tr class="field"><th class="field-name">debug:</th><td class="field-body">print a lot of information (typically for developer and debugging use)</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre class="literal-block">
nsim X.py --loglevel info2
</pre>
<p>or:</p>
<pre class="literal-block">
nsim X.py --loglevel debug
</pre>
</td>
</tr>
<tr class="field"><th class="field-name">--slavelog:</th><td class="field-body"><p class="first">Log message from slave nodes (when running under MPI) are usually
supressed. This switch activates them. Printing these messages will
reduce the MPI performance somewhat as the messages are printed to
stdout on each slave, and then have to be transferred through the
network to the master process.</p>
<p>Note that any log-messages from the nodes will only go to stdout
(whereas log messages from the master will also go into the log
file, see <a class="reference internal" href="manual.html#file-names-for-log-files">File names for log files</a>.)</p>
<p>Messages from slave nodes are preceeded by <tt class="docutils literal"><span class="pre">S0X</span></tt> where X is the
rank of the node. I.e. log messages from slave node with rank 2,
would start with <tt class="docutils literal"><span class="pre">S02</span></tt>.</p>
<p>Example:</p>
<pre class="literal-block">
nsim X.py --slavelog
</pre>
</td>
</tr>
<tr class="field"><th class="field-name">--restart:</th><td class="field-body"><p class="first">If a calculation of a hysteresis loop is interrupted (power cut,
computer crash, exceeding allocated run time on cluster, etc), then
the calculation can be carried out starting from the moment when the
last restart file was saved (see <a class="reference internal" href="manual.html#restart-example">Restart example</a>).</p>
<p>This continuation is activated with the <tt class="docutils literal"><span class="pre">--restart</span></tt> switch.</p>
<p>Example:</p>
<pre class="literal-block">
nsim X.py --restart
</pre>
<p class="last">Note that this functionality is only available for the hysteresis loop.</p>
</td>
</tr>
</tbody>
</table>
<p>The command line options can be combined, for example:</p>
<pre class="literal-block">
nsim X.py --clean --loglevel debug
</pre>
<p>There are a few other switches (mostly for debugging) which can be seen using:</p>
<pre class="literal-block">
nsim X.py --help
</pre>
</div>
</div>
<div class="section" id="finite-element-mesh-generation">
<h1><a class="toc-backref" href="manual.html#id173">5&nbsp;&nbsp;&nbsp;Finite element mesh generation</a></h1>
<p>Finite element mesh generation is a difficult business, and one needs
to get used to using at least one mesh generating software package to
be able to create meshes for the geometries one wants to simulate.</p>
<p>A list of available free and commercial mesh generators is available at:
<a class="reference external" href="http://www.andrew.cmu.edu/user/sowen/softsurv.html">http://www.andrew.cmu.edu/user/sowen/softsurv.html</a></p>
<p>For nmag one needs to create 'unstructured' meshes which means for
three dimensional simulations that the mesh simplices are tetrahedra,
and the surface elements are triangles.</p>
<p>We are not recommending any mesh generating software. We have used
<a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> to generate most of the meshes for this manual. The
Vienna/Sheffield group (Fidler and Schrefl) use the commercial mesh
generator <em>GID</em> (<a class="reference external" href="http://gid.cimne.upc.es/">http://gid.cimne.upc.es/</a>).</p>
<p>The mesh format used by nmag is called  nmesh  and described in
<a class="reference internal" href="manual.html#nmesh-file-format">Nmesh file format</a>.</p>
<p>The <a class="reference internal" href="manual.html#nmeshimport">nmeshimport</a> tool provides conversion from the following mesh
formats into nmesh files:</p>
<ul>
<li><p class="first">Netgen (neutral). Create mesh in Netgen, then go to <tt class="docutils literal"><span class="pre">File-&gt;Export</span>
<span class="pre">Filetype</span></tt> and ensure that <tt class="docutils literal"><span class="pre">Neutral</span> <span class="pre">Format</span></tt> is selected. Then
export the mesh with <tt class="docutils literal"><span class="pre">File-&gt;Export</span> <span class="pre">Mesh</span></tt>. (See also <a class="reference internal" href="manual.html#mesh-generation">Mesh
generation</a> which is part of the <a class="reference internal" href="manual.html#guided-tour">Guided Tour</a>.)</p>
</li>
<li><p class="first">There is a contributed import module for <a class="reference external" href="http://www.fluent.com/software/gambit/index.htm">Gambit</a>. Use at your own risk.</p>
</li>
<li><p class="first"><a class="reference external" href="http://www.geuz.org/gmsh/">Gmsh</a> meshes written file format version 1.0 can be imported.</p>
<p>If you already have the Gmsh mesh file in format 2.0, then you can use</p>
<pre class="literal-block">
$&gt; gmsh -3 -format msh1 -o outfile.msh infile.msh
</pre>
<p>to create 'outfile.msh' which contains the mesh in the gmesh file format 1.0 that can be imported.</p>
<dl class="docutils">
<dt>If you create the mesh interactively, then</dt>
<dd><ul class="first last simple">
<li>choose <tt class="docutils literal"><span class="pre">FILE</span> <span class="pre">-&gt;</span> <span class="pre">SAVE</span> <span class="pre">AS</span></tt>,</li>
<li>select <tt class="docutils literal"><span class="pre">Gmsh</span> <span class="pre">mesh</span> <span class="pre">(*.msh)</span></tt> from the drop down list,</li>
<li>choose filename and click <tt class="docutils literal"><span class="pre">OK</span></tt></li>
<li>When the <tt class="docutils literal"><span class="pre">MSH</span> <span class="pre">Options</span></tt> box appears, choose <tt class="docutils literal"><span class="pre">Version</span> <span class="pre">1.0</span></tt> from the
drop down list in the Format field.</li>
<li>click <tt class="docutils literal"><span class="pre">OK</span></tt></li>
</ul>
</dd>
</dl>
<p>If you create your meshes automatically from the command line, then add <tt class="docutils literal"><span class="pre">--format</span> <span class="pre">msh1</span></tt> to the command line
to instruct <a class="reference external" href="http://www.geuz.org/gmsh/">Gmsh</a> to write in the 1.0 format.</p>
</li>
</ul>
<div class="section" id="nmesh-file-format">
<h2><a class="toc-backref" href="manual.html#id174">5.1&nbsp;&nbsp;&nbsp;Nmesh file format</a></h2>
<p>There are two nmesh file formats: <a class="reference internal" href="manual.html#ascii-nmesh">ascii nmesh</a> and <a class="reference internal" href="manual.html#hdf5-nmesh">hdf5 nmesh</a>.</p>
<div class="section" id="ascii-nmesh">
<h3><a class="toc-backref" href="manual.html#id175">5.1.1&nbsp;&nbsp;&nbsp;Ascii nmesh</a></h3>
<p>This section describes the syntax of the nmesh ascii files. You only
need to read this if you would like to know what the nmesh ascii
format looks like. This is only necessary if you (i) need to convert
nmesh ascii files into other mesh formats, or (ii) if you have
generated a mesh in a format that is not supported by <a class="reference internal" href="manual.html#nmeshimport">nmeshimport</a>.</p>
<p>(You could in principle convert any data into the <cite>nmesh hdf5</cite> format
but it is expected that it is easier to convert the mesh into a <cite>nmesh
ascii</cite> file, and then use <a class="reference internal" href="manual.html#nmeshpp">nmeshpp</a> with option <tt class="docutils literal"><span class="pre">--convert</span></tt> to
convert the mesh frnm nmesh ascii to nmesh hdf5.)</p>
<p>We describe the structure of the ascii nmesh file format using the
following example: A <a class="reference external" href="../files/smallsphere.nmesh">mesh file</a> for
a sphere with radius 1 (with <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> and this geometry file
<a class="reference external" href="../files/sphere.geo">sphere.geo</a>):</p>
<div align="center" class="align-center"><img alt="../images/smallsphere.png" class="align-center" src="../images/smallsphere.png" /></div>
<p>The mesh file looks as follows:</p>
<pre class="literal-block">
# PYFEM mesh file version 1.0
# dim = 3      nodes = 79      simplices = 174         surfaces = 148          periodic = 0
79
         0.000000000000            0.000000000000            0.000000000000
         1.000000000000            0.000000000000            0.000000000000
         0.911922000000            0.410365000000            0.000000000000
         0.941662000000            0.159249000000            0.296499000000
&lt;snip&gt;
         0.038305000000           -0.552912000000           -0.107777000000
        -0.533150000000            0.052091000000           -0.084880000000
174
     1         58          0         62         78
     1         33         78         36         50
     1         19         77          0         17
     1         67         75         78         72
&lt;snip&gt;
     1         58          0         53         62
     1         77         51         32         39
     1         78         67         63         72
     1         78         49         63         50
148
     -1 1     45 51 59
     1 -1     5 12 13
     1 -1     25 37 39
&lt;snip&gt;
     1 -1     19 30 34
     1 -1     42 44 54
     1 -1     32 45 51
</pre>
<p>We have removed a significant number of lines for the purpose of
abbreviation in the places marked with <tt class="docutils literal"><span class="pre">&lt;snip&gt;</span></tt>. We discuss the
different parts of this file in more detail:</p>
<ul>
<li><p class="first">The file starts with two lines starting with <tt class="docutils literal"><span class="pre">#</span></tt>.</p>
<ul>
<li><p class="first">The first line contains a file format version string which needs to have
exactly this form.</p>
</li>
<li><p class="first">The second line contains a summary of the data, i.e.:</p>
<dl class="docutils">
<dt>dim</dt>
<dd><p class="first last">the dimensionality of the space in which the mesh is defined (usually 3,
as we work with meshes in 3d space).</p>
</dd>
<dt>nodes</dt>
<dd><p class="first last">the number of nodes (also called vertices), here <tt class="docutils literal"><span class="pre">79</span></tt></p>
</dd>
<dt>simplices</dt>
<dd><p class="first last">the number of simplices (also called volume elements), here <tt class="docutils literal"><span class="pre">174</span></tt>.
In 3d, a simplex is a tetrahedron.</p>
</dd>
<dt>surfaces</dt>
<dd><p class="first last">the number of surface elements, here <tt class="docutils literal"><span class="pre">148</span></tt>. In 3d, the surface
elements are triangles.</p>
</dd>
<dt>periodic</dt>
<dd><p class="first last">the number of periodic identifications of points.</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p class="first">The next section contains the data for all the nodes. The first line
of this section contains (again) the total number of nodes
(<tt class="docutils literal"><span class="pre">79</span></tt>). All subsequent 79 lines in this section contain each the
position of one node. Because the dimensionality of space in this
example is 3, there are 3 floating point numbers per node (i.e. the
x, y and z-component).</p>
</li>
<li><p class="first">The next section contains the data for the simplices. The first line
of this section contains (again) the total number of simplices (here
<tt class="docutils literal"><span class="pre">174</span></tt>). The next 174 lines contain the following information each:</p>
<p>The first integer is a <em>region identifier</em>. In this example, we have
only one region (the sphere). This is useful, if different magnetic
materials are simulated at the same time. When the mesh is loaded
into nmag, one assigns material properties to these regions.</p>
<p>The next 4 integers (in 3 dimensions) are node identifiers. The 4 nodes
listed here, form a simplex. Note that the very first node has index 0.</p>
</li>
<li><p class="first">The next section contains the data for the surface elements. The
first line contains the number of surface elements (<tt class="docutils literal"><span class="pre">148</span></tt>). The
next 148 lines contain each the following information:</p>
<ul class="simple">
<li>The first two integers are the region identifiers between which the
surface is sandwiched. If there is no simplex on one side of the surface,
then the &quot;outside&quot; region identifier of <tt class="docutils literal"><span class="pre">-1</span></tt> will be used. (It is possible
to use other negative numbers to discern between different parts of the outer
boundary. This is occasionally important in nsim to specify Dirichlet and
von Neumann boundary conditions along different parts of a boundary.)</li>
<li>The following integers are the node ids of the nodes that define
the surface. (In this example, we have three nodes as the surface
elements are triangles.)</li>
</ul>
<p>Note that this last section is only contained in the file to make the
users' life easier (for, say, plotting of the mesh). This section on
surface elements can be omitted and nmesh will read and process the mesh
even if the surface elements are not specified (they can be computed from
the node and simplex data provided in the other sections).</p>
</li>
<li><p class="first">The next section contains data about periodic points. The first line
again is the number of data lines to follow. Each data line gives the
node indices belonging to one set of points that are treated as
copies of the same point. (I.e. Nmag will know that field degrees of
freedom associated to points from such a set will have &quot;mirage&quot; copies and
use this information internally e.g. in the time integrator and when building
finite element matrix operators.)</p>
</li>
</ul>
</div>
<div class="section" id="hdf5-nmesh">
<h3><a class="toc-backref" href="manual.html#id176">5.1.2&nbsp;&nbsp;&nbsp;Hdf5 nmesh</a></h3>
<p>In addition to the <a class="reference internal" href="manual.html#ascii-nmesh">Ascii nmesh</a> format, there is another (binary and
compressed) way of storing nmesh meshes. This is based on the <a class="reference external" href="http://www.hdfgroup.org/">hdf5</a>
library which often is abbreviated as <tt class="docutils literal"><span class="pre">h5</span></tt>.</p>
<p>We recommend that this file-format to store meshes as it is a
compressed binary file format, and thus much more space efficient. The
<a class="reference internal" href="manual.html#nmeshpp">nmeshpp</a> tool can convert (using <tt class="docutils literal"><span class="pre">--convert</span></tt>) ascii nmesh files into
hdf5 files. Likewise, using the <a class="reference internal" href="manual.html#nmeshimport">nmeshimport</a> tool with a target file
name that ends in <tt class="docutils literal"><span class="pre">.h5</span></tt> will also choose this file format. We
strongly recommend to use the extension <tt class="docutils literal"><span class="pre">.nmesh.h5</span></tt> (but <tt class="docutils literal"><span class="pre">.h5</span></tt> is
sufficient to trigger saving meshes in hdf5 format).</p>
<p>For conversion of other mesh formats to a format readable by nmesh,
we suggest to bring data into <a class="reference internal" href="manual.html#ascii-nmesh">ascii nmesh</a> format, and then convert
this ascii nmesh file to a .h5 file.</p>
<p>For completeness, we outline the <tt class="docutils literal"><span class="pre">nmesh.h5</span></tt> file format
here. Knowledge of <a class="reference external" href="http://www.hdfgroup.org/">hdf5</a> or <a class="reference external" href="http://www.pytables.org/">pytables</a> may be useful to understand the
underlying concepts.</p>
<p>The nmesh.h5 file contains the following nodes (this is output from
<a class="reference external" href="http://www.pytables.org/">pytables</a>'s <tt class="docutils literal"><span class="pre">ptdump</span></tt> program):</p>
<pre class="literal-block">
/ (RootGroup) ''
/etc (Group) 'Configuration and version data'
/etc/filetype (Array(1L,)) 'data file type'
/etc/fileversion (Array(1L,)) 'data file type version'
/mesh (Group) 'Mesh data'
/mesh/points (CArray(1154L, 3L), shuffle,
              zlib(5)) 'Positions of mesh nodes (=points)'
/mesh/simplices (CArray(4953L, 4L), shuffle, zlib(5))
             'Indices of nodes (starting from zero).
              Each row is one simplex.'
/mesh/simplicesregions (CArray(4953L,), shuffle, zlib(5))
             'Region ids (one for each simplex).'
</pre>
<p>In short, the position of the mesh nodes are stored in
<tt class="docutils literal"><span class="pre">/mesh/points</span></tt> as 8byte-floats. The simplices (i.e. tetrahedra in
3d) are stored in <tt class="docutils literal"><span class="pre">/mesh/simplices</span></tt> as a set of integers (4 in 3d)
per simplex which are the indices of the mesh nodes that form the
simplex. We also need to store to what physical region each simplex
belongs. Regions are coded by integer values (with 0 being vacuum, and
-1 the area outside the mesh) and stored in <tt class="docutils literal"><span class="pre">/mesh/simplicesregions</span></tt>.</p>
</div>
</div>
<div class="section" id="mesh-file-size">
<h2><a class="toc-backref" href="manual.html#id177">5.2&nbsp;&nbsp;&nbsp;mesh file size</a></h2>
<p>The following table shows the size of the mesh file used in <a class="reference internal" href="manual.html#example-2">Example 2</a> stored in various formats.</p>
<blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="52%" />
<col width="20%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Filename</th>
<th class="head">size (kB)</th>
<th class="head">type</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>bar30_30_100.neutral</td>
<td>1036</td>
<td>ascii</td>
</tr>
<tr><td>bar30_30_100.neutral.gz</td>
<td>246</td>
<td>gzipped ascii</td>
</tr>
<tr><td>bar30_30_100.nmesh</td>
<td>794</td>
<td>ascii</td>
</tr>
<tr><td>bar30_30_100.nmesh.h5</td>
<td>203</td>
<td>hdf5</td>
</tr>
</tbody>
</table>
</blockquote>
<p>The <tt class="docutils literal"><span class="pre">.neutral</span></tt> file is the mesh as written by <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> in this
particular format. The second line shows the file size of the same
file after compressing with <tt class="docutils literal"><span class="pre">gzip</span></tt>. The third line shows the size of
the mesh stored as an <a class="reference internal" href="manual.html#ascii-nmesh">Ascii nmesh</a> file while the last line gives
the size of the corresponding <a class="reference internal" href="manual.html#hdf5-nmesh">Hdf5 nmesh</a> file.</p>
</div>
</div>
<div class="section" id="executables">
<h1><a class="toc-backref" href="manual.html#id178">6&nbsp;&nbsp;&nbsp;Executables</a></h1>
<div class="section" id="ncol">
<h2><a class="toc-backref" href="manual.html#id179">6.1&nbsp;&nbsp;&nbsp;ncol</a></h2>
<p><tt class="docutils literal"><span class="pre">ncol</span></tt> is a utility to conveniently analyse <a class="reference internal" href="manual.html#ndt">ndt</a> files.</p>
<p>Suppose we have data file with name X_dat.ndt. We can then use:</p>
<pre class="literal-block">
ncol X_dat.ndt
</pre>
<p>or simply:</p>
<pre class="literal-block">
ncol X
</pre>
<p>to display the content of the file. This is useful to quickly gain an
overview of the data in the file.  For the <a class="reference internal" href="manual.html#example-2-computing-the-time-development-of-a-system">Example 2: Computing the
time development of a system</a>, the command is:</p>
<pre class="literal-block">
ncol bar
</pre>
<p>which produces this output:</p>
<pre class="literal-block">
0 :         #time           #&lt;s&gt;              0
1 :            id             &lt;&gt;              0
2 :          step             &lt;&gt;              0
3 :  last_step_dt            &lt;s&gt;              0
4 :    stage_time            &lt;s&gt;              0
5 :    stage_step             &lt;&gt;              0
6 :         stage             &lt;&gt;              0
7 :    E_total_Py      &lt;kg/ms^2&gt;  -260346.5776034
8 :           phi            &lt;A&gt;  2.50626665111e-07
9 :      E_ext_Py      &lt;kg/ms^2&gt;              0
10:     H_demag_0          &lt;A/m&gt;  -263661.6673782
11:     H_demag_1          &lt;A/m&gt;  -8.212128727093
12:     H_demag_2          &lt;A/m&gt;  -77027.64089399
13:     dmdt_Py_0         &lt;A/ms&gt;  -8.250903922407e+15
14:     dmdt_Py_1         &lt;A/ms&gt;  2.333345040949e+16
15:     dmdt_Py_2         &lt;A/ms&gt;  8.250903922407e+15
16:           pin             &lt;&gt;              1
17:   H_anis_Py_0          &lt;A/m&gt;              0
18:   H_anis_Py_1          &lt;A/m&gt;              0
19:   H_anis_Py_2          &lt;A/m&gt;              0
20:        m_Py_0             &lt;&gt;  0.7071067811865
21:        m_Py_1             &lt;&gt;              0
22:        m_Py_2             &lt;&gt;  0.7071067811865
23:        M_Py_0          &lt;A/m&gt;  608111.8318204
24:        M_Py_1          &lt;A/m&gt;              0
25:        M_Py_2          &lt;A/m&gt;  608111.8318204
26:     E_anis_Py      &lt;kg/ms^2&gt;              0
27:     E_exch_Py      &lt;kg/ms^2&gt;  3.114630036477e-11
28:           rho        &lt;A/m^2&gt;  3.469702141876e+13
29:       H_ext_0          &lt;A/m&gt;              0
30:       H_ext_1          &lt;A/m&gt;              0
31:       H_ext_2          &lt;A/m&gt;              0
32:  H_total_Py_0          &lt;A/m&gt;  -263661.6673782
33:  H_total_Py_1          &lt;A/m&gt;  -8.212128727085
34:  H_total_Py_2          &lt;A/m&gt;  -77027.64089399
35:    E_demag_Py      &lt;kg/ms^2&gt;  -260346.5776034
36:   H_exch_Py_0          &lt;A/m&gt;  2.037901097873e-11
37:   H_exch_Py_1          &lt;A/m&gt;              0
38:   H_exch_Py_2          &lt;A/m&gt;  2.037901097873e-11
39: maxangle_m_Py          &lt;deg&gt;              0
40:     localtime             &lt;&gt;  2007/10/04-20:46:28
41:      unixtime            &lt;s&gt;  1191527188.269
</pre>
<p>The four columns above show the following data: the first is just a
line number count. The second is the <em>name</em> of the data. The third
provides the <em>units</em> of this data type. The fourth displays the first
data value in the file (typically corresponding to the configuration
of the simulation when <a class="reference internal" href="manual.html#save-data">save_data</a> was called the first time).</p>
<p>The meaning of the keywords <tt class="docutils literal"><span class="pre">time</span></tt>, <tt class="docutils literal"><span class="pre">id</span></tt>, <tt class="docutils literal"><span class="pre">step</span></tt>, <tt class="docutils literal"><span class="pre">stage_time</span></tt>,
<tt class="docutils literal"><span class="pre">stage_step</span></tt>, <tt class="docutils literal"><span class="pre">stage</span></tt>, <tt class="docutils literal"><span class="pre">localtime</span></tt> and <tt class="docutils literal"><span class="pre">unixtime</span></tt> is explained
in section <a class="reference internal" href="manual.html#stage-step-iteration-time-etc">Stage, Step, iteration, time, etc.</a>.</p>
<p id="unique-identifier-id">The role of the <strong>id</strong> counter is to provide a reference to the
configuration that was saved, and it is a <strong>unique identifier</strong> of a
physical configuration. It is used to identify configurations in the
<tt class="docutils literal"><span class="pre">_dat.h5</span></tt> file (which stores spatially resolved fields) and to
identify the corresponding (spatially averaged) data in the
<tt class="docutils literal"><span class="pre">_dat.ndt</span></tt> file. This <tt class="docutils literal"><span class="pre">id</span></tt> is used to uniquely identify physical
configurations in nmag.  (See also: <a class="reference internal" href="manual.html#why-can-you-not-use-the-step-as-a-unique-identifier">Why can you not use the step as a
unique identifier?</a>)</p>
<p><tt class="docutils literal"><span class="pre">last_step_dt</span></tt> is the length of the last time step carried out by
the timestepper. This is a useful indicator to learn about the
stiffness of the system: the time step is adjusted automatically to
achieve a certain accuracy, and thus the size of the time step
reflects how hard it is to integrate the equations of motion.</p>
<p>The fields starting with <tt class="docutils literal"><span class="pre">E_total_Py</span></tt> down to <tt class="docutils literal"><span class="pre">H_exch_Py_2</span></tt> are
all nsim subfields (see <a class="reference internal" href="manual.html#fields">fields</a>), and the data stored for these are
spatially averaged numbers. For example, the subfield <tt class="docutils literal"><span class="pre">M_Py_0</span></tt> is
the x-component of the Magnetisation of the material <tt class="docutils literal"><span class="pre">Py</span></tt> averaged
over all the space where this material is defined.</p>
<p>The <tt class="docutils literal"><span class="pre">maxangle_m_Py</span></tt> is the maximum angle (in degree) of the change
of the magnetisation from one node in the mesh to the next. It is
important that this number is small: the equations on which the
micromagnetic theory is based assume that the magnetisation changes
slowly as a function of space. In the discretised solvers (this
applies to nmag as it applies to OOMMF, Magpar and other codes),
this means that the maximum angle between neighbouring sites should be
kept small. How small is good enough? This is hard to say in
general. We provide some (subjective) guidance: Values of 180 degrees
(or -180 degrees) quite clearly indicate that the results of the
calculations must not be trusted (i.e. they are wrong). Values around
90 degrees make the results highly questionable. Values of below 30
degrees indicate that the results are probably reliable. The smaller
the value, the more accurate the results will be. If this is new to you, you may want to read the <a class="reference internal" href="manual.html#mini-tutorial-micromagnetic-modelling">Mini tutorial micromagnetic modelling</a> and in particular the section <a class="reference internal" href="manual.html#what-size-of-the-cells-fd-and-tetrahedra-fe-should-i-choose">What size of the cells (FD) and tetrahedra (FE) should I choose?</a>.</p>
<p>The general syntax for calling <tt class="docutils literal"><span class="pre">ncol</span></tt> is:</p>
<pre class="literal-block">
ncol [OPTIONS] datafile [COLS]
</pre>
<p>A list of options can be obtained with:</p>
<pre class="literal-block">
ncol --help
</pre>
<!-- comment:
[Note for developers] In principle we could have used the
iteration counter of the
time integration as this unique identifier. However, because the
user can interactively modify `primary fields`_, and the secondary
fields are updated without calling the time integration, the
timestepper's iteration counter would not provide a unique
reference. Similarly, |nmag| could be extended to include more
sophisticated energy minimisation routines. -->
</div>
<div class="section" id="nmagpp">
<h2><a class="toc-backref" href="manual.html#id180">6.2&nbsp;&nbsp;&nbsp;nmagpp</a></h2>
<p>The stage``nmagpp`` program is the NMAG data PostProcessor. It can be used to</p>
<ul class="simple">
<li>convert data stored in <tt class="docutils literal"><span class="pre">RUNID_dat.h5</span></tt> files into vtk files</li>
<li>dump the data to the screen.</li>
</ul>
<p>The documentation is available with the <tt class="docutils literal"><span class="pre">--help</span></tt> switch:</p>
<pre class="literal-block">
nmagpp --help
</pre>
<div class="section" id="inspecting-the-content">
<h3><a class="toc-backref" href="manual.html#id181">6.2.1&nbsp;&nbsp;&nbsp;Inspecting the content</a></h3>
<p>We describe some typical scenarios, using the data file <tt class="docutils literal"><span class="pre">bar_dat.h5</span></tt>
that is generated in <a class="reference internal" href="manual.html#example-2-computing-the-time-development-of-a-system">Example 2: Computing the time development of a
system</a>.</p>
<p>The <tt class="docutils literal"><span class="pre">bar_dat.h5</span></tt> file contains spatially resolved data for all
fields in the simulation (because we have used the
<tt class="docutils literal"><span class="pre">save_data(fields='all')</span></tt> command). Some of the functions of
<tt class="docutils literal"><span class="pre">nmagpp</span></tt> apply to one or more fields (such as <tt class="docutils literal"><span class="pre">--dump</span></tt> and
<tt class="docutils literal"><span class="pre">--vtk</span></tt>) and these can be specified through a <tt class="docutils literal"><span class="pre">--fields</span></tt> command
line parameter. Similarly, the <tt class="docutils literal"><span class="pre">--range</span></tt> command will limit the number of saved configurations which will be processed.</p>
<p>Try <tt class="docutils literal"><span class="pre">nmagpp</span> <span class="pre">--help</span></tt> for further documentation. Some examples:</p>
<ul>
<li><p class="first">Checking what at what configurations have been saved:</p>
<pre class="literal-block">
nmagpp --idlist bar
</pre>
<p>produces:</p>
<pre class="literal-block">
id   stage   step     time fields
 0-&gt;    1      0         0 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
10-&gt;    1    312     5e-11 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
20-&gt;    1    495     1e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
30-&gt;    1    603   1.5e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
40-&gt;    1    678     2e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
50-&gt;    1    726   2.5e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
60-&gt;    1    762     3e-10 E_anis E_demag E_exch E_ext E_total H_anis H_demag  ... phi pin rho
</pre>
</li>
</ul>
<p>The <tt class="docutils literal"><span class="pre">id</span></tt> is the same <a class="reference internal" href="manual.html#unique-identifier-id">unique identifier id</a> used in the <a class="reference internal" href="manual.html#ndt">ndt</a> files that can be
read with the <a class="reference internal" href="manual.html#ncol">ncol</a> command. In particular, its purpose is to identify
time steps saved in the ndt file with the corresponding data saved in
the h5 data file.</p>
<p>Columns <tt class="docutils literal"><span class="pre">time</span></tt> (measured in seconds), <tt class="docutils literal"><span class="pre">step</span></tt> and <tt class="docutils literal"><span class="pre">stage</span></tt> are
just providing some further information (see <a class="reference internal" href="manual.html#stage-step-iteration-time-etc">Stage, Step, iteration,
time, etc.</a>) Finally, the available (i.e. saved) fields for every
configuration are listed. The list of fields is not displayed
completely if it is long (unless the <tt class="docutils literal"><span class="pre">--printall</span></tt> switch is used).</p>
</div>
<div class="section" id="dumping-data">
<h3><a class="toc-backref" href="manual.html#id182">6.2.2&nbsp;&nbsp;&nbsp;Dumping data</a></h3>
<p>Suppose we are interested in the magnetisation data stored at id
0. We restrict the data to the <tt class="docutils literal"><span class="pre">m</span></tt> field using the <tt class="docutils literal"><span class="pre">--fields</span> <span class="pre">m</span></tt> switch, and restrict the number <tt class="docutils literal"><span class="pre">ids</span></tt> to dump using <tt class="docutils literal"><span class="pre">--range</span> <span class="pre">0</span></tt>:</p>
<pre class="literal-block">
nmagpp --fields m --range 0 --dump bar
</pre>
<p>produces output that starts like this:</p>
<pre class="literal-block">
field    : m
subfield : m_Py
time     : 0 * &lt;SI: 1  s &gt;
id       : 0
step     : 0
stage    : 0
field unit: &lt;SI: 1  &gt;
position unit: &lt;SI: 1e-09  m &gt;
row: 0
#Start (index in h5 table, dofsite, pos, data)
   0:   0 : (  0,  0,  0) : (    0.707107,            0,     0.707107)
   1:   1 : (  3,  0,  0) : (    0.707107,            0,     0.707107)
   2:   2 : (  6,  0,  0) : (    0.707107,            0,     0.707107)
   3:   3 : (  9,  0,  0) : (    0.707107,            0,     0.707107)
</pre>
<p>The first few rows provide some metadata such as which field and
subfield the data is about, at what simulation time it was saved (here
0 seconds), what the id, step and stage is. It further shows the
<tt class="docutils literal"><span class="pre">field</span> <span class="pre">unit</span></tt> and the <tt class="docutils literal"><span class="pre">position</span> <span class="pre">unit</span></tt>. These give the physical
dimensions with which the numerical quantities from the table have to
be multiplied to get dimensionful physical quantities. For example,
the positions in the table are provided as <tt class="docutils literal"><span class="pre">(0,0,0)</span></tt>, <tt class="docutils literal"><span class="pre">(3,0,0)</span></tt>,
<tt class="docutils literal"><span class="pre">(6,0,0)</span></tt> etc. These numbers have to be multiplied by
`` &lt;SI: 1e-09 m &gt; `` = 1e-9 meters to obtain the actual positions
in SI units. In other words, the position coordinate data is expressed in
nanometers. In this particular example, the field data -- the normalised
magnetisation -- is dimensionless.</p>
<p>Followed by the keyword <tt class="docutils literal"><span class="pre">#Start</span></tt> the actual data starts (in the next
line).  The format of the subsequent data lines is as follows:</p>
<ul class="simple">
<li>Column 1: index of the site in the h5 file. This mostly relevant for
developers.</li>
<li>Column 2: the index of the site. As long as we are dealing with
first order basis functions (as is nearly always the case in
micromagnetics), this is equivalent to the node id in the mesh.</li>
<li>Columns 3, 4, 5: enclosed in parentheses, the position of the site
is expressed in units of the <tt class="docutils literal"><span class="pre">position</span> <span class="pre">unit</span></tt>.</li>
<li>Columns 6, 7, 8: enclosed in parentheses, the actual field data
expressed in units of the <tt class="docutils literal"><span class="pre">field</span> <span class="pre">unit</span></tt>.</li>
</ul>
<p>In short, the first line of the actual data:</p>
<pre class="literal-block">
0:   0 : (  0,  0,  0) : (    0.707107,            0,     0.707107)
</pre>
<p>tells us that the normalised magnetisation at node id <tt class="docutils literal"><span class="pre">0</span></tt>, and
position <tt class="docutils literal"><span class="pre">(0,0,0)</span> <span class="pre">nm</span></tt> is pointing in the direction
<tt class="docutils literal"><span class="pre">(0.707107,0,0.707107)</span></tt>.</p>
<p>Another example: Suppose we are interested in the magnetisation field
<tt class="docutils literal"><span class="pre">M</span></tt> (this is the non-normalised magnetisation measured in Ampere per
meter) at time 1e-10 seconds (i.e. id=20). We use this
command:</p>
<pre class="literal-block">
nmagpp --fields M --dump --range 20 bar
</pre>
<p>to obtain output beginning like this:</p>
<pre class="literal-block">
field    : m
subfield : m_Py
time     : 1e-10 * &lt;SI: 1  s &gt;
id       : 20
step     : 495
stage    : 1
field unit: &lt;SI: 1  &gt;
position unit: &lt;SI: 1e-09  m &gt;
row: 2
#Start (index in h5 table, dofsite, pos, data)
   0          0 (           0            0            0 ) (    0.182556     0.525948     0.830694 )
   1          1 (           3            0            0 ) (    0.165008     0.534525     0.828888 )
   2          2 (           6            0            0 ) (    0.104837     0.544846     0.831957 )
   3          3 (           9            0            0 ) (    0.029925     0.552054     0.833272 )
   4
</pre>
<p>In principle, this output data can be parsed by other tools to extract
the positions and the data. However, it is hoped that other options of
the nmagpp tool (such as the <tt class="docutils literal"><span class="pre">--vtk</span></tt> switch ) already cover most of
the situations where the need to convert data may arise. (If you would
like to export the raw data into another file format or application,
please contact the <a class="reference internal" href="manual.html#nmag-team">nmag team</a> to request this feature, as it may be
of interest to other people as well.)</p>
<p>It is further possible to access the data in the <tt class="docutils literal"><span class="pre">_dat.h5</span></tt> files
directly from tailor written post-processing scripts. See <a class="reference internal" href="manual.html#example-post-processing-of-saved-field-data">example:
post processing of saved field data</a>.</p>
</div>
<div class="section" id="range-of-data-to-be-processed">
<h3><a class="toc-backref" href="manual.html#id183">6.2.3&nbsp;&nbsp;&nbsp;Range of data to be processed</a></h3>
<p>The <tt class="docutils literal"><span class="pre">--range</span></tt> switch allows a variety of ways to express which of
the <tt class="docutils literal"><span class="pre">ids</span></tt> in the data file should be selected (for dumping to the
screen, or conversion to a vtk file). Here are some examples:</p>
<pre class="literal-block">
--range 17                        #will select 17
--range &quot;range(5,10)&quot;             #will select [5,6,7,8,9]
--range &quot;[2,5,10,42]&quot;             #will select [2,5,10,42]
--range &quot;range(10)+[20,25,31,42]&quot; #will select [0,1,2,3,...,9,10,20,25,31,42]
--range &quot;max(ids)&quot;                #will select the last saved id
</pre>
</div>
<div class="section" id="conversion-to-vtk-file">
<h3><a class="toc-backref" href="manual.html#id184">6.2.4&nbsp;&nbsp;&nbsp;Conversion to vtk file</a></h3>
<p>The command</p>
<blockquote>
nmagpp --range 0 --vtk test.vtk bar</blockquote>
<p>will take the dataset with <tt class="docutils literal"><span class="pre">id``=0</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">``bar_dat.h5</span></tt> file and convert it
to a (binary) vtk file with name <tt class="docutils literal"><span class="pre">test.vtk</span></tt>. For vtk files, the
default is to convert all fields. However, if a field (or a list of fields) is specified
using the <tt class="docutils literal"><span class="pre">--field</span></tt> option, then only this field is converted. This
may be useful if disk space or conversion time is an issue.</p>
<p>We can convert multiple time steps into a set of vtk files with one
command. For example, to convert for all saved configurations all
fields into vtk files, use:</p>
<pre class="literal-block">
nmagpp --vtk alltest.vtk bar
</pre>
<p>This will create files <tt class="docutils literal"><span class="pre">alltest-000000.vtk</span></tt>, <tt class="docutils literal"><span class="pre">alltest-000010.vtk</span></tt>,
<tt class="docutils literal"><span class="pre">alltest-000020.vtk</span></tt>, <tt class="docutils literal"><span class="pre">alltest-000030.vtk</span></tt>, <tt class="docutils literal"><span class="pre">alltest-000040.vtk</span></tt>,
<tt class="docutils literal"><span class="pre">alltest-000050.vtk</span></tt>, and <tt class="docutils literal"><span class="pre">alltest-000060.vtk</span></tt>.</p>
<p>The conversion to vtk can be combined with the <tt class="docutils literal"><span class="pre">--range</span></tt> command.
(See  <a class="reference internal" href="manual.html#range-of-data-to-be-processed">Range of data to be processed</a>). For example, to convert every
second saved configuration (i.e. ids 0, 20, 40) into vtk files, we could use:</p>
<pre class="literal-block">
nmagpp --range &quot;range(0,60,20)&quot; --vtk x.vtk bar
</pre>
<p>The string &quot;range(0,60,20)&quot; is a Python expression and will evaluate
to [0,20,40] (because it is the list of integers starting from 0,
going up to [but not including] 60, in steps of 20). This will create
files <tt class="docutils literal"><span class="pre">x-000000.vtk</span></tt>, <tt class="docutils literal"><span class="pre">x-000020.vtk</span></tt> and <tt class="docutils literal"><span class="pre">x-000040.vtk</span></tt>.</p>
</div>
<div class="section" id="other-features">
<h3><a class="toc-backref" href="manual.html#id185">6.2.5&nbsp;&nbsp;&nbsp;Other features</a></h3>
<p>Use:</p>
<blockquote>
nmagpp --help</blockquote>
<p>to get an overview of other features of nmag, and further details.</p>
</div>
</div>
<div class="section" id="nmeshpp">
<h2><a class="toc-backref" href="manual.html#id186">6.3&nbsp;&nbsp;&nbsp;nmeshpp</a></h2>
<p>The <tt class="docutils literal"><span class="pre">nmeshpp</span></tt> program is the NMESHPreProcesser and NMESHPostProcessor.
It provides quick access to some statistical information
about nmesh meshes. The basic usage is</p>
<blockquote>
<tt class="docutils literal"><span class="pre">nmeshpp</span> <span class="pre">[OPTIONS]</span> <span class="pre">INPUTFILE</span> <span class="pre">[OUTPUTFILE]</span></tt></blockquote>
<p>where <tt class="docutils literal"><span class="pre">INPUT</span></tt> is the name of a nmesh file (either in ascii or hdf5
format), <tt class="docutils literal"><span class="pre">OUTPUTFILE</span></tt> is the name of the file to be written to (if
required; this depends on the <tt class="docutils literal"><span class="pre">OPTIONS</span></tt>) and OPTIONS can be one or
several of the options listed in the following subsections. We use the
mesh file <a class="reference external" href="../example2/bar30_30_100.nmesh.h5">bar30_30_100.nmesh.h5</a> from <a class="reference internal" href="manual.html#example-2">Example 2</a> to
illustrate the usage of <a class="reference internal" href="manual.html#nmeshpp">nmeshpp</a>.</p>
<div class="section" id="general-information-info">
<h3><a class="toc-backref" href="manual.html#id187">6.3.1&nbsp;&nbsp;&nbsp;General information (<tt class="docutils literal"><span class="pre">--info</span></tt>)</a></h3>
<p>The command:</p>
<pre class="literal-block">
nmeshpp --info bar30_30_100.nmesh.h5
</pre>
<p>produces the following output:</p>
<pre class="literal-block">
====== Info output: ========================================================
3-dimensional mesh
18671 volume elements (3d)
 3438 surface elements (2d)
 4086 points
    1 simplex regions ([1])
    2 point regions ([-1, 1])
    2 region volumes ([0.0, 89999.999999999782])
 1721 boundary points (-&gt; BEM size&lt;=  22MB)
    0 periodic points (mirage=0, total=0)
a0: average=3.543451, std=0.581220, min=1.953689, max=5.708395
</pre>
<p>Starting from the top of the output, we are given the information that
this is a three-dimensional mesh, with its number of <em>volume elements</em>
(i.e. tetrahedra in 3d), <em>surface elements</em> (i.e. surface triangles) and
<em>points</em>.</p>
<p>We are also given a list of <em>simplex regions</em> (which is just [1]
here). If we had more than one region defined (say two disconnected
spheres that are to be associated with different material), then we
would have two entries here. The numbers given in this list are the
identifiers of the regions: in this example there is only one region
and it has the identifier 1.</p>
<p>The <em>point regions</em> is a list of all regions in which points are
located. This includes of course region 1. Region -1 represents the
vacuum around the meshed region. The points that are located on the
surface of the bar are located both in the bar (region 1) and in the
vacuum (region -1). Other negative region numbers (-2, -3) can be used
to discern different pieces of a boundary. (While this feature is at
present not used by Nmag, the underlying nsim framework provides
capabilities to e.g. associate Dirichlet boundary conditions to a
1/-1 boundary and von Neumann boundary conditions to a 1/-2 boundary.)</p>
<p>The <em>region volumes</em> provide the geometrical volume of the regions. By
convention, the vacuum has volume 0. In this example, the bar volume
is meant to be 30x30x100=90000. The deviation from this due to limited
numerical precision (and of the order of 1e-10).</p>
<p>The <em>boundary points</em> are the number of nodes located at the surface
of the bar. This number is important if using the hybrid finite
element/boundary element method to compute the demagnetisation field,
as the boundary element matrix size will be proportional to the square
of the number of boundary points. The size of the boundary element
matrix is given as well (see <a class="reference internal" href="manual.html#memory-requirements-of-boundary-element-matrix">memory requirements of boundary element matrix</a>).</p>
<p>The <em>periodic points</em> are the number of points that have <em>mirage
images</em> in the mesh. There will always be zero periodic points (and
thus zero mirage images) unless we are dealing with a periodic mesh
(see <a class="reference internal" href="manual.html#nmeshmirror">nmeshmirror</a> and <a class="reference internal" href="manual.html#example-spin-waves-in-periodic-system">Example: Spin-waves in periodic system</a>).</p>
<p>Finally, we are given some information about the statistics of the
edge lengths <em>a0</em> in the mesh: the average value, the standard
deviation, the maximum and minimum value. This is important as in
micromagnetics the angle of the magnetisation must not vary strongly
from one node to the next. In practice, the edge length a0 should
therefore be (significantly) smaller than the exchange length (see
<a class="reference internal" href="manual.html#what-size-of-the-cells-fd-and-tetrahedra-fe-should-i-choose">What size of the cells (FD) and tetrahedra (FE) should I choose?</a>)</p>
</div>
<div class="section" id="memory-requirements-of-boundary-element-matrix">
<h3><a class="toc-backref" href="manual.html#id188">6.3.2&nbsp;&nbsp;&nbsp;Memory requirements of boundary element matrix</a></h3>
<p>The boundary element matrix is densely populated matrix with s rows
and s columns, where s is the number of surface nodes in the
mesh. (Strictly, it is only the number of surface nodes that enclose a
ferromagnetic material.) Assuming we use 8 bytes to store one floating
point number, we can thus estimate the memory required to store this
matrix. In the example above, we have 1721 boundary points, and thus
1721*1721=2961841 matrix entries. Each entry requires 8 byte, so the
total memory requirement is 23694728 bytes, or approximately 23139
kilobytes or 23 megabytes.</p>
<p>The <tt class="docutils literal"><span class="pre">nmeshpp</span> <span class="pre">-i</span></tt> command can be used to quickly check how big the
BEM matrix is. A computation is only feasible if the RAM of the
computer can hold the boundary element matrix. (When carrying out a
distributed calculation, it is sufficient if the total RAM of all
machines can hold the matrix.)</p>
</div>
<div class="section" id="inspecting-the-quality-of-a-mesh">
<h3><a class="toc-backref" href="manual.html#id189">6.3.3&nbsp;&nbsp;&nbsp;Inspecting the quality of a mesh</a></h3>
<p>The quality of a mesh can be defined in various ways. In
micromagnetics, we usually want tetrahedra that have edges of nearly
identical length (i.e. we do not want the tetrahedra to be flat).</p>
<p><tt class="docutils literal"><span class="pre">nmeshpp</span></tt> uses the ratio of the radius of the in-sphere (the sphere
that can just fit into a tetrahedron so that it touches the sides) to
radius of the circumsphere (the sphere passing through the four corners),
multiplied by the number of dimensions. This number is 1.0 for a
perfect tetrahedron with identical edge lengths, and 0 for a
completely flat (effectively 2-dimensional) tetrahedron.</p>
<p>The command:</p>
<pre class="literal-block">
nmeshpp -q bar30_30_100.nmesh.h5
</pre>
<p>computes a histogram of the distribution of this quality parameter for
the bar mesh, and produces this output:</p>
<pre class="literal-block">
====== Quality output: ======================================================
[qual interval] counts = probability
[ 0.000- 0.100]      0 = 0.00%
[ 0.100- 0.200]      0 = 0.00%
[ 0.200- 0.300]      0 = 0.00%
[ 0.300- 0.400]      0 = 0.00%
[ 0.400- 0.500]      1 = 0.01% *
[ 0.500- 0.600]     42 = 0.22% *
[ 0.600- 0.700]    364 = 1.95% **
[ 0.700- 0.800]   2420 =12.96% ************
[ 0.800- 0.900]   8252 =44.20% ****************************************
[ 0.900- 1.000]   7592 =40.66% *************************************
</pre>
</div>
<div class="section" id="histogram-of-edge-lengths">
<h3><a class="toc-backref" href="manual.html#id190">6.3.4&nbsp;&nbsp;&nbsp;Histogram of edge lengths</a></h3>
<p>The command:</p>
<pre class="literal-block">
nmeshpp -a bar30_30_100.nmesh.h5
</pre>
<p>computes a histogram of the edge length distribution of the mesh:</p>
<pre class="literal-block">
====== a0 output: ===========================================================
[a0   interval] counts = probability
[ 1.954- 2.329]    234 = 0.63% **
[ 2.329- 2.705]   1424 = 3.81% *******
[ 2.705- 3.080]   7921 =21.17% *************************************
[ 3.080- 3.456]   8790 =23.50% ****************************************
[ 3.456- 3.831]   7573 =20.24% ***********************************
[ 3.831- 4.207]   5884 =15.73% ***************************
[ 4.207- 4.582]   3769 =10.08% ******************
[ 4.582- 4.957]   1385 = 3.70% *******
[ 4.957- 5.333]    365 = 0.98% **
[ 5.333- 5.708]     63 = 0.17% *

average   a0: &lt;a0&gt;   = 3.543451
stand dev a0: &lt;a0^2&gt; = 0.581220^2
min and max :        =(1.953689,5.708395)
</pre>
</div>
</div>
<div class="section" id="convert-nmesh-h5-to-nmesh-file-and-back">
<h2><a class="toc-backref" href="manual.html#id191">6.4&nbsp;&nbsp;&nbsp;Convert nmesh.h5 to nmesh file (and back)</a></h2>
<p>The command:</p>
<pre class="literal-block">
nmeshpp -c mesh.nmesh.h5 mesh.nmesh
</pre>
<p>converts a the mesh <tt class="docutils literal"><span class="pre">mesh.nmesh.h5</span></tt> (in h5 format) to the <tt class="docutils literal"><span class="pre">mesh.nmesh</span></tt> (in ascii format). Works also in the reverse way. <tt class="docutils literal"><span class="pre">nmeshpp</span></tt> will save as <tt class="docutils literal"><span class="pre">h5</span></tt> file in the last extension of the file to write is <tt class="docutils literal"><span class="pre">.h5</span></tt>.</p>
<div class="section" id="nmeshmirror">
<h3><a class="toc-backref" href="manual.html#id192">6.4.1&nbsp;&nbsp;&nbsp;nmeshmirror</a></h3>
<p>The <tt class="docutils literal"><span class="pre">nmeshmirror</span></tt> tool can create periodic meshes out of a non-periodic mesh. The geometry described by the non-periodic mesh has to
be a cuboid. This can be mirrored along one (or more) of the planes
defined by the sides of the cuboid.</p>
<p>The general usage is</p>
<pre class="literal-block">
nmeshmirror meshfile error1 error2 directions newfile remove
</pre>
<p>where:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">meshfile</span></tt> is the original (non-periodic) ASCII nmesh file</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">error1</span></tt> is the maximum distance between two points in
order to consider them coincident (case of points on mirroring planes)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">error2</span></tt> is the maximum distance between a point and the surface
opposite to the one used as mirroring plane in order to consider the
point periodic</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">directions</span></tt> is a list of values 0,1 or -1, corresponding to the
direction(s) over which the mesh is mirrored: 1 corresponds to
mirroring along the positive given axis, -1 along the negative given
axis and 0 corresponds to no mirroring along the given axis.</p>
<p>For a three dimensional mesh, there are three options to mirror the
mesh (along the x, y and z direction). In that case, the
<tt class="docutils literal"><span class="pre">directions</span></tt> would be a list of three integers, for example
<tt class="docutils literal"><span class="pre">0,1,0</span></tt> to mirror the input mesh on the xz plane that limits the
mesh in the y direction.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">newfile</span></tt> is the name of the ASCII file with the new periodic mesh</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">remove</span></tt> is an optional argument which takes the values 0 and 1
and removes the periodic points from the final mesh when is set to 1.
The default value is 0.</p>
</li>
</ul>
<p>Calling <tt class="docutils literal"><span class="pre">orig.nmesh</span></tt> the ASCII file of a 3D non-periodic mesh, an example
of the use of nmeshmirror is the following, where the mesh is mirrored
along the positive x-axis and the negative z-axis:</p>
<pre class="literal-block">
nmeshmirror orig.nmesh 1e-6 1e-6 1,0,-1 periodic.nmesh
</pre>
<p>resulting in a periodic mesh along the same axes.</p>
</div>
<div class="section" id="nmeshsort">
<h3><a class="toc-backref" href="manual.html#id193">6.4.2&nbsp;&nbsp;&nbsp;nmeshsort</a></h3>
<p>The <tt class="docutils literal"><span class="pre">nmeshsort</span></tt> script sorts the nodes of a mesh along a given axis
(not recommended when using parmetis with multiple-object meshes). We
expect this to be most relevant to developers.</p>
<p>The general usage is</p>
<pre class="literal-block">
nmeshsort meshfile axis newfile
</pre>
<p>where:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">meshfile</span></tt> is the original ASCII nmesh file</li>
<li><tt class="docutils literal"><span class="pre">axis</span></tt> is the axis over which the sorting takes place</li>
<li><tt class="docutils literal"><span class="pre">newfile</span></tt> is the name of the ASCII file with the new periodic mesh</li>
</ul>
<p>Calling <tt class="docutils literal"><span class="pre">orig.nmesh</span></tt> the ASCII file of a 3D mesh, an example
of the use of nmeshsort is the following, where the mesh is sorted
along the z-axis:</p>
<pre class="literal-block">
nmeshsort orig.nmesh 2 sorted.nmesh
</pre>
</div>
</div>
<div class="section" id="nmeshimport">
<h2><a class="toc-backref" href="manual.html#id194">6.5&nbsp;&nbsp;&nbsp;nmeshimport</a></h2>
<p>The <a class="reference internal" href="manual.html#nmeshimport">nmeshimport</a> command can be used to read other mesh formats and write them into the nmesh format that can be read by nmag.</p>
<p>The <tt class="docutils literal"><span class="pre">nmeshimport</span></tt> tool can convert <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a>, Gambit and <a class="reference external" href="http://www.geuz.org/gmsh/">Gmsh</a> files
into nmesh files.</p>
<p>The general usage is:</p>
<pre class="literal-block">
nmeshimport OPTIONS INPUTFILE NMESHFILE
</pre>
<p>The OPTION to import from <a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> is <tt class="docutils literal"><span class="pre">--netgen</span></tt>. The (contributed)
code for importing from a Gambit mesh file is <tt class="docutils literal"><span class="pre">--gambit</span></tt>.
The OPTION to import from <a class="reference external" href="http://www.geuz.org/gmsh/">Gmsh</a> is <tt class="docutils literal"><span class="pre">--gmsh</span></tt>.</p>
<p>Usage example: assuming we have a file <tt class="docutils literal"><span class="pre">mymesh.neutral</span></tt> created with
<a class="reference external" href="http://www.hpfem.jku.at/netgen/">Netgen</a> and would like to convert it to <tt class="docutils literal"><span class="pre">mymesh.nmesh.h5</span></tt>, we could
use this command:</p>
<pre class="literal-block">
nmeshimport --netgen mymesh.neutral mymesh.nmesh.h5
</pre>
<p>Use:</p>
<pre class="literal-block">
nmeshimport --help
</pre>
<p>to see all available features.</p>
</div>
<div class="section" id="nsim">
<h2><a class="toc-backref" href="manual.html#id195">6.6&nbsp;&nbsp;&nbsp;nsim</a></h2>
<p>This is the main executable. It superficially appears to be a Python
interpreter, but has extended functionality. In particular, it has
support for parallel execution (using MPI), and contains extensions
accessible in the additional built-in <tt class="docutils literal"><span class="pre">ocaml</span></tt> module which provides
the additional functionality of the nsim multiphysics
system. (Nmag is a Python library on top of nsim, which itself is
implemented in Objective Caml.)</p>
</div>
<div class="section" id="nsimversion">
<h2><a class="toc-backref" href="manual.html#id196">6.7&nbsp;&nbsp;&nbsp;nsimversion</a></h2>
<p>A script that provides some information about the version of the
software. If you need to report a bug/problem, please include the
output of this program.</p>
</div>
</div>
<div class="section" id="files-and-file-names">
<h1><a class="toc-backref" href="manual.html#id197">7&nbsp;&nbsp;&nbsp;Files and file names</a></h1>
<div class="section" id="mesh-files-nmesh-nmesh-h5">
<h2><a class="toc-backref" href="manual.html#id198">7.1&nbsp;&nbsp;&nbsp;mesh files (<tt class="docutils literal"><span class="pre">.nmesh</span></tt>, <tt class="docutils literal"><span class="pre">.nmesh.h5</span></tt>)</a></h2>
<p>Files that contain a finite element mesh. See <a class="reference internal" href="manual.html#nmesh-file-format">Nmesh file format</a>.</p>
</div>
<div class="section" id="simulation-scripts-py">
<h2><a class="toc-backref" href="manual.html#id199">7.2&nbsp;&nbsp;&nbsp;Simulation scripts (<tt class="docutils literal"><span class="pre">.py</span></tt>)</a></h2>
<p>Files that contain simulation program code. The ending is (by
convention) <tt class="docutils literal"><span class="pre">.py</span></tt> which reflects that the programming language used
is Python.</p>
<p>All the example codes provided in the <a class="reference internal" href="manual.html#guided-tour">Guided tour</a> are such simulation scripts.</p>
</div>
<div class="section" id="data-files-ndt">
<span id="ndt"></span><h2><a class="toc-backref" href="manual.html#id200">7.3&nbsp;&nbsp;&nbsp;Data files (<tt class="docutils literal"><span class="pre">.ndt</span></tt>)</a></h2>
<p><tt class="docutils literal"><span class="pre">ndt</span></tt> stands for Nmag Data Table, analog to <tt class="docutils literal"><span class="pre">odt</span></tt> files (<a class="reference external" href="http://math.nist.gov/oommf/">OOMMF</a>
Data Table) for the OOMMF project. In fact, <tt class="docutils literal"><span class="pre">ndt</span></tt> and <tt class="docutils literal"><span class="pre">odt</span></tt> files
are very similar.</p>
<p><tt class="docutils literal"><span class="pre">ndt</span></tt> files are ascii files where each row corresponds to one time
step (or, more generally, configuration of the system). The columns
contain:</p>
<ul class="simple">
<li>metadata such as<ul>
<li>a unique identifier for every row</li>
<li>the time at which the row was written</li>
</ul>
</li>
<li>(spatially) averaged <a class="reference internal" href="manual.html#field">field</a> data</li>
</ul>
<p>The first two lines contain information about what data is stored in the various columns:</p>
<blockquote>
<ol class="arabic simple">
<li>The first line provides a header</li>
<li>The second line provides the SI units</li>
</ol>
</blockquote>
<p>All other lines contain the actual data.</p>
<p>The file can be loaded into any data processing software (such as MS
Excel, Origin, Matlab, Gnuplot, ...). However, often it is more
convenient to use the <a class="reference internal" href="manual.html#ncol">ncol</a> tool to select the relevant columns, and
only to pass the filtered data to a post-processing (e.g. plotting)
program.</p>
<p>Data is written into the <tt class="docutils literal"><span class="pre">ndt</span></tt> file whenever the <a class="reference internal" href="manual.html#save-data">save_data</a> method
of the simulation object is called.</p>
</div>
<div class="section" id="data-files-h5">
<span id="h5-data-file"></span><span id="h5-data-files"></span><h2><a class="toc-backref" href="manual.html#id201">7.4&nbsp;&nbsp;&nbsp;Data files (<tt class="docutils literal"><span class="pre">.h5</span></tt>)</a></h2>
<p>The <tt class="docutils literal"><span class="pre">h5</span></tt> data files store spatially resolved <a class="reference internal" href="manual.html#fields">fields</a>. The format is
a binary and compressed <a class="reference external" href="http://www.hdfgroup.org/">hdf5</a> format to which we have convenient
access via the <a class="reference external" href="http://www.pytables.org/">pytables</a> package for Python. The user should not have
to worry about reading this file directly, but use the <a class="reference internal" href="manual.html#nmagpp">nmagpp</a> tool to
access the data.</p>
</div>
<div class="section" id="file-names-for-data-files">
<h2><a class="toc-backref" href="manual.html#id202">7.5&nbsp;&nbsp;&nbsp;File names for data files</a></h2>
<p>The filenames for the <a class="reference internal" href="manual.html#ndt">ndt</a> and <a class="reference internal" href="manual.html#h5-data-files">h5 data files</a> are given by
concatenation of the <em>simulation name</em>, the extension <tt class="docutils literal"><span class="pre">_dat.</span></tt> and
the extension (<tt class="docutils literal"><span class="pre">.h5</span></tt> or <tt class="docutils literal"><span class="pre">.ndt</span></tt>).</p>
<p>When a simulation object is created, for example in a file called
<tt class="docutils literal"><span class="pre">mybar.py</span></tt> starting like this:</p>
<pre class="literal-block">
import nmag
sim = nmag.Simulation(name=&quot;bar&quot;)
</pre>
<p>then the simulation name is <tt class="docutils literal"><span class="pre">bar</span></tt>.</p>
<p>If no name is provided, i.e. the file <tt class="docutils literal"><span class="pre">mybar.py</span></tt> starts like this:</p>
<pre class="literal-block">
import nmag
sim = nmag.Simulation()
</pre>
<p>then the simulation name will be the <em>run id</em>. The <em>run id</em> is the
filename of the simulation script (without the <tt class="docutils literal"><span class="pre">.py</span></tt> extension),
i.e. the simulation name then will be <tt class="docutils literal"><span class="pre">mybar</span></tt>.</p>
<p>Let us assume for the rest of this section that the simulation name
is <tt class="docutils literal"><span class="pre">bar</span></tt>.  Once we use the <a class="reference internal" href="manual.html#save-data">save_data</a> command, for example like this:</p>
<pre class="literal-block">
sim.save_data()
</pre>
<p>an <tt class="docutils literal"><span class="pre">ndt</span></tt> file will be created, with name <tt class="docutils literal"><span class="pre">bar_dat.ndt</span></tt> (= <tt class="docutils literal"><span class="pre">bar</span></tt>
+ <tt class="docutils literal"><span class="pre">_dat.</span></tt> + <tt class="docutils literal"><span class="pre">ndt</span></tt>).</p>
<p>Similarly, if we write the fields spatially resolved:</p>
<pre class="literal-block">
sim.save_data(fields='all')
</pre>
<p>a <a class="reference internal" href="manual.html#h5-data-file">h5 data file</a> with name <tt class="docutils literal"><span class="pre">bar_dat.h5</span></tt> (= <tt class="docutils literal"><span class="pre">bar</span></tt> + <tt class="docutils literal"><span class="pre">_dat.</span></tt> + <tt class="docutils literal"><span class="pre">h5</span></tt>)
will be created.</p>
</div>
<div class="section" id="file-names-for-log-files">
<h2><a class="toc-backref" href="manual.html#id203">7.6&nbsp;&nbsp;&nbsp;File names for log files</a></h2>
<p>A log file is created that stores (most of) the messages displayed to
stdout (i.e. the screen). The name of the log file starts with the
name of the simulation script (without the <tt class="docutils literal"><span class="pre">.py</span></tt> extension), and ends with <tt class="docutils literal"><span class="pre">_log.log</span></tt>.</p>
<p>For example, a simulation script with name <tt class="docutils literal"><span class="pre">mybar.py</span></tt> will have an
associated log file with name <tt class="docutils literal"><span class="pre">mybar_log.log</span></tt>.</p>
<p>Another three files will be created if the (undocumented)
<tt class="docutils literal"><span class="pre">--dumpconf</span></tt> switch is provided. This are primarily of use to the
developers and can usually be ignored:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">mybar_log.conf</span></tt>:
This can be used to configure what data is logged.</li>
<li><tt class="docutils literal"><span class="pre">mybar_ocaml.conf</span></tt>:
Configuration of some variables used in the ocaml code</li>
<li><tt class="docutils literal"><span class="pre">mybar_nmag.conf</span></tt>:
Some variables used in the nmag code</li>
</ul>
<!-- comment :.. _FAQ: -->
</div>
</div>
<div class="section" id="frequently-asked-questions">
<h1><a class="toc-backref" href="manual.html#id204">8&nbsp;&nbsp;&nbsp;Frequently Asked Questions</a></h1>
<div class="contents local topic" id="contents">
<ul class="auto-toc simple">
<li><a class="reference internal" href="manual.html#what-is-the-difference-between-the-oommf-and-nmag-approach" id="id229">8.1&nbsp;&nbsp;&nbsp;What is the difference between the OOMMF and nmag approach?</a></li>
<li><a class="reference internal" href="manual.html#so-this-means-the-major-difference-is-cubes-vs-tetrahedra" id="id230">8.2&nbsp;&nbsp;&nbsp;...So, this means the major difference is &quot;cubes&quot; vs. &quot;tetrahedra&quot;?</a></li>
<li><a class="reference internal" href="manual.html#why-do-you-have-your-own-python-interpreter-nsim" id="id231">8.3&nbsp;&nbsp;&nbsp;Why do you have your own Python interpreter (=``nsim``)?</a></li>
<li><a class="reference internal" href="manual.html#what-is-nsim-i-thought-the-package-is-called-nmag" id="id232">8.4&nbsp;&nbsp;&nbsp;What is nsim - I thought the package is called nmag?</a></li>
<li><a class="reference internal" href="manual.html#how-fast-is-nmag-in-comparison-to-magpar" id="id233">8.5&nbsp;&nbsp;&nbsp;How fast is nmag in comparison to magpar?</a></li>
<li><a class="reference internal" href="manual.html#how-do-i-start-a-time-consuming-nmag-run-in-the-background" id="id234">8.6&nbsp;&nbsp;&nbsp;How do I start a time-consuming nmag run in the background?</a></li>
<li><a class="reference internal" href="manual.html#nmag-claims-to-support-mpi-so-can-i-run-simulation-jobs-on-multiple-processors" id="id235">8.7&nbsp;&nbsp;&nbsp;nmag claims to support MPI. So, can I run simulation jobs on multiple processors?</a></li>
<li><a class="reference internal" href="manual.html#how-should-i-cite-nmag" id="id236">8.8&nbsp;&nbsp;&nbsp;How should I cite nmag?</a></li>
<li><a class="reference internal" href="manual.html#why-can-you-not-use-the-step-as-a-unique-identifier" id="id237">8.9&nbsp;&nbsp;&nbsp;Why can you not use the step as a unique identifier?</a></li>
<li><a class="reference internal" href="manual.html#how-to-generate-a-mesh-with-more-than-one-region-using-gmsh" id="id238">8.10&nbsp;&nbsp;&nbsp;How to generate a mesh with more than one region using GMSH?</a></li>
</ul>
</div>
<div class="section" id="what-is-the-difference-between-the-oommf-and-nmag-approach">
<h2><a class="toc-backref" href="manual.html#id229">8.1&nbsp;&nbsp;&nbsp;What is the difference between the OOMMF and nmag approach?</a></h2>
<p>There are several aspects. One important point is the calculation of
the demagnetisation field as this is a computationally very expensive step.</p>
<p><a class="reference external" href="http://math.nist.gov/oommf/">OOMMF</a> is based on discretising space into small cuboids (often called
'finite differences'). One advantage of this method is that the demag
field can be computed very efficiently (via fast Fourier
transformation techniques). One disadvantage is that this methods
works less well (i.e. less accurately) if the geometry shape does not
align with a cartesian grid as the boundary then is represented as a
staircase pattern.</p>
<p>nmag's finite elements discretise space into many small
tetrahedra. The corresponding approach towards the computation of the
demagnetisation field (which is the same as <a class="reference external" href="http://magnet.atp.tuwien.ac.at/scholz/magpar/">Magpar</a>'s method) is based
on the Fredkin and Koehler Hybrid Finite Element/Boundary Element
method. The advantage of this method (over OOMMF's approach) is that
curved and spherical geometries can be spatially resolved much more
accurately. However, this method of calculating the demagnetisation
field is less efficient than OOMMF's approach for thin films. (In
particular: memory requirements for the boundary element method grow
as the square of the number of surface points.) Note that for
simulation of thin films, the hybrid Finite Element/Boundary Element
(as used by nmag and <a class="reference external" href="http://magnet.atp.tuwien.ac.at/scholz/magpar/">Magpar</a>) is likely to require a lot of memory
(see <a class="reference internal" href="manual.html#memory-requirements-of-boundary-element-matrix">memory requirements of boundary element matrix</a>).</p>
<p>There are other points that are related to the fundamentally different
discretisation approach used to turn a field theory problem (with a
conceptually infinite number of degrees of freedom) into a finite
problem: OOMMF assumes the magnetisation in every cell to be constant
(with jumps at boundaries), while Nmag assumes magnetisation to be
continuous and vary linearly within cells (thus slightly violating the
constraint of constant magnitude within a cell of non-constant
magnetisation).</p>
</div>
<div class="section" id="so-this-means-the-major-difference-is-cubes-vs-tetrahedra">
<h2><a class="toc-backref" href="manual.html#id230">8.2&nbsp;&nbsp;&nbsp;...So, this means the major difference is &quot;cubes&quot; vs. &quot;tetrahedra&quot;?</a></h2>
<p>No. Simplicial mesh discretisation is fundamentally different from
finite-difference discretisation. With OOMMF, say, magnetisation
degrees of freedom are associated with the centers(!) of the cells,
while with nmag, they are associated with corners. This conceptual
difference has many implications, e.g. for the question how to
conceptually deal with the exchange interaction between different
materials.</p>
</div>
<div class="section" id="why-do-you-have-your-own-python-interpreter-nsim">
<h2><a class="toc-backref" href="manual.html#id231">8.3&nbsp;&nbsp;&nbsp;Why do you have your own Python interpreter (=``nsim``)?</a></h2>
<p>In order to provide the ability to run code in a distributed
environment (using MPI), we cannot use the standard Python
executable. (Technically speaking, a program started under MPI control
will receive extra MPI-related command line arguments which upset the
standard Python interpreter.) It so happens that -- by providing our
own Python executable which is called <tt class="docutils literal"><span class="pre">nsim</span></tt> -- we have easier
access to the low-level library of nsim which is written in
Objective Caml.</p>
</div>
<div class="section" id="what-is-nsim-i-thought-the-package-is-called-nmag">
<h2><a class="toc-backref" href="manual.html#id232">8.4&nbsp;&nbsp;&nbsp;What is nsim - I thought the package is called nmag?</a></h2>
<p>The <a class="reference internal" href="manual.html#nsim-library">nsim library</a> is our general purpose multi-physics simulation
environment. The corresponding executable is started through the <a class="reference internal" href="manual.html#nsim">nsim</a>
command. Nmag is a collection of scripts that provide micromagnetic
functionality on top of nsim. For this reason, nsim is being mentioned
a lot in the manual.</p>
</div>
<div class="section" id="how-fast-is-nmag-in-comparison-to-magpar">
<h2><a class="toc-backref" href="manual.html#id233">8.5&nbsp;&nbsp;&nbsp;How fast is nmag in comparison to magpar?</a></h2>
<p>Internally, some of the magpar and nmag core components are
structurally very similar. In particular, the time integration routine
is almost identical up to some philosophical issues such as how to
keep the length of the magnetisation vector constant, and whether or
not to use a symmetrical exchange matrix and a post-processing step
rather than combining these into an asymmetrical matrix, etc. The
actual wall clock time used will depend to a large degree on the
requested accuracy of the calculations (see <a class="reference internal" href="manual.html#example-timestepper-tolerances">example timestepper
tolerances</a>).</p>
<p>Given equivalent tolerance parameters, we have found (the
single-process version of) nmag to be about as fast as magpar. The
computation of an individual velocity dM/dt is very similar in nmag
and magpar, and about equally efficient. However, we observe that,
depending on the particular problem, subtle differences in the
philosophies underlying time integration can lead to noticeable
differences in the number of individual steps required to do some
particular simulation, which can be up to about 25% of simulation time
in either direction.</p>
<p>Setup time is a different issue: nmag derives its flexibility from
abstract approaches where magpar uses hard-coded compiled
functions. Where magpar uses a hand-coded Jacobian, nmag employs the
nsim core to symbolically compute the derivative of the equations of
motion. There is a trade-off: the flexibility of being able to
introduce another term into the equations of motion without having to
manually adjust the code for the Jacobian comes at a price in
execution time. Therefore, nmag's setup time at present is far larger
than magpar's. This can be alleviated to a considerable degree by
providing hard-coded &quot;bypass routines&quot; which can be used as
alternatives to the symbolically founded methods for special
situations that are frequently encountered (such as setting up a
Laplace operator matrix). Conceptually, it is easy to add support for
this but due to limited manpower, it has not happened yet.</p>
<p>In short: once the setup stage is over, nmag is about as fast as
magpar. Magpar's setup time, however, is much smaller.</p>
</div>
<div class="section" id="how-do-i-start-a-time-consuming-nmag-run-in-the-background">
<h2><a class="toc-backref" href="manual.html#id234">8.6&nbsp;&nbsp;&nbsp;How do I start a time-consuming nmag run in the background?</a></h2>
<p>While this is a Unix rather than a nmag issue, it comes up
sufficiently often to address it here.</p>
<p>Well-known techniques to run programs in the background are:</p>
<blockquote>
<ul>
<li><p class="first">Using the &quot;nohup&quot; (no-hangup) command, as in:</p>
<pre class="literal-block">
nohup nsim sphere1.py &amp;
</pre>
</li>
<li><p class="first">Using the at-daemon for scheduling of command execution at
given times:</p>
<pre class="literal-block">
at now
warning: commands will be executed using /bin/sh
at&gt; nsim example1.py
at&gt; &lt;EOT&gt;
job 2 at Fri Dec 14 12:08:00 2007
</pre>
</li>
<li><p class="first">Manual daemonization by using a parent process which forks &amp; exits,
as in:</p>
<pre class="literal-block">
perl -e 'exit(0) if fork(); exec &quot;nsim sphere1.py&quot;'
</pre>
<p>(But if you know Unix to that degree, you presumably would
not have asked in the first place.)</p>
</li>
<li><p class="first">One of the most elegant ways to start a process in the background
is by using the &quot;screen&quot; utility, which is installed on a number of
Unix systems. With &quot;screen&quot;, it becomes possible to start a text
terminal session in such a way that one can &quot;detach&quot; from it while
keeping the session alive, and even log out and log in again much
later and from a different machine, re-attaching the terminal
session and continuing work from the point where it was left.</p>
<p>While it is a good idea to read the documentation, most basic usage of
&quot;screen&quot; requires the knowledge of three commands only:</p>
<blockquote>
<ul class="simple">
<li>With &quot;screen -R&quot;, one can re-attach to a running session,
automatically creating a new one if none was created before.</li>
<li>Within a &quot;screen&quot; session, Control+a is a prefix keyboard command
for controlling &quot;screen&quot;: Pressing Control-a and then Control-d
will detach the session.</li>
<li>Control-a ? will being up a help screen showing all &quot;screen&quot;
keyboard commands.</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<!-- comment:
Furthermore, once one exits a shell which was started under "screen"
control, this will kill the "screen" session as well. -->
</div>
<div class="section" id="nmag-claims-to-support-mpi-so-can-i-run-simulation-jobs-on-multiple-processors">
<h2><a class="toc-backref" href="manual.html#id235">8.7&nbsp;&nbsp;&nbsp;nmag claims to support MPI. So, can I run simulation jobs on multiple processors?</a></h2>
<p>Yes. See <a class="reference internal" href="manual.html#example-parallel-execution-mpi">Example: Parallel execution (MPI)</a>.</p>
</div>
<div class="section" id="how-should-i-cite-nmag">
<h2><a class="toc-backref" href="manual.html#id236">8.8&nbsp;&nbsp;&nbsp;How should I cite nmag?</a></h2>
<p>For the time being, please cite:</p>
<ul class="simple">
<li>Thomas Fischbacher, Matteo Franchin, Giuliano Bordignon, and Hans
Fangohr.  <em>A Systematic Approach to Multiphysics Extensions of
Finite-Element-Based Micromagnetic Simulations: Nmag</em>, in IEEE
Transactions on Magnetics, <strong>43</strong>, 6, 2896-2898 (2007). (Available <a class="reference external" href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4202717">online</a>)</li>
</ul>
<p>A more substantial publication is in preparation.</p>
</div>
<div class="section" id="why-can-you-not-use-the-step-as-a-unique-identifier">
<h2><a class="toc-backref" href="manual.html#id237">8.9&nbsp;&nbsp;&nbsp;Why can you not use the step as a unique identifier?</a></h2>
<p>There are two reasons. Firstly, nmag may be extended in future to
support effective energy minimisation in which case the <tt class="docutils literal"><span class="pre">step</span></tt>
becomes somewhat meaningless (although it could probably still be used
as an identifier if we identify minimisation iterations with
steps). Secondly (and more importantly), in nmag, the user can modify
the magnetisation directly using <a class="reference internal" href="manual.html#set-m">set_m</a> (either scripted or
interactively). This will change the configuration of the system
without increasing the step counter of the time integrator. For this
reason, we have the <a class="reference internal" href="manual.html#unique-identifier-id">unique identifier id</a>.</p>
</div>
<div class="section" id="how-to-generate-a-mesh-with-more-than-one-region-using-gmsh">
<h2><a class="toc-backref" href="manual.html#id238">8.10&nbsp;&nbsp;&nbsp;How to generate a mesh with more than one region using GMSH?</a></h2>
<p>To assign different material properties to different objects, the mesher needs to assign different region number to different simplices of the mesh. The manual shows how to do this for netgen (see <a class="reference external" href="../example_two_materials/two_cubes.geo">two_cubes.geo</a>) file in example <a class="reference internal" href="manual.html#example-two-different-magnetic-materials">Example: two different magnetic materials</a>).</p>
<p>How does one define different regions using GMSH? User Xu Shu (Wuhan,
China) kindly provides this solution:</p>
<blockquote>
Within GMSH, one has to firstly &quot;add physical groups&quot; and choose the
two detached volumes separately to add them into different groups,
then choose &quot;edit&quot; to redefine the number of the two groups, thus you
can get two physical objects as you want.</blockquote>
</div>
</div>
<div class="section" id="useful-tools">
<h1><a class="toc-backref" href="manual.html#id215">9&nbsp;&nbsp;&nbsp;Useful tools</a></h1>
<div class="section" id="vtk">
<h2><a class="toc-backref" href="manual.html#id216">9.1&nbsp;&nbsp;&nbsp;vtk</a></h2>
<p>The homepage of the Visualisation ToolKit (vtk) is
<a class="reference external" href="http://www.vtk.org">http://www.vtk.org</a>. VTK provides is is an open source, freely
available software system for 3D computer graphics, image processing,
and visualization. It also provides a file-format which is called
'vtk'. A number of high-level user interfaces exist to visualise data
provided in such vtk files. These include:</p>
<ul class="simple">
<li><a class="reference internal" href="manual.html#mayavi">MayaVi</a> (<a class="reference external" href="http://mayavi.sourceforge.net/">http://mayavi.sourceforge.net/</a>)</li>
<li>VisIt (<a class="reference external" href="http://www.llnl.gov/visit/">http://www.llnl.gov/visit/</a>)</li>
<li>ParaView (<a class="reference external" href="http://www.paraview.org/">http://www.paraview.org/</a>)</li>
</ul>
</div>
<div class="section" id="mayavi">
<h2><a class="toc-backref" href="manual.html#id217">9.2&nbsp;&nbsp;&nbsp;MayaVi</a></h2>
<p>&quot;MayaVi is a free, easy to use scientific data visualizer. It is
written in Python and uses the Visualization Toolkit (VTK) for
graphical rendering. MayaVi is free and distributed under the
conditions of the BSD license. It is also cross platform and should
run on any platform where both Python and VTK are available (which is
almost any Unix, Mac OSX or Windows).&quot; The MayaVi web page is
<a class="reference external" href="http://mayavi.sourceforge.net/">http://mayavi.sourceforge.net/</a>.</p>
<p>MayaVi has been used to generate many of the plots in this manual.
Other tools are available for visualisation of vtk files (see <a class="reference internal" href="manual.html#vtk">vtk</a>).</p>
</div>
<div class="section" id="numpy">
<h2><a class="toc-backref" href="manual.html#id218">9.3&nbsp;&nbsp;&nbsp;NumPy</a></h2>
<p>Numerical Python (short <em>numpy</em>) is an extension library to Python
that provides fast array operations and is designed for numerical
work. This Python extension and documentation can be found at
<a class="reference external" href="http://numpy.scipy.org/">http://numpy.scipy.org/</a></p>
</div>
</div>
<div class="section" id="contact">
<h1><a class="toc-backref" href="manual.html#id219">10&nbsp;&nbsp;&nbsp;Contact</a></h1>
<p id="nmag-team">The nmag developer team can be contacted at
<tt class="docutils literal"><span class="pre">nmag&#64;soton.ac.uk</span></tt>.</p>
<p>Questions about the usage of nmag can also be send to the <a class="reference internal" href="manual.html#nmag-users">nmag-users</a> mailing list.</p>
</div>
<div class="section" id="mini-tutorial-micromagnetic-modelling">
<h1><a class="toc-backref" href="manual.html#id220">11&nbsp;&nbsp;&nbsp;Mini tutorial micromagnetic modelling</a></h1>
<p>This section is intended for researchers who are just beginning to
explore micromagnetic modelling. It is assumed that you have some
knowledge on micromagnetics. We advise to read this whole section, and
then to look the <a class="reference internal" href="manual.html#guided-tour">Guided tour</a> examples (or to explore other
<a class="reference internal" href="manual.html#micromagnetic-packages">micromagnetic packages</a> at that point).</p>
<div class="section" id="introduction-micromagnetic-modelling">
<h2><a class="toc-backref" href="manual.html#id221">11.1&nbsp;&nbsp;&nbsp;Introduction micromagnetic modelling</a></h2>
<p>To carry out micromagnetic simulations, a set of partial differential
equations have to be solved repeatedly. In order to be able to do
this, the simulated geometry has to be spatially discretised. The two
methods that are most widely spread in micromagnetic modelling are the
so-called finite difference (FD) method and the finite element (FE)
method. With either the FD or the FE method, we need to integrate the
Landau-Lifshitz and Gilbert equation numerically over time (this is a
coupled set of ordinary differential equations). All these
calculations are carried out by the <a class="reference internal" href="manual.html#micromagnetic-packages">micromagnetic packages</a> and the
user does not have to worry about these.</p>
<p>The finite difference method subdivides space into many small
cuboids. Sometimes the name <em>cell</em> is used to describe one of these
cuboids. (Warning: in finite difference simulations, the simulated
geometry is typically enclosed by a (big) cuboid which is also
referred to as <em>simulation cell</em>. Usually (!) it is clear from the
context which is meant.)  Typically, all simulation cells in one
finite difference simulation have the same geometry. A typical size
for such a cell could be a cube of dimensions 3nm by 3nm by 3nm.</p>
<p>Let's assume we would like to simulate a sphere. The following picture</p>
<div align="center" class="align-center"><img alt="../tutorial/fd.png" class="align-center" src="../tutorial/fd.png" /></div>
<p>shows an approximation of the shape of the sphere by cubes. This is
the finite difference approach. For clarity, we have chosen rather
large cubes to resolve the sphere -- in an actual simulation one would
typically use a much smaller cell size in order to resolve geometry
better.</p>
<p>On the other hand, the finite element method (typically) subdivides
space into many small tetrahedra. The tetrahedra are sometimes
referred to as the (finite element) mesh elements. Typically, the
geometry of these tetrahedra does vary throughout the simulated
region. This allows to combine the tetrahedra to approximate
complicated geometries.</p>
<p>Using tetrahedra, the a discretised sphere looks like this:</p>
<div align="center" class="align-center"><img alt="../tutorial/fe.png" class="align-center" src="../tutorial/fe.png" /></div>
<p>The spherical shape is approximated better than with the finite
differences.</p>
<p>The first step in setting up a micromagnetic simulation is to describe
the geometry. In the case of finite difference calculations, it will
depend on the package you use (currently there is only <a class="reference external" href="http://math.nist.gov/oommf/">OOMMF</a> freely
available) how to tell the package what geometry you would like to
use, and how small your simulation cells should be.</p>
<p>In the case of finite element calculations, you need to create a
finite element mesh (see <a class="reference internal" href="manual.html#finite-element-mesh-generation">Finite element mesh generation</a>).</p>
</div>
<div class="section" id="what-is-better-finite-differences-or-finite-elements">
<h2><a class="toc-backref" href="manual.html#id222">11.2&nbsp;&nbsp;&nbsp;What is better: finite differences or finite elements?</a></h2>
<p>This depends on what you want to simulate. Here are some points to consider.</p>
<ul>
<li><p class="first">Finite difference simulations are best when the geometry you
simulate is of rectangular shape (i.e. a cube, a beam, a geometry
composed of such objects, a T profile, etc). In these situations,
the finite element discretisation of the geometry will not yield any
advantage. (Assuming that the finite difference grid is aligned with
the edges in the geometry.)</p>
</li>
<li><p class="first">Finite difference simulations need generally less computer memory
(RAM). This is in particular the case if you simulate geometries
with a big surface (such as thin films). See <a class="reference internal" href="manual.html#memory-requirements-of-boundary-element-matrix">Memory requirements of
boundary element matrix</a> for a description of the memory
requirements of the hybrid finite element/boundary element simulations (both
Nmag and <a class="reference external" href="http://magnet.atp.tuwien.ac.at/scholz/magpar/">Magpar</a> are in this category).</p>
<p>(We state for completeness that there are techniques to
significantly reduce the memory footprint of the hybrid finite
element/boundary element method but these are not available in open
source micromagnetic code.)</p>
</li>
<li><p class="first">Finite element simulations are best suited to describe geometries
with some amount of curvature, or angles other than 90 degrees. For
such simulations, there is an error associated with the staircase
discretisation that finite difference approaches have to use. This
error is very much reduced when using finite elements.</p>
<p>(We state for completeness that there are techniques to reduce the
staircase effect in finite difference simulations but these are
currently not available in open source micromagnetic simulation
code.)</p>
</li>
<li><p class="first">For finite element simulations, the user has to create a finite
element mesh. This requires some practice (mostly to get used to a
meshing package), and in practice will take a significant amount of
the time required to set up a finite element simulation.</p>
</li>
</ul>
</div>
<div class="section" id="what-size-of-the-cells-fd-and-tetrahedra-fe-should-i-choose">
<h2><a class="toc-backref" href="manual.html#id223">11.3&nbsp;&nbsp;&nbsp;What size of the cells (FD) and tetrahedra (FE) should I choose?</a></h2>
<p>There are several things to consider:</p>
<ul class="simple">
<li>the smaller the cells or tetrahedra, the more accurate the
simulation results.</li>
<li>the smaller the cells or tetrahedra, the more cells and tetrahedra
are required to describe a geometry. Memory requirements and
execution time increase with the number of cells and tetrahedra. In
practice this will limit the size of the system that can be
simulated.</li>
</ul>
<!-- comment:
.. _`Max angle requirements`: -->
<ul>
<li><p class="first">the discretisation length (this is the edge length of the cells or
the tetrahedra) should be <em>much smaller than the exchange
length</em>. The reason for this is that in the derivation of the
micromagnetic (Brown's) equations, one assumes that the
magnetisation changes little in space (there is a Taylor expansion
for the exchange interaction). Therefore, we need to choose a
discretisation length so that the direction of the magnetisation
vectors varies little from one site (cell center in FD, node of
tetrahedron in FE) to the next. The difference of the magnetisation
vector is sometimes referred to as the 'spin angle': a spin angle of
0 degrees, means that the magnetisation at neighbouring sites points
in the same direction, whereas a spin angle of 180 degrees would mean
that they point in exactly opposite directions.</p>
<p>How much variation is acceptable, i.e. how big is the spin angle
allowed to be? It depends on the accuracy required. Some general
guidelines from  M Donahue [in email to H Fangohr on 26 March
2002 referring to OOMMF] which we fully endorse :</p>
<p><tt class="docutils literal"><span class="pre">[Begin</span> <span class="pre">quote</span> <span class="pre">M</span> <span class="pre">Donahue]</span></tt></p>
<ul class="simple">
<li>if the spin angle is approaching 180 degrees, then the results are
completely bogus.</li>
<li>over 90 degrees the results are highly questionable.</li>
<li>Under 30 degrees the results are probably reliable.</li>
</ul>
<p><tt class="docutils literal"><span class="pre">[end</span> <span class="pre">quote]</span></tt></p>
<p>It is <em>absolutely vital</em> that the spin angle does not become
excessive if the simulation results are to be trusted. (It is
probably the most common error in micromagnetics: one would like to
simulate a large geometry, thus one has to choose the discretisation
length large to get any results within reasonable time. However, the
results are often completely useless if the spin angle becomes too
large).</p>
<p>Because this is such an important issue, OOMMF -- for example --
provides <tt class="docutils literal"><span class="pre">Max</span> <span class="pre">Spin</span> <span class="pre">Ang</span></tt> data in its <tt class="docutils literal"><span class="pre">odt</span></tt> data table file (for
the current configuration, the last stage, and the overall
run). Nmag has a columns <tt class="docutils literal"><span class="pre">maxangle_m_X</span></tt> in the <a class="reference internal" href="manual.html#ndt">ndt</a> file that
provide this information (where <tt class="docutils literal"><span class="pre">X</span></tt> is the name of the magnetic
material).</p>
<p>You will probably find that often a discretisation length of half
the <a class="reference internal" href="manual.html#exchange-length">exchange length</a> or even about the <a class="reference internal" href="manual.html#exchange-length">exchange length</a> is
chosen. If the spin angle stays sufficiently low during the whole
simulation (including intermediate non-equilibrium configurations),
then this may be acceptable.</p>
<p>The ultimate test (recommended by -- among others -- M Donahue and the
nmag team) is the following:</p>
</li>
<li><p class="first">cell size dependence test</p>
<p>The best way to check whether the cell size has been chosen small
enough, is to perform a series of simulations with increasing cell
size. Suppose we are simulating Permalloy (Ni80Fe20 with Ms=8e5 A/m,
A=1.3e-11) and the <a class="reference internal" href="manual.html#exchange-length">exchange length</a> l<sub>1</sub> is about 5nm. Suppose further
we would like to use a cell size of 5nm for our simulations.</p>
<p>We should then carry out the same simulation with smaller cell
sizes, for example, 4nm, 3nm, 2nm, 1nm. Now we need to study
(typically plot) some (scalar) entity of the simulation (such as
the coercive field, or the remanence magnetisation) as a function of
the cell size.</p>
<p>Ideally, this entity should converge towards a constant value when
we reduce the simulation cell size below a critical cell size. This
critical cell size is the maximum cell size that should be used to
carry out the simulations.</p>
<p>Be aware that (i) it is often nearly impossible to carry out these
simulations at smaller cell sizes [because of a lack of
computational power] and (ii) this method is not 100% fool proof
[the observed entity may appear to converge towards a constant but
actually start changing again if the cell size is reduced even
further].</p>
<p>One should therefore treat the suggestions made above as advise on
good practice, but never solely rely on this. Critical examination
of the validity of simulation results is a fundamental part of any
simulation work.</p>
</li>
</ul>
<p>In summary, it is vital to keep the maximum spin angle small to obtain
accurate results. One should always (!) check the value of the spin
angle in the data files. One should also carry out a series of
simulations where the spin angle is reduced from one simulation to the
next while keeping all other parameters and the geometry the
same. This should reveal any changes in the results that depend on the
discretisation length.</p>
<div class="section" id="exchange-length">
<h3><a class="toc-backref" href="manual.html#id224">11.3.1&nbsp;&nbsp;&nbsp;Exchange length</a></h3>
<p>There is sometimes confusion about what equation should be used to
compute the exchange length. In this document, we refer to this
equation for soft materials (where the demagnetisation energy is
driving domain wall formation)</p>
<div align="center" class="align-center"><img alt="../tutorial/l_ex_soft.png" class="align-center" src="../tutorial/l_ex_soft.png" /></div>
<p>and this equation for hard materials (with uniaxial pinning) where the
crystal anisotropy governs domain wall lengths</p>
<div align="center" class="align-center"><img alt="../tutorial/l_ex_hard.png" class="align-center" src="../tutorial/l_ex_hard.png" /></div>
<p>If in doubt which of the two equations is the right one, compute both
l<sub>1</sub> and l<sub>2</sub> and choose the minimum length as the relevant exchange
length for this system.</p>
</div>
<div class="section" id="further-reading">
<h3><a class="toc-backref" href="manual.html#id225">11.3.2&nbsp;&nbsp;&nbsp;Further reading</a></h3>
<p>Micheal Donahue and co-workers have published a couple of papers on
the effect of cell size on vortex mobility:</p>
<blockquote>
<ul class="simple">
<li><a class="reference external" href="http://math.nist.gov/~MDonahue/publications.html#Donahue199606A">M. J. Donahue and R. D. McMichael, Physica B, 233, 272-278 (1997)</a></li>
<li><a class="reference external" href="http://math.nist.gov/~MDonahue/publications.html#Donahue20030528">M. J. Donahue and D. G. Porter, Physica B, 343, 177-183 (2004)</a></li>
</ul>
</blockquote>
<p>and one which included a section on discretisation-induced Neel wall
collapse</p>
<blockquote>
<ul class="simple">
<li><a class="reference external" href="http://math.nist.gov/~MDonahue/publications.html#Donahue199710">M. J. Donahue, Journal of Applied Physics, 83, 6491-6493 (1998)</a></li>
</ul>
</blockquote>
</div>
</div>
<div class="section" id="micromagnetic-packages">
<h2><a class="toc-backref" href="manual.html#id226">11.4&nbsp;&nbsp;&nbsp;Micromagnetic packages</a></h2>
<p>The following micromagnetic simulation packages are freely available on the internet:</p>
<blockquote>
<ul class="simple">
<li><a class="reference external" href="http://math.nist.gov/oommf/">OOMMF</a> (finite differences)</li>
<li><a class="reference external" href="http://magnet.atp.tuwien.ac.at/scholz/magpar/">Magpar</a> (finite elements)</li>
<li><a class="reference external" href="../../../../index.html">nmag</a> (finite elements)</li>
</ul>
</blockquote>
<p>These are general purpose packages. Some other (and partly closed
source/commercial packages) are listed at
<a class="reference external" href="http://math.nist.gov/oommf/otherlinks.html">http://math.nist.gov/oommf/otherlinks.html</a>.</p>
</div>
<div class="section" id="summary">
<h2><a class="toc-backref" href="manual.html#id227">11.5&nbsp;&nbsp;&nbsp;Summary</a></h2>
<p>The most important points in short:</p>
<blockquote>
<ul class="simple">
<li>choose a small discretisation length so that the spin angle stays
well below 30 degrees.</li>
<li>if you want to simulate thin films (or other geometries with a lot
of surface [nodes]), with finite elements, consider how much memory
you would need for the boundary element matrix (best to do this
before you start creating the mesh).</li>
</ul>
</blockquote>
</div>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="manual.html#id228">12&nbsp;&nbsp;&nbsp;Acknowledgements</a></h1>
<p>This work has been financially supported by the <a class="reference external" href="http://www.epsrc.ac.uk">Engineering and
Physical Science Research Council (EPSRC)</a>
(GR/T09156/01,EP/E0400631/1) in the United Kingdom, through funding
from the European Community's Seventh Framework Programme
(FP7/2007-2013) under Grant Agreement no 233552, and by the
<a class="reference external" href="http://www.soton.ac.uk">University of Southampton</a>.</p>
<p>We thank Thomas Schrefl, Wyn Williams, Michael Donahue, Richard
Boardman and Jurgen Zimmermann for useful discussion that have
supported the development of this tool.</p>
<p>Further acknowledgements go to the <a class="reference external" href="http://magnet.atp.tuwien.ac.at/scholz/magpar/">Magpar</a> software and its main
author Werner Scholz. Magpar has provided a finite element
implementation of micromagnetics that has proved very useful in the
development of nmag. Special thanks to Werner Scholz who has discussed
various numerical problems with the nmag team in great depth.</p>
<p>We further thank the beta users for their helpful feedback, in
particular Michael Martens, David Vokoun, Niels Wiese, Gabriel David
Chaves O'Flynn and David Gonzales at the very early stages of the
project.</p>
<!-- comment:
.. _gyromagnetic: http://hussle.harvard.edu/~gabrielse/gabrielse/papers/2006/NewElectronMagneticMoment.pdf -->
<!-- comment:

A summary of the conventions we try to use in this document:

unix prompt: $ (suggested by Thomas) -->
<!-- comment: unused references
.. _EPSRC: http://www.epsrc.ac.uk -->
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="../manual.txt">View document source</a>.
Generated on: 2009-12-22.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
